<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=Windows-1250"><title>8. Programování s SQL</title>


	
	<link rel="STYLESHEET" type="text/css" href="kap8_soubory/main.css">
	<style type="text/css"><!--:hover { font-weight: bold;         color: red }
--></style></head><body alink="Blue" background="kap8_soubory/pozadi.jpg" vlink="Blue">
<a name="k"></a>
<a href="http://www.cs.vsb.cz/amalka/tomica/sql/kap7.html"><img src="kap8_soubory/prev.gif" alt="7. Integritní omezení v SQL"></a>
<a href="http://www.cs.vsb.cz/amalka/tomica/sql/zaver.html"><img src="kap8_soubory/next.gif" alt="Závìreèné pøíklady"></a>
<a href="http://www.cs.vsb.cz/amalka/tomica/sql/index.html"><img src="kap8_soubory/toc.gif" alt="Obsah"></a>
<hr color="Blue" size="1">
<h1>8. Programování s SQL</h1>
<dt><a href="#k1">8.1 Hostitelská verze SQL</a></dt>
<dt><a href="#k2">8.2 Jazyk modulù</a></dt>
<dt><a href="#k3">8.3 Transakce v SQL</a></dt>
<dt><a href="#k4">8.4 Za hranice relaèní úplnosti</a></dt>
<h2><a name="k1"></a>8.1 Hostitelská verze SQL</h2>
<a href="#k"><img src="kap8_soubory/toc.gif" alt="Obsah 8. kapitoly"></a>
<p>Pro zpracování dat v relaèní databázi je potøebná verze SQL v
hostitelské verzi. Až na malé výjimky platí, že každý pøíkaz SQL mùže
být použit beze zbytku v hostitelském jazyku (opak neplatí). Pøíkazy
SQL mohou obsahovat odkazy na promìnné v hostitelském jazyku Tìmto
promìnným je pøedsazen znak : . Lze je použít za INTO v SELECT nebo
FETCH. SELECT, WHERE nebo HAVING, SET v UPDATE, VALUES v INSERT, mohou
být uveden jako prvek skalárního výrazu v SELECT, WHERE, HAVING nebo
SET (ne VALUES). kde výraz se vyhodnocuje jako hodnota, která má být
vybrána, porovnána nebo pøiøazena.</p>
<p>Pøedpokládejme napø., že hostitelským jazykem je PL/l. Všechny
pøíkazy SQL v programu napsaném v PL/I mají pøedtext EXEC SQL a jsou
ukonèeny END_EXEC nebo ; . Základní relace (i pohledy) by mìly být
definovány pøíkazem</p>
<pre>EXEC SQL DECLARE jméno TABLE (...);</pre>
<p class="BEZ">který, na rozdíl od pøíkazù SQL v interakèní verzi, je
pouze deklarativní. Nevytváøí se tedy skuteèné relace, definice jsou
uvedeny pouze z dokumentaèních dùvodù. Kompilátoru jsou však poskytnuty
možnosti urèitých kontrol.</p>
<p> Rozhraní mezi výsledkem SELECT-FROM-WHERE blokem a PL/1 je snadné,
je-li výsledek jednoprvkový. Pak lze užít INTO. Obecnì však rozhraní
mezi SQL a programovacím jazykem. dovoluje pøenést pouze jeden øádek,
bud' z programu do databáze nebo naopak. Toto omezení je dáno pro
zjednodušení situace, která nastává v souvislosti s bìžnými
programovacími jazyky ve kterých nejsou k dispozici možnosti pro
zacházení s množinami øádkù promìnné délky Do hostitelského jazyka
vnoøený pøíkaz SQL SELECT vyžaduje použití INTO specifikujíc promìnné,
kam budou hodnoty z databáze pøiøazeny. Typy promìnných musí být
kompatibilní s odpovídajícími typy atributù relaèní databáze. V SQL
existuje mechanizmus tzv. kurzoru pro specifikaci množiny øádkù, na
kterých je pak možné operovat zpùsobem "po jednom" v èase.</p>
<pre>EXEC SQL DECLARE CURSOR kdo_co
         FOR SELECT (jmeno_c, isbn)
             FROM Rezervace, Ctenar
             WHERE Rezervace.cislo= Ctenar.cislo AND d_rez &gt; :X;
EXEC OPEN kdo_co
     loop:
       EXEC SQL FETCH kdo_co
       INTO(:IJMÉNO ÈT,:IISBN)
     end loop</pre>

<p>Kurzor je tedy vlastnì pojmenovaný použitý pøíkaz SELECT. Chceme-li
pøistoupit ke zpracování øádkù daných kurzorem, je nutné kurzor otevøít
pøíkazem OPEN. Pøíkaz FETCH zajistí umístìní kurzoru na následující
prvek odpovìdi dané vyhodnocením pøíkazu SELECT a dosazení pøíslušných
komponent prvku do promìnných hostitelského jazyka.</p>
<p>Zpìtná vazba po vyvolání pøíkazu SQL se provádí pomocí SQL
Communication Area. speciálnì v promìnné SQLCODE. Navrácená 0 znamená
úspìšnost operace, hodnota +l00 indikuje úspìšnost operace s
upozornìním na výskyt nìjakých výjimeèných podmínek, záporní hodnota
znamená výskyt chyby. Principiálnì za každým pøíkazem SQL by mìl
následovat test na SQLCODE.</p>
<p>Prùchod odpovìdí na dotaz lze tedy øídit testem promìnné SQLCODE.
Pøíkaz FETCH vlastnì realizuje setøídìné procházení odpovìdi na dotaz
daný pøíkazem SELECT v definici kurzoru.</p>
<p>V definici kurzoru je možné použít promìnné X, Y apod., které se v
SELECT pøíkazu zapisují jako :X, :Y Hodnoty promìnných jsou
zpøístupnìny pøi provedení OPEN, takže kurzor mùže poskytovat pro rùzná
volání OPEN rùzné množiny øádkù. V našem pøíkladì lze napø. takto
parametrizovat d_rez. Definice kurzoru s pøíkazem SELECT má zcela
deklarativní charakter, tj. SELECT se v tomto místì nevolá, to se stane
až pøi otevøení kurzoru.</p>
<p>Jestliže kurzor je v nìjaké pozici, lze odpovídající (CURRENT) prvek bud' zmìnit nebo odstranit pøíkazy UPDATE, resp. DELETE.</p>
<pre>EXEC SQL UPDATE Exemplar
         SET cena = cena + :ncena
         WHERE zeme_vydani = `GB'
         WHERE CURRENT OF kur_exem;
EXEC SQL DELETE
         FROM Kniha
         WHERE autor = :kdo
         WHERE CURRENT OF kur_knuh;</pre>
<p>Ovšem aby se mohla provést aktualizace kurzorem kur_exem, je nutné jej definovat s klauzulí FOR UPDATE OF zeme_vydani.</p>
<p>Zbytek manipulaèních pøíkazù (až na jisté výjimky) nevyžaduje
kurzor. Patøí sem použití SELECT dávající jednoprvkovou relaci, INSERT,
DELETE a UPDATE.</p>
<pre>EXEC SQL SELECT jmeno, adresa
         INTO :j_kdo, :a_kdo
         FROM Ctenar
         WHERE cislo = H54;</pre>
<p>Je-li v odpovìdi pouze jeden takový ètenáø (a mìl by být), SQLCODE 0. neexistuje-li. SQLCODE
=+100, je-li jich více, SQLCODE bude mít zápornou hodnotu.</p>
<pre>EXEC SQL INSERT
         INTO Ctenar(cislo, jmeno) 
         VALUES(:cislo,:jmeno);</pre>
<p class="BEZ">tj. hodnota adresa bude NULL.</p>
<pre>EXEC SQL UPDATE Exemplar
         SET cena = cena + :ncena
         WHERE zeme_vydani = `GB';
EXEC SQL DELETE
         FROM Kniha
         WHERE autor = :kdo;</pre>
<h2><a name="k2"></a>8.2 Jazyk modulù</h2>
<a href="#k"><img src="kap8_soubory/toc.gif" alt="Obsah 8. kapitoly"></a>
<p>Standard SQL dovoluje dvì metody pro použití manipulaèních pøíkazù v
aplikaèních programech. Kromì již zmínìného zapojení pøíkazù SQL pøímo
do programu pomocí EXEC SQL lze použít ještì tzv. jazyk modulù. Jde o
jednoduchý jazyk umožòující vytváøet procedury. Procedura se skládá z
hlavièky obsahující jméno procedury, deklarace parametrù a jednoduchého
manipulaèního pøíkazu v SQL. Napø. procedura</p>
<pre>PROCEDURE Vyrad_kus
             SQLCODE
             inv_c_param INTEGER;
          DELETE
          FROM Exemplar
          WHERE Exemplar.id = inv_c_param</pre>
<p class="BEZ">definuje postup vyøazení exempláøe knihy z knihovny.
SQLCODE vrací kód úspìšnosti provedení procedury programu, odkud byla
procedura volána.</p>
<p>Modul se deklaruje vyhrazeným slovem MODULE, jménem modulu, jménem
programovacího jazyka, kam bude modul pøipojen, deklarací kurzorù a
seznamem procedur. Syntaxi lze v první úrovni popsat takto:</p>
<pre>MODULE [jméno-modulu]
LANGUAGE programovací-jazyk
AUTHORIZATION c-identifikátor
[deklarace-kurzorù]...
deklarace-procedury ...</pre>
<p>Program v hostitelském jazyce volá oddìlenì pøeložený program
napsaný v SQL místo v hostitelském jazyce. Není tedy nutné mìnit syntax
hostitelského jazyka. Napø. v
PASCALu by bylo možné (pøí vhodném zaøazení procedury do modulu) použít
proceduru VYØAÏ_KUS takto:</p>
<p><u><b>var</b></u></p>
<pre>INVC: integer; /* pro INV_È */
SQLC: integer; /* pro SQLCODE */</pre>
<p><u><b>begin</b></u></p>
<pre>INVC := 85671
VYØAÏ KUS(INVC) /* vyøadí ètenáøe 85671 */</pre>
<p><u><b>end</b></u></p>
<p>Výhodou toho, že existují dvì verze jazyka v rámci jednoho systému,
je možnost odladit databázové èásti aplikaèního programu interaktivnì.</p>
<h2><a name="k3"></a>8.3 Transakce v SQL</h2>
<a href="#k"><img src="kap8_soubory/toc.gif" alt="Obsah 8. kapitoly"></a>
<p>Standardní SQL podporuje koncepci transakce v rámci hostitelského
jazyka. Transakce je definována jako posloupnost pøíkazù SQL formující
jednotku zotavení z chyb a soubìžného zpracování.</p>
<p>Transakce jsou implicitní v tom smyslu, že první pøíkaz SQL znamená
poèátek transakce. Každá transakce konèí vyvoláním bud' pøíkazu COMMIT
WORK (normální ukonèení) nebo ROLLBACK WORK (nenormální ukonèení).</p>
<p>V pøípadì chyby èi splnìní dané podmínky se zpracování transakce
pøeruší a databáze se uvede do stavu pøed transakcí, v opaèném pøípadì
dojde k provádìní pøíkazù a k dokonèení transakce a vytvoøení
permanentní verze nové databáze. Pøíkazy jsou z množiny manipulaèních
pøíkazù jazyka SQL.</p>
<p>Lze se setkat i s jiným formátem transakce:</p>
<pre>TRANSACTION jméno-transakce
    WHENEVER {ERROR I podmínka} ROLLBACK
    pøíkazy
COMMIT END</pre>
<p>Jako pøíklad uveïme transakci, která by mìla pøehodnotit ceny všech
nìmeckých knih pùvodnì vedených v DM na ceny v èeských korunách.</p>
<pre>TRANSACTION Prehodnoceni
    WHENEVER ERROR ROLLBACK
    UPDATE Exemplar
    SET cena = cena* 18 WHERE zeme_vydani = 'SRN'
COMMIT END</pre>
<h2><a name="k4"></a>8.4 Za hranice relaèní úplnosti</h2>
<a href="#k"><img src="kap8_soubory/toc.gif" alt="Obsah 8. kapitoly"></a>
<p>Dokázat, že SQL je relaènì úplný jazyk není obtížné, i když dùkaz je
proveden na základì možnosti rozložit dotaz na poddotazy, tj.
jednotlivé relaèní operace relaèního výrazu se realizuj í samostatnými
pøíkazy SQL. Nalézt obecnì k libovolnému relaènímu výrazu ekvivalentní
SELECT blok by bylo zøejmì obtížné, ne-li nemožné.</p>
<p>Jde vlastnì o to. nalézt pro každou operaci relaèní algebry odpovídající vyjádøení v SQL.</p>
<dl>
<ul type="circle">
<li>sjednocení T:=R U S
<pre>INSERT INTO T
       SELECT * FROM R
INSERT INTO T
       SELECT * FROM S</pre>
</li><li>rozdíl T:=R - S
<pre>INSERT INTO T
       SELECT * FROM R
DELETE FROM T
       WHERE K IN (SELECT K FROM S)
<i>kde K je klíèem v R i v S.</i></pre>
</li><li>kartézský souèin T:=R x S
<pre>INSERT INTO T
       SELECT R.*,S.* F
       FROM R,S</pre>
</li></ul>	   
</dl>	   
<p>Selekce a projekce vyplývají pøímo z vlastností základního SELECT
bloku. Øada relaèních SØBD obsahuje konstrukty jdoucí za rámec
relaèních jazykù. Napø. ORACLE-SQL dovoluje použití rekurzivního
SELECT-FROM-WHERE bloku, kterým lze realizovat dotazy na tranzitivní
uzávìr relace, které nejsou v pùvodní verzi SQL vyjádøitelné.</p>
<p>Pøedpokládat budeme schéma relace</p>
<pre>JE_ÈÁSTÍ(OBJEKT.NADOBJEKT,POÈ STRAN)</pre>
<p class="BEZ">vyjadøující pøímé vztahy mezi objekty a jejich
nadobjekty. Aplikaèní doménou bude dokumentace o daných objektech. Za
objekty lze zvolit napø. jisté projekty, tj. v relaci JE_ÈASTÍ* se
tøeba nachází trojice (RDBS,IS,500), kde RDBS znamená relaèní
databázový systém, tj. platí, že RDBS je èástí IS a jeho dokumentace
èiní 500 stran. Pøíklad relace JE ÈÁSTÍ* je dán orientovaným grafem na
obr.1.</p>
<center><img src="kap8_soubory/obr1.htm">
<br><i>Obr. è.1 Relace JE_ÈÁSTÍ*</i></center>
<p>Všimnìme si, že nejde nutnì o stromovou strukturu, DODÁVKY patøí do
dokumentace jak svazku EXTERNÍ_VAZBY, tak ke svazku APLIKACE.
Dokumentace objektu neznamená, že se jedná o podèást dokumentace
nadobjektu, spíše jde o další navazující svazek. Pracovníci používající
IS jsou školeni tak, že pro vyškolení v nìjakém objektu O musí
absolvovat celou cestu v grafu, poèínaje IS a objektem O konèe. Ke
školení obdrží vždy kompletní dokumentaci objektù na dané cestì.</p>
<p>Dále ještì uvažujme relaci</p>
<pre>SVAZKY(<u>OBJEKT</u>,AUTOR,DATUM VYDÁNÍ,VERZE)</pre>
<p>Tranzitivní uzávìr relace pøedstavuje pouze jeden z možných typù rekurzivních dotazù. Jde napø. o dotaz</p>
<b>D41.</b> Najdi všechny podobjekty objektu APLIKACE <p> </p>
<p>tj. všechny navazující díly dokumentace k dílu APLIKACE.</p>
<p>Jde tedy vlastnì o dotaz na jistou dosažitelnost uzlù ve smìru šipek
v daném grafu. Užiteèné dotazy jsou však i proti smìru tìchto šipek.
Napø. bychom se mohli ptát na všechna školení, která pøedcházejí kurzu
DODÁVKY (jde o APLIKACE, EXTERNÍ VAZBY, IS).</p>
<p>Jiným typem dotazu je <i> vyèíslení všech cest</i> z daného uzlu do všech listù, tj. napø. dotaz</p>
<b>D41'. </b> "Najdi úplnou strukturu objektu IS se všemi navazujícími díly do všech úrovní".
Na obr. 2 je stromová reprezentace výsledku takového dotazu.<p></p>
<center><img src="kap8_soubory/obr2.htm">
<br><i>Obr. è.2 Cesty dané relací JE_ÈÁSTÍ*</i></center>
<p>K dotazu tohoto typu lze pøidat také požadavek na dílèí agregaci
shora dolù, napø. celkový poèet stránek pro daný objekt na dané cestì.
Obsahuje-li napø. relace JE ÈASTÍ* následující øádky</p>

<table align="center" border="0" cellpadding="10" cellspacing="0">
<tbody><tr>
	<td>IS</td>	<td>dokumentace</td>	<td>20</td>
</tr>
<tr>
	<td>aplikace</td>	<td>IS</td>	<td>300</td>
</tr>
<tr>
	<td>externí_vazby</td>	<td>IS</td>	<td>170</td>
</tr>
<tr>
	<td>dodávky</td>	<td>externí_vazby</td>	<td>20</td>
</tr>
<tr>
	<td>dodávky</td>	<td>aplikace</td>	<td>20</td>
</tr>
<tr>
	<td>RDBS</td>	<td>IS</td>	<td>800</td>
</tr>
<tr>
	<td>výpùjèky</td>	<td>aplikace</td>	<td>25</td>
</tr>
<tr>
	<td>rezervace</td>	<td>aplikace</td>	<td>12</td>
</tr>
<tr>
	<td>povinné</td>	<td>dodávky</td>	<td>2</td>
</tr>
<tr>
	<td>kupované</td>	<td>dodávky</td>	<td>6</td>
</tr>
<tr>
	<td>výpoèetní služby</td>	<td>externí_vazby</td>	<td>130</td>
</tr>
</tbody></table>

<p>pak celkový poèet stránek pro objekt DODÁVKA na cestì pøes APLIKACE
by byl 340, pøes EXTERNÍ_VAZBY 190. Aplikuje se tedy agregaèní funkce
SUM. Výsledek lze napø. interpretovat jako poèet stránek, které obdrží
pracovník na daném školení.</p>
<p>Koneènì <i>agregace cest</i> znamená uvažovat opìt graf na obr.2.
aplikovat eventuálnì nìjaký výpoèet na jednotlivých cestách a provést
jisté souèty pøi spojení cest do grafu na obr. 2. V naší aplikaci by
byl smysluplný jednoduchý dotaz</p>
<b>D41".</b> Kolik stránek až mùže obdržet pracovník pro objekt DODÁVKA
(tj. do výsledku se zahrnují dokumentace jak od cesty pøes APLIKACE,
tak pøes EXTERNÍ VAZBY).
V dotazu D41" jsou samozøejmì zahrnuty nìkteré díly dokumentace
dvakrát. ORACLE-SQL podporuje dotazy na tranzitivní uzávìr a vyèíslení
všech cest.
<b>D41"(ORACLE-SQL)</b>
<pre>SELECT level, objekt, nadobjekt
FROM Je_èástí
CONNECT BY PRIOR objekt = nadobjekt
START WITH nadobjekt = `IS'</pre>
<p>Výsledkem bude speciálnì uspoøádaná tabulka obsahující øádky</p>
<table align="center" border="0" cellpadding="10" cellspacing="0">
<tbody><tr>
	<td>1</td>	<td>RDBS</td>	<td>IS</td>
</tr>
<tr>
	<td>1</td>	<td>aplikace</td>	<td>IS</td>
</tr>
<tr>
	<td>2</td>	<td>výpùjèky</td>	<td>aplikace</td>
</tr>
<tr>
	<td>2</td>	<td>rezervace</td>	<td>aplikace</td>
</tr>
<tr>
	<td>2</td>	<td>dodávky</td>	<td>aplikace</td>
</tr>
<tr>
	<td>3</td>	<td>povinné</td>	<td>dodávky</td>
</tr>
<tr>
	<td>3</td>	<td>kupované</td>	<td>dodávky</td>
</tr>
<tr>
	<td>1</td>	<td>externí_vazby</td>	<td>IS</td>
</tr>
<tr>
	<td>2</td>	<td>dodávky</td>	<td>externí_vazby</td>
</tr>
<tr>
	<td>3</td>	<td>povinné</td>	<td>dodávky</td>
</tr>
<tr>
	<td>3</td>	<td>kupované</td>	<td>dodávky</td>
</tr>
<tr>
	<td>2</td>	<td>výpoèetní služby</td>	<td>externí vazby</td>
</tr>
</tbody></table>


<p>Uspoøádání pomocí ORDER BY nemá smysl, protože se tím ztratí
struktura cest. Uspoøádání dané explicitnì ve výsledku ovšem omezuje
použití výsledku v dalším zpracování. Výsledek totiž není skuteèná
tabulka ve smyslu SQL.</p>
<p>Použitý konstrukt má ovšem jistá omezení. Napø. nelze generovat pro
jednotlivé podobjekty celkový poèet stránek daný cestou od IS. CONNECT
BY také neumožòuje formulovat spojení více relací, tj. nelze napø.
pøipojit k výsledným øádkùm informace z relace SVAZKY.</p>
<p>Jak se vypoøádat s omezením SQL pøi øešení uvedených problémù, je
navrženo v [Fr93]. Užiteèná mùže být speciální relace obsahující
vyèíslení všech cest (jejich krajních bodù) spolu s nìkterými dalšími
informacemi. V našem pøíkladì by mohla mít tvar daný tab. 5. Nazveme ji
VVC (tab.6 obsahuje pouze èást danou nadobjektem IS.)</p>
<table align="center" border="1" cellpadding="4" cellspacing="1">
<caption align="top"><i>Tabulka 5 Relace VVC*</i></caption>
<tbody><tr align="left" bgcolor="Lime">
    <th colspan="6"><b>VVC</b></th>
</tr>
<tr align="center" bgcolor="White">
    <th>PÈ</th> 
	<th>ÚROVEÒ</th> 
	<th>OBJEKT</th>
	<th>NADOBJEKT</th> 
	<th>MAX_PODSTROM</th> 
	<th>SUMA</th>
</tr>
<tr align="center">
	<td>1</td>
	<td>1</td>
	<td>RDBS</td>
	<td>IS</td>
	<td>1</td>
	<td>820</td>
</tr>
<tr align="center">
	<td>2</td>
	<td>1</td>
	<td>aplikace</td>
	<td>IS</td>
	<td>7</td>
	<td>320</td>
</tr>
<tr align="center">
	<td>3</td>
	<td>2</td>
	<td>výpùjèky</td>
	<td>IS</td>
	<td>3</td>
	<td>345</td>
</tr>
<tr align="center">
	<td>4</td>
	<td>2</td>
	<td>rezervace</td>
	<td>IS</td>
	<td>4</td>
	<td>332</td>
</tr>
<tr align="center">
	<td>5</td>
	<td>2</td>
	<td>dodávky</td>
	<td>IS</td>
	<td>7</td>
	<td>340</td>
</tr>
<tr align="center">
	<td>6</td>
	<td>3</td>
	<td>povinné</td>
	<td>IS</td>
	<td>6</td>
	<td>342</td>
</tr>
<tr align="center">
	<td>7</td>
	<td>3</td>
	<td>kupované</td>
	<td>IS</td>
	<td>7</td>
	<td>346</td>
</tr>
<tr align="center">
	<td>8</td>
	<td>1</td>
	<td>externí_vazby</td>
	<td>IS</td>
	<td>12</td>
	<td>190</td>
</tr>
<tr align="center">
	<td>9</td>
	<td>2</td>
	<td>dodávky</td>
	<td>IS</td>
	<td>11</td>
	<td>210</td>
</tr>
<tr align="center">
	<td>10</td>
	<td>3</td>
	<td>povinné</td>
	<td>IS</td>
	<td>10</td>
	<td>212</td>
</tr>
<tr align="center">
	<td>11</td>
	<td>3</td>
	<td>kupované</td>
	<td>IS</td>
	<td>11</td>
	<td>216</td>	
</tr>
<tr align="center">
	<td>12</td>
	<td>2</td>
	<td>výpoèetní_služby</td>
	<td>IS</td>
	<td>12</td>	
	<td>150</td>
</tr>
</tbody></table>
<p>Poøadové èíslo PÈ udává poøadí uzlu v prùchodu stromem, který se v
teorii algoritmù nazývá preorder, max_podstrom je pè nejvzdálenìjšího
uzlu podstromu daného uzlem ve sloupci OBJEKT. Napø pro APLIKACE v
øádku s PÈ = 2 je to uzel s pè = 7, pro EXTERNÍ VAZBY na øádku 8 èiní
hodnota max_podstrom=12.</p>
<p>Je jisté, že tuto tabulku lze zatím získat pouze procedurálním zpùsobem (napø. v jazyku 4GL nebo hostitelském jazyku).</p>
<p>Rùzné rekurzivní dotazy lze pak øešit snadno nad touto tabulkou.</p>
<b>D41.</b>
<pre>SELECT DISTINCT objekt, nadobjekt
FROM VVC
WHERE nadobjekt = `IS'</pre>
<p>Dotaz D41' rozšíøený o souèty stránek svazkù na uvažovaných cestách z uzlu IS v grafu získáme pøímo jako</p>
<b>D41'</b> 
<pre>SELECT *
FROM VVC
WHERE nadobjekt = `IS'
ORDER BY pè</pre>
<p>Dotaz D41" vyžaduje GROUP BY a použití SUM.</p>
<b> D41"</b>
<pre>SELECT objekt, nadobjekt, SUM(suma)
FROM VVC
WHERE nadobjekt = `IS' GROUP BY nadobjekt, objekt</pre>
<p>Zkusíme nyní modifikovat dotaz D41 tak, že budeme navíc vyžadovat
eliminaci objektu DODÁVKA vèetnì všech jeho podobjektù. K tomu se
využije znalost hodnot atributu max_podstrom.</p>
<pre>SELECT DISTINCT prvni.objekt, prvni.nadobjekt
FROM VVC prvni, VVC druha
WHERE prvni.nadobjekt = `IS' AND druha.nadobjekt = `IS'
      AND druha.objekt = `dodavka'
	  AND (prvni.pè NOT BETWEEN druha.pè AND
	  druha.max_podstrom)</pre>
<p>Z relace VVC* v tab. 6 tak budou vylouèeny øádky 9,10,11.</p>
<p>Závìrem ještì ukážeme, jak lze v ORACLE-SQL øešit spojení s jinými
relacemi, tj. dotaz D41 ve verzi s pøidanými informacemi o objektech.</p>
<pre>SELECT DISTINCT objekt, autor, datum_vydani, verze
FROM svazky
WHERE objekt IN (SELECT objekt                          
		 FROM Je_èástí
		 CONNECT BY PRIOR objekt = nadobjekt
		 START WITH nadobjekt = `IS')</pre>
<hr color="Blue" size="1">
<a href="http://www.cs.vsb.cz/amalka/tomica/sql/kap7.html"><img src="kap8_soubory/prev.gif" alt="7. Integritní omezení v SQL" align="left"></a>
<a href="http://www.cs.vsb.cz/amalka/tomica/sql/zaver.html"><img src="kap8_soubory/next.gif" alt="Závìreèné pøíklady" align="left"></a>
<a href="http://www.cs.vsb.cz/amalka/tomica/sql/index.html"><img src="kap8_soubory/toc.gif" alt="Obsah" align="left"></a>
</body></html>