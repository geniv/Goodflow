<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Seriál o PHP</title>
<link href="css/style.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="000001"></a><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (1) - Historie a budoucnost</h2>
			<p class="perex">Od dnešního dne začíná vycházet nový seriál o PHP.
				<br>
			</p>
<a name="000002"></a><h2>Historie jazyka PHP</h2>
<p>
PHP je skriptovací jazyk pro tvorbu dynamického webu a jeho počátky
spadají do roku 1994. Tehdy se pan Rasmus Lerdorf rozhodl vytvořit
jednoduchý systém pro počítání přístupu ke svým stránkám; bylo to
napsáno v PERLu. Za nějakou dobu byl systém přepsán do jazyka C,,
protože perlovský kód dost zatěžoval server. Sada těchto skriptů byla
ještě později téhož roku vydána pod názvem "Personal Home Page Tools",
zkráceně PHP. Ještě potom se to jmenovalo "Personal Home Page
Construction Kit".
</p>
<p>
U toho však nezůstalo. V polovině roku 1995 se systém PHP spojil s
jiným programem stejného autora, a to sice s nástrojem "Form
Interpreter" neboli zkráceně FI. Tak vzniklo PHP/FI 2.0, systém, který
si postupně získal celosvětovou proslulost a byl velmi rozšířen.
</p>
<p>Koncem roku 1998 byla již k dispozici verze PHP 3.0, která byla
mnohem rychlejší (a vybavenější) než "dvojka" a která byla k dispozici
rovněž pod operačními systémy Windows. Počet webů které používaly PHP
se zvyšoval, až dosáhl cca 150 000. "Čtyřkové" verze PHP, které jsou k
dispozici nyní, přidávají do jazyka mnoho nových funkcí a rovněž
přinášejí přepracované a tudíž podstatně rychlejší jádro Zend. <br>
</p>
<p>Podle údajů z dubna 2004 běží PHP na více než 15 000 000 doménách a
je to bezkonkurenčně nejčastěji používaný modul webového serveru
Apache. Zkratka PHP by se měla překládat jako "PHP: Hypertext
preprocessor", česky bychom řekli asi něco ve stylu "předzpracovávač
hypertextu" (je to opravdu česky? ;-) )
Úvaha o počátcích PHP by nebyla úplná, kdybychom se krátce nezmínili
rovněž o jeho budoucím vývoji. V době psaní tohoto článku je již k
dispozici Release Candidate 2 verze PHP 5 a podle vývojářů se máme na
co těšit. Namátkou – jádro Zend II, kompletně přepsaná podpora XML,
nové objektové rozhraní pro práci s databází MySQL a mnoho dalšího.
Čili, systém je stále vybavován novými technologiemi a je aktivně
vyvíjen.
</p>
<a name="000003"></a><h2>Proč ano a proč ne</h2>
<p>
Proč je PHP tak oblíbené? K tomu vede celá řada věcí:
</p>
<ul>
<li>PHP je relativně jednoduché na pochopení</li>
<li>PHP má syntaxi velmi podobnou jazyku C a je tedy většině vývojářů
dost blízký </li>
<li>PHP podporuje širokou řadu souvisejících technologií, formátů a
standardů</li>
<li>je to otevřený projekt s rozsáhlou podporou komunity</li>
<li>dají se najít kvanta již hotového kódu k okamžitému použití nebo
funkční PHP aplikace. Podstatná část z hotového kódu je šířena pod
nějakou svobodnou licencí a dá se použít ve vlastních projektech<br>
</li>
<li>PHP si dobře rozumí s webovým serverem Apache (aby ne, vždyť je
to sesterský projekt spravovaný Apache software foundation)</li>
<li>PHP snadno komunikuje s databázemi, jako je MySQL, PostgreSQL a
řada dalších</li>
<li>PHP je multiplatformní a lze jej provozovat s většinou webových
serverů a na většině dnes existujících operačních systémů<br>
</li>
<li>PHP podporuje mnoho existujících poskytovatelů webhostingových
služeb</li>
</ul>
<a name="000004"></a><h2>Má PHP také svoje nevýhody?</h2>
<p> Víceméně ne; pokud budete chtít napsat dynamický web, bude PHP
prakticky vždy dobrou volbou. S některými věcmi byste ale přesto měli
při použití PHP počítat:
</p>
<ul>
<li>PHP je interpretovaný, ne kompilovaný jazyk</li>
<li>kdokoli má přímý přístup k serveru, může nahlédnout do vašich PHP
skriptů</li>
<li>Podpora objektového programování není v PHP na moc dobré úrovni.
V PHP 5 by se to ale mělo zlepšit.<br>
</li>
<li>protože je PHP aktivně vyvíjen, v budoucích verzích jazyka se
mohou některé funkce změnit nebo se mohou chovat jinak než dosud. <br>
</li>
</ul>
<a name="000005"></a><h2>Co se v PHP dá napsat ?</h2>
<p>
Lakonická odpověď by zněla: Téměř všechno, co nějak souvisí s
dynamickým webem a/nebo s databázemi. Mezi nejčastější aplikace psané v
PHP patří například:
</p>
<ul>
<li>internetové obchody</li>
<li>podnikové informační systémy (ať už intranetové nebo internetové)</li>
<li>diskusní fóra</li>
<li>redakční systémy</li>
<li>firemní prezentace</li>
<li>dynamické osobní stránky</li>
<li>weboví poštovní či databázoví klienti</li>
<li>vyhledávače a katalogy</li>
<li>drobnosti typu počitadla, ankety a mnoho dalších </li>
</ul>
<a name="000006"></a><h2>O čem bude náš seriál ?</h2>
<p>
Na své si při čtení našeho seriálu přijdou začínající i pokročilí
uživatelé PHP. Nejprve se v několika dílech podíváme na jazyk samotný –
na jeho syntaxi, výrOperační systémazy, operátory, konstrukce, příkazy a podobně. Dále
se budeme věnovat práci se soubory a formuláři. Velkou pozornost budeme
věnovat databázím; nejprve obecně a zvlášť MySQL. Ukážeme si, jak lze
PHP pro práci s databázemi použít a jaká úskalí nás přitom čekají.
Dotkneme se otázek kolem autentifikace uživatelů a bezpečnosti webové
aplikace vůbec. Zakončíme několika díly popisujícími, co byste měli
vědět při práci na rozsáhlejším projektu a příkladem jednoho takového
projektu. Takže se máte na co těšit.
</p>
<p>Příště se krátce podíváme na to, jak vlastně PHP funguje a co z toho
pro vývojáře vlastně vyplývá.<br>
</p>

			<hr>
<a name="000007"></a><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (2) - Jak to funguje</h2>
			<p class="perex">V
minulém díle jsme si ukázali, co PHP vlastně je a k čemu všemu se dá
použít. Dnes se zaměříme na to, co to PHP zhruba dělá a jak celá
komunikace mezi serverem a prohížečem při použití tohoto jazyka
funguje. <br>
			</p>
			<p>Jestliže s PHP začínáte, měli byste si tento článek pečlivě přečíst.
Setkal jsem se totiž s lidmi, kteří sice s tímto jazykem už nějakou
dobu pracují, ale přesto jim uniká princip - a dělají tak základní
koncepční chyby.
</p>
<a name="000008"></a><h2>Princip PHP</h2>
<p>
V době internetového pravěku byly všechny
internetové stránky statické. Prostě tak, jak byla stránka napsána, tak
byla odeslána do prohlížeče a tak byla také zobrazena. To pochopitelně
časem přestávalo stačit, a proto byla vyvinuta celá řada technologií,
které měly stránky rozpohybovat. Zhruba řečeno se dají tyto technologie
rozdělit do dvou skupin, na "klientské" a "serverové".</p>
<p>"Klientské"
technologie se spoléhají na jednoduchou věc: Spolu s HTML stránkou je
prohlížeči odeslán i nějaký kus programového kódu a ten je ve vhodnou
chvíli na "cílovém" počítači spuštěn. Vhodná chvíle může nastat
například při kliknutí na tlačítko, při najetí myší na odkaz, při
otevření okna prohlížeče a podobně. O spuštění klientského kódu se
stará
prohlížeč - a to může být nevýhoda. Prohlížeč totiž musí znát
programovací jazyk, v němž je kód napsán. Příkladem
technologií běžících na straně klienta je například Java script. Máme o
něm na Linuxsoftu <a href="http://www.linuxsoft.cz/article_list.php?id_kategory=195">seriál</a>.
</p>
<p>"Serverové" technologie jsou založeny na jiném principu. Když
prohlížeč
požaduje webovou stránku ze serveru, server tuto stránku nejprve
sestaví a pak odešle. Servery mohou (a také to často dělají) sestavovat
pokaždé jinou stránku v závislosti na tom, co přesně prohlížeč
požaduje. <br>
</p>
<p>PHP JE TECHNOLOGIE BĚŽÍCÍ NA SERVERU. Typický PHP skript
obsahuje jednak kusy normálního HTML kódu, a jednak kusy programového
kódu. Když webový server obdrží požadavek na zpracování takového
skriptu, vezme:
</p>
<ul>
  <li> kusy HTML kódu tak, jak jsou</li>
  <li> části PHP programového kódu provede</li>
  <li> výsledek zkombinuje a odešle prohlížeči</li>
</ul>
<p>Tato filozofie fungování je nesmírně mocná. Server totiž může
provést jednu nebo dokonce několik operací a výsledek poslat do
prohlížeče jako obyčejnou HTML stránku. Jakmile tento koncept
pochopíte, můžete začít psát PHP skripty. Celé si to předvedeme na malé
ukázce: Následující kód je obyčejná HTML stránka. Když si ji prohlížeč
vyžádá, uvidíte v něm jen řádek mezi značkami.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;HTML&gt;<br>
Já jsem obyčejná stránka. Nic neumím. <br>
&lt;/HTML&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Následující kód je
PHP skript. Všimněte si, že se skládá jednak
z HTML kódu, a jednak z PHP kódu. V některém z dalších dílů to
rozebereme podrobněji, teď ale jen uvedu, že to, co vidíte mezi
značkami &lt;? a ?&gt; je právě PHP kód. Příkaz echo vypisuje text na
standardní výstup a příkaz Date vrací aktuální čas: </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;HTML&gt; <br>
Já jsem speciální stránka. Vím, že právě je <font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">Date</font><font color="#007700">(</font><font color="#dd0000">"G:i"</font><font color="#007700">)</font><font color="#0000bb">?&gt;<br>
</font>&lt;/HTML&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Jak asi tušíte, stránka vám vypíše
aktuální čas na serveru v
době, kdy byla generována. To proto, že kód mezi značkami &lt;? a ?&gt;
se na serveru nejprve provede a teprve pak se výsledek odešle
prohlížeči. Jinými slovy, do prohlížeče dorazí něco jako: </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;HTML&gt;<br>
Já jsem speciální stránka. Vím, že právě je 21:08 <br>
&lt;/HTML&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Prohlížeč nemá sebemenší tušení, co všechno se na serveru dělo
než mu byl výstup odeslán, vidí jen samotný výsledek. Dodejme, že dít
se na serveru mohla celá řada věcí – matematické výpočty, přístupy k
databázím, formátování, operace s řetězci a podobné taškařice. Z toho
vyplývá několik důležitých věcí. </p>
<p>Za prvé, abyste mohli PHP
skript skutečně spustit, musíte ho "prohnat" serverem. Když ho otevřete
v textovém editoru nebo si ho prohlédnete jako soubor na disku,
neuvidíte <span style="font-style: italic;">výsledek</span>, ale <span style="font-style: italic;">zdrojový kód</span> skriptu. To se Vám
může plést
zejména tehdy, když máte PHP skript na vlastním počítači a používáte na
prohlížení souborů na disku stejný nástroj jako na prohlížení obsahu
sítě internet (třeba Konqueror). PHP soubor proženete serverem tak, že
se na něj zeptáte prohlížeče pomocí adresy url. Například pomocí <span style="font-weight: bold;">http://localhost/skript.php</span>
můžete skutečně donutit server, aby skript
zpracoval a poslal Vám výsledek, zatímco prostřednictvím <span style="font-weight: bold;">file://var/www/html/skript.php</span>
zobrazíte jen zdrojový soubor. </p>
<p>Za
druhé – PHP skripty nejsou vlastně vůbec závislé na použitém
prohlížeči, protože ten s nimi nepřijde do styku. Všechnu práci si
odskáče server a do prohlížeče dorazí jen prosté HTML.<br>
</p>
<p>Za třetí – části PHP kódu se do skriptů vkládají pomocí
speciálních značek. Z ukázky to sice nevyplývá, ale v úvahu přicházejí
následující možnosti kombinace HTML a PHP kódu v jednom souboru: </p>
<ol>
  <li> Celý soubor může být jeden dlouhý PHP kód. Pak začíná a končí
znaky &lt;? a ?&gt;</li>
  <li> V souboru může být kód PHP jen na jednom určitém místě.</li>
  <li> V souboru ale klidně může být více než jedno místo obsahující
PHP kód</li>
  <li> Soubor se sice může tvářit jako php skript, ale ve skutečnosti
je to normální HTML soubor a PHP kód v něm vůbec není.</li>
</ol>
<p>Za čtvrté: Jelikož výsledkem PHP skriptu je normální HTML
stránka, neměli byste se pouštět do práce v PHP, pokud alespoň zběžně
neznáte HTML.
Tyto technologie se můžete učit současně, ale není nad to naučit se
nejprve HTML a pak se pustit do PHP. Mimochodem, o HTML máme na
Linuxsoftu <a href="http://www.linuxsoft.cz/article_list.php?id_kategory=172">seriál</a>.
</p>
<p>A konečně za páté – jak jste asi
pochopili, když si budete chtít
vyzkoušet fungování skriptu ve skutečném světě, měli byste mít k
dispozici nějaký webový server. A právě o tom, co všechno byste měli
mít k dispozici pro práci s PHP bude další díl našeho seriálu. </p>

			<hr>

<a name="000009"></a><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (3) - Instalace</h2>
			<p class="perex">V tomto díle seriálu o PHP si ukážeme, co budeme k jeho provozování potřebovat.
				<br>
			</p>
			<p>V předchozí části našeho PHP seriálu jsme se
dozvěděli, jak webový server zpracovává PHP kód a posílá jej prohlížeči
sítě internet k zobrazení. Dnes
se podíváme na to, jaký software je pro práci s PHP nezbytný a kde jej
najdete.
</p>
<p>Bez dobrých nástrojů je jakákoli práce přinejmenším velmi
náročná. Pokud to s PHP myslíte vážně, sežeňte si vše potřebné co
nejdříve, ať si to můžete nainstalovat, nastavit a začít to používat!
Mnoho nadšenců chce psát už od Prvního Dne a diví se, že velice záhy
narazí na nějaký problém, který s PHP skoro nesouvisí, ale který musí
rychle vyřešit (třeba konfigurace, práva nebo zabezpečení). Takže, co
budeme potřebovat: Budeme
potřebovat světlo, neboli <span style="font-weight: bold;">LAMP</span>.
Skutečně, ideální kombinace pro práci s
PHP je <span style="font-weight: bold;">L</span>inux, <span style="font-weight: bold;">A</span>pache, <span style="font-weight: bold;">M</span>ySQL a <span style="font-weight: bold;">P</span>HP (lamp je anglicky; česky to
znamená
lampa, svítilna nebo žárovka). Uvedená sada nástrojů se může prokázat
opravdu jako nejlepší. Zmíním se i o alternativách, ale tohle je
vyzkoušené.
</p>
<a name="000010"></a><h2>Operační systém</h2>
<p>Máte-li svou oblíbenou distribuci GNU/Linuxu, neváhejte a použijte
ji. Jestliže
ne, můžete si vybrat třeba v sekci DISTRIBUCE na <a href="http://www.linuxsoft.cz/distro_list.php?id_kategory=1" target="_blank">našem
serveru</a>. Zmíněný
software můžete nainstalovat na prakticky libovolný GNU/Linux systém,
včetně distribucí typu SSSL (Sestav Si Svůj Linux). Poznámky pro
uživatele
Windows budou v závěru článku.
</p>
<a name="000011"></a><h2>Webový server</h2>
<p>V prvním díle jsme si řekli, že PHP funguje pod kdečím. Nejlépe si
ale
rozumí se serverem Apache, proto bude instalace Apache serveru asi tou
nejlepší volbou. Apache najdete na <a href="http://httpd.apache.org/" target="_blank">http://httpd.apache.org</a>
nebo jako
připravený balíček ve Vaší distribuci (pokud Vaše distribuce používá
nějaký balíčkovací systém). Nastavení serveru Apache se provádí úpravou
konfiguračních souborů, zejména pak souboru httpd.conf. Bývá
komentovaný. Dokumentace k nastavení Apache je na
<a href="http://httpd.apache.org/docs-2.0/configuring.html" target="_blank">http://httpd.apache.org/docs-2.0/configuring.html</a>
a patří mimochodem k
nejpovedenějším stránkám nápovědy, které jsem kdy viděl. Nějaké české
zdroje můžete najít například na <a href="http://www.jakpsatweb.cz/server.htm" target="_blank">http://www.jakpsatweb.cz/server.htm</a>.<br>
</p>
<p>Začátečníci často narážejí na problém, který se projevuje tak, že po
zadání URL se do prohlížeče nevrátí výsledek skriptu, ale jeho zdrojový
kód. To je způsobeno tím, že server Apache netuší, že by měl soubor php
zpracovat jako skript, případně proto, že nemá, čím by to udělal. V
konfiguračním souboru Apache tedy musejí být přibližně tyto řádky:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">LoadModule php4_module
modules/libphp4.so<br>
AddType application/x-httpd-php .php<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Pokud budete navíc chtít, aby se po zadání url zobrazil soubor
index.php (pokud je a pokud není specifikován jiný soubor), proveďte
něco jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">DirectoryIndex index.php<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<a name="000012"></a><h2>Databáze MySQL</h2>
<p>Protože se v dalších dílech budeme věnovat rovněž MySQL databázi,
pojďme ji rovnou nainstalovat. Domovská stránka tohoto projektu je
<a href="http://www.mysql.com/" target="_blank">http://www.mysql.com</a>
a MySQL
pravděpodobně bude rovněž existovat jako
balíček ve Vaší distribuci.<br>
</p>
<p><span style="font-style: italic;">Pozn.: O MySQL máme na Linuxsoftu </span><a style="font-style: italic;" href="http://www.linuxsoft.cz/article_list.php?id_kategory=232">seriál</a><span style="font-style: italic;">. </span><a style="font-style: italic;" href="http://www.linuxsoft.cz/article.php?id_article=736">Tento</a><span style="font-style: italic;"> a </span><a style="font-style: italic;" href="http://www.linuxsoft.cz/article.php?id_article=738">tento</a><span style="font-style: italic;"> díl rozebírají instalaci databázového
systému MySQL podrobněji.</span><br>
</p>
<a name="000013"></a><h2>PHP</h2>
<p>Ovšem, budete potřebovat PHP samotné. To žije na <a href="http://www.php.net/" target="_blank">http://www.php.net</a>,
české zrcadlo je na <a href="http://www.php.cz/" target="_blank">http://www.php.cz</a>.
V době psaní článku je k
dispozici stabilní verze 4.3.6. Na serveru je k dispozici je stažení
jako zdrojový kód a možná i nějaké ty binární soubory.
</p>
<a name="000014"></a><h2>Ostatní</h2>
<p>To nejsou jediné věci, které budete pro práci s PHP potřebovat.
Budete
potřebovat prohlížeč; dobrý designér bude chtít vidět výsledek dokonce
v několika různých prohlížečích. <a href="http://www.mozilla.cz/" target="_blank">Mozilla</a>
by mohla být dobrou volbou;
jistě ale máte mezi prohlížeči svého favorita. Budete potřebovat rovněž
nějaký textový editor pro práci se zdrojovým kódem PHP; nejlepší je
ten, který Vám nejlépe vyhovuje. Pro mě by například dobrý PHP editor
měl mít barevné zvýrazňování syntaxe, odsazování bloků, pružnou
konfiguraci a měl by být k dispozici pod GNU/GPL. WYSIWYG ("what you
see is what you get", "co vidíš, to dostaneš") editory obecně nebývají
pro práci s PHP moc dobré, lepší je nějaký opravdu textový editor. Pro
práci na lokálním počítači je to myslím všechno; budete-li chtít
nahrávat skripty na vzdálený server, bude to většinou pomocí
nějakého ftp klienta.
</p>
<a name="000015"></a><h2>Windows</h2>
<p>PHP lze vyvíjet i pod Windows. Pokud mohu z vlastní zkušenosti
poradit
– zanechte pokusů rozběhnout PHP pod Personal Web serverem z Windows 9x
nebo Internet Information Serverem z Windows NT/2000/XP a nainstalujte
si pod Windows rovněž Apache. PHP i MySQL jsou pro Windows k dispozici
jako
binární instalační soubory; neměla by s tím být větší potíž. Až budete
ukládat skripty na disk, pamatujte na to, že při případném nahrávání na
unix-like servery záleží na velikosti písmen v názvech souborů.<br>
</p>
<p>Pod Windows existují rovněž nástroje, které instalují PHP a MySQL z
jednoho instalátoru. Přiznám se ale, že jsem je nezkoušel, takže v
tomto ohledu moc neporadím.</p>
<a name="000016"></a><h2>Závěrečné postřehy</h2>
<p>Pokud si napíšete nějaký jednoduchý PHP
skript (třeba ten z minulého dílu) a spustíte
jej, měl by Vám ho server provést. Máte-li
například server nastaven tak, že hledá php soubory z
/var/www/html a v této složce máte skript test.php,
mělo by http://localhost/test.php donutit server aby skript
zpracoval a vrátil do prohlížeče. Pokud se to
nestane, zkontrolujte konfiguraci – nejprve serveru a pak PHP.</p>
<p>Pamatujte, že pokud vyvíjíte stránky které
budou umístěny na skutečném serveru, není od
věci mít "doma" stejnou verzi PHP (a MySQL) jako bude na
serveru. Naprostá většina správců instaluje na
servery poslední stabilní verze těchto produktů, což
je většinou dobrý nápad. Verzi Vašeho PHP a
související informace o konfiguraci zjistíte
pomocí následujícího jednoduchého
skriptu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?phpinfo</font><font color="#007700">();</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Prostudujte si licenční podmínky. MySQL například
má dva různé licenční modely; licence výše
uvedeného software se při provozování pod
GNU/LINUX mohou lišit od licencí pro Windows nebo se licence
pro osobní použití mohou lišit od licencí pro
podnikovou sféru.</p>
<p>V dalším díle se podíváme na základy
syntaxe v PHP a napíšeme si několik prvních
smysluplných skriptíků.</p>

			<hr>
<a name="000017"></a><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (4) - Základy syntaxe</h2>
			<p class="perex">V minulém díle našeho seriálu jsme si PHP
nainstalovali a nastavili.
Dnes se dostaneme v našem povídání o tomto skriptovacím jazyku k
základům syntaxe. Uvidíme, jak je kód PHP členěn, jak se v něm trochu
vyznat a na co bychom při psaní PHP neměli zapomínat. 
				<br>
			</p>
			<p>Jak vůbec server
pozná, že má se souborem zacházet jako s programem v PHP? V zásadě
podle přípony souboru, který po něm požadujeme. Jestliže má soubor
příponu php, server nám jej nevrátí přímo jako by šlo o HTML, ale
nejprve jej zpracuje. Příponu php (také phtml, php3 a některé další)
pozná server jako soubor skriptu prostě proto, že to má nastaveno v
konfiguraci (viz minulý díl). My budeme používat při ukládání skriptů
příponu php, je to nejčastější. <br>
</p>
<p>Úplná
katastrofa může nastat, když souboru se skriptem php dáme omylem
příponu htm nebo html. To jej potom server pošle do prohlížeče bez
jakýchkoli úprav a uživatel může vidět zdrojový kód skriptu. To asi
není to, co chcete, zejména kdyby skript obsahoval citlivé údaje
(třeba,
jak se připojit k databázi). Takže, dávejte si na to pozor. Na druhou
stranu Vám nic nebrání nazvat si "obyčejné" html soubory tak, aby měly
příponu php. Když server zjistí, že v nich není žádný php kód, pošle je
prohlížeči tak, jak jsou. A navíc – když do nich později budete chtít
nějaký kód přidat, už je nebudete muset přejmenovávat.
</p>
<a name="000018"></a><h2>Oddělení kódu</h2>
<p>Ve skriptu samotném je kód php uzavřen dvojicí značek. Mohou to být:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
</font><font color="#007700">[</font><font color="#0000bb">PHP kód</font><font color="#007700">] </font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>To je typický případ.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?php
</font><font color="#007700">[</font><font color="#0000bb">PHP kód</font><font color="#007700">] </font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>tato sytnaxe je kompatibilní se standardem XML, takže asi
syntakticky nejčistší. Bývám ale líný to psát.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;SCRIPT
LANGUAGE="php"&gt; php </font><font color="#007700">[</font><font color="#0000bb">PHP kód</font><font color="#007700">] </font><font color="#0000bb">&lt;/SCRIPT&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>To je sice asi nejsložitější, ale mělo by to donutit editory typu
Microsoft FrontPage, aby kód mezi tagy neformátovaly podle svých
představ, takže někdy se může docela hodit to znát.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;% [PHP kód] %&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>To je syntaxe známá z jazyka asp (Active server pages) firmy
Microsoft. Používat by se to mělo jen v krajních případech, protože to
vyžaduje úpravu konfiguračních souborů a je to silně nestandardní.</p>
<p>My budeme v
příkladech používat dvojice značek &lt;? a ?&gt;. Dokumentace uvádí, že
toto chování musí být implicitně zapnuté v konfiguračním souboru, aby
to fungovalo, ale že to je zároveň výchozí nastavení. Mě to však
funguje úplně všude.</p>
<a name="000019"></a><h2>Oddělení instrukcí</h2>
<p>Jednotlivé instrukce se v PHP oddělují středníkem.
Takže, následující kód Vám nebude
fungovat:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"První
řádek"<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Druhý
řádek"<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Celé to skončí chybou "Parse Error", protože
za prvním řádkem nenásleduje středník.
S touto chybou se seznamte – pokud jste předtím
neprogamovali v nějakém jazyku, který rovněž používá
středníky, asi je budete často zapomínat (jako já).
Opravený skript je:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"První
řádek"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Druhý řádek"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a ještě poznámky: </p>
<ul>
  <li>
    <p>Před poslední instrukcí nemusí středník být. Pište ho tam ale,
protože se Vám bude stávat, že připíšete nějakou instrukci ještě níže a
kód Vám přestane fungovat.</p>
  </li>
  <li>
    <p>Na rozdíl od některých jiných jazyků jsou konce řádků pro PHP
nepodstatné. To můžete použít pro formátování kódu tak, abyste se v něm
vyznali. Nepodstatné jsou rovněž mezery a tabelátory. Následující kód
je tedy totožný s předchozím:</p>
  </li>
</ul>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
</font><font color="#007700">echo </font><font color="#dd0000">"První
řádek"</font><font color="#007700">; echo </font><font color="#dd0000">"Druhý
řádek"</font><font color="#007700">; </font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<a name="000020"></a><h2>Komentáře (ano?)</h2>
<p>Komentář je něco, co program při zpracování
ignoruje a slouží tedy pouze uživateli. Rozhodně si osvojte
zapisování komentářů hned při pasní
kódu; bude se Vám to hodit. Patřičně to zdůrazníme
v článku věnovaném <a href="#000260">psaní
rozsáhlejších
projektů</a>, ale zvykněte si na to už teď. Komentáře mohou
být v PHP jednořádkové nebo víceřádkové
a používají se na ně znaky "//" (dvě dopředná lomítka), "#" (mřížka) a
dvojice "/*" a "*/" (lomítko+hvězdička --- hvězdička+lomítko). </p>
<p>Jednořádkový kometář:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">// skript kašle na to, co tady napíšu<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>nebo </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000"># skriptu je úplně jedno, co tu bude<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Víceřádkový komentář</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">/*<br>
Nevím, jestli to, co napsáno v tomto skriptu bude fungovat.<br>
Ještě se na to budu muset podívat.<br>
*/<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Víceřádkovým komentářem můžete
zakomentovat celý blok textu velice rychle, a také
velice špatně. Pamatujte, že víceřádkové
komentáře nelze vnořovat. První sekvence '*/' totiž
celý komentář ukončí. Následující
kód tedy skončí chybou (je to vidět už z obarvení kódu):</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">/*<br>
Chci to zakomentovat.<br>
To by přece nemělo vadit.<br>
&nbsp;&nbsp;/*<br>
&nbsp;&nbsp;Ale díky "vnořenému" víceřádkovému komentáři<br>
&nbsp;&nbsp;... už to vadí<br>
&nbsp;&nbsp;*/<br>
</font><font color="#007700">*/<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V dalším díle se podíváme na některé
příkazy php, které bude lepší se naučit hned
a na formátování výsledného kódu,
který PHP vrací do prohlížeče.</p>

<a name="000021"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (5) - Příkaz Echo; formátování kódu</h2>
			<p class="perex">V PHP se dnes naučíme jeden příkaz a něco formátovacích zvyklostí
				<br>
			</p>
			<p>V předchozím díle našeho PHP seriálu jsme si
ukázali, jak se PHP kód
oděluje od HTML kódu, jak se instrukce v PHP oddělují jedna od druhé a
jak se píší v kódu komentáře. Dnes se podíváme na jeden příkaz a jeden
operátor PHP; ty se raději naučíme rovnou, protože je budeme často
používat. Ukážeme si také na formátování výsledného kódu, který se
posílá do prohlížeče.
</p>
<a name="000022"></a><h2>Příkaz ECHO</h2>
<p>Příkaz echo vytiskne jeden nebo více řetězců.
Příklady:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Dnes
je hezky"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Dnes
je hezky "</font><font color="#007700">, </font><font color="#dd0000">"Zítra
bude ošklivo..."</font><font color="#007700">, </font><font color="#dd0000">"pozítří bude taky ošklivo..."</font><font color="#007700">, </font><font color="#dd0000">" jak bude v pondělí
mě nezajímá..."</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Budete-li chtít vytisknout víceřádkový
řetězec, můžete provést něco jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
</font><font color="#007700">echo </font><font color="#dd0000">"Tohle
bude první řádek<br>
Tohle bude druhý řádek<br>
Tohle dáme nakonec"</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>To BUDE fungovat, stejně jako následující
syntaxe, která místo fyzického konce řádku
vkládá do textu speciální sekvenci znaků
\n.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
</font><font color="#007700">echo </font><font color="#dd0000">"Tohle
bude první řádek\nTohle bude druhý řádek\nTohle dáme nakonec"</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>\n je jednou z tzv. escape sekvencí. Těch sekvencí je více –
viz tabulka</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; font-weight: bold;">Sekvence<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Význam<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">\n<br>
      </td>
      <td style="vertical-align: top;">Nový řádek<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">\"<br>
      </td>
      <td style="vertical-align: top;">Uvozovky<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">\r<br>
      </td>
      <td style="vertical-align: top;">Návrat vozíku<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">\t<br>
      </td>
      <td style="vertical-align: top;">Tabelátor<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">\\<br>
      </td>
      <td style="vertical-align: top;">Zpětné lomítko<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">\$<br>
      </td>
      <td style="vertical-align: top;">Dolar<br>
      </td>
    </tr>
  </tbody>
</table>
<p>Takže, budete-li chtít donutit příkaz echo, aby ve
výstupu zobrazil skutečnou uvozovku, můžete napsat něco
jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#dd0000">"PHP už \"skoro\"
umím"</font><font color="#007700">;</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-style: italic;">Tip: Ten trik s uvozovkami se
docela používá. Často totiž pomocí PHP potřebujeme zapsat HTML tagy
včetně parametrů a ty bývají v uvozovkách.</span><br>
</p>
<p>Pokud jste si zkoušeli uvedený příklad s řádky a máte
pocit, že tam cosi nehraje, máte pravdu. V prohlížeči
totiž budou všechny údaje na <span style="font-style: italic;">jednom </span>řádku.
Kde je
tedy problém? Problém je v tom, že nesmíme
míchat dvě věci: to jak PHP <span style="font-style: italic;">předává </span>informace
prohlížeči a to, jak prohlížeč předané
informace <span style="font-style: italic;">zobrazuje</span>. Když
pošlete prohlížeči požadavek na
skript uvedený výše a necháte si zobrazit
zdrojový kód stránky která dorazí,
zjistíte, že tam ty konce řádku opravdu jsou. HTML
ale nezalamuje řádek tehdy, když je znak konce řádku
v kódu, HTML má k tomu značku &lt;BR&gt;. Je
samozřejmě možné vložit značku HTML do řetězce v PHP,
třeba takhle:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Řádek
první...&lt;BR&gt;Řádek druhý&lt;BR&gt; a konečně řádek jánevímjaký"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>… prohlížeč pak obdrží následující
kód:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">Řádek
první...&lt;BR&gt;Řádek druhý&lt;BR&gt;a konečně řádek jánevímjaký<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>… a ten zobrazí s tím, že pochopitelně značky
&lt;BR&gt; nahradí zalomením řádku.</p>
<p>Kdybychom ale chtěli být maličko preciznější,
můžeme napsat kód i takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Řádek
první...&lt;BR&gt;\nŘádekdruhý&lt;BR&gt;\na konečně řádek jánevímjaký"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>… prohlížeč pak obdrží následující
kód:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">Řádek první...&lt;BR&gt;<br>
Řádek druhý&lt;BR&gt;<br>
a konečně řádek jánevímjaký<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>… a ten nám zobrazí. Rozdíl pro uživatele
není žádný. Rozdíl pro prohlížeč
je jen ten, že musí načíst více dat a přísně
řečeno ten druhý způsob bude více zatěžovat linku
do internetu, protože i ty znaky konce řádku se musejí
ze serveru přenést – ale pokud budeme chtít
rozpitvat to, co dorazilo do prohlížeče, je ten druhý
způsob daleko přehlednější.</p>
<p><a href="http://cz.php.net/manual/cs/function.echo.php">Příkaz echo</a>
je jasně nejčastějším příkazem
PHP. Naučme se dnes ještě jeden operátor – a to operátor
pro spojování řetězců.</p>
<a name="000023"></a><h2>Spojování řetězců</h2>
<p>Spojování retězců se prování pomocí
operátoru . (tečka). Takže příklad:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#dd0000">"Klidně si spojím
úvod "</font><font color="#007700">.</font><font color="#dd0000">"se
závěrem"</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Tečka zde vedla ke spojení, zřetězení řetězců.
Je rovněž možné spojit více než dva řetězce. Pokud byste podlehli
pokušení řetězce spojit pomocí
plusítka (+), bude výsledek následujícího skriptu</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#dd0000">"Klidně si spojím
úvod "</font><font color="#007700">+</font><font color="#dd0000">"se
závěrem"</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>překvapivě 0. Proč to tak je si rozebereme podrobněji v díle seriálu
o <a href="http://www.linuxsoft.cz/article.php?id_article=181">přetypování
proměnných</a>.
<br>
</p>
<p><span style="font-style: italic;">Pozn.: Telegraficky - je to proto,
že PHP narazí na znak plus, ten vyžaduje čísla, a PHP se tedy pokusí
považovat oba řetězce za čísla. Má na to pravidlo, podle něhož řetězec
nezačínající číslicí, desetinným oddělovačem nebo znaky "+" či "-" je
povážován při převodu za nulu. A 0+0=0!</span></p>
<p>Upozorňuji na to především programátory přecházející na PHP z ASP,
kde se skutečně řetězce spojovaly pomocí plusítka. Příštích několik
dílů se budeme věnovat
proměnným.</p>

<a name="000024"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (6) - Typy proměnných</h2>
			<p class="perex">V tomto díle seriálu o jazyce PHP se podíváme na
zoubek proměnným.
				<br>
			</p>
<a name="000025"></a><h2>Proměnné v PHP</h2>
<p>Každý programovací jazyk pracuje s nějakými hodnotami. To, do čeho
se
tyto hodnoty ukládají, se nazývá proměnné. Každá proměnná má název
(někdy se mu říká identifikátor) a hodnotu (někdy se označuje termínem
literál). V každém okamžiku je hodnota proměnné v programu jednoznačně
daná, během programu se však může měnit. Proměnné se podle toho, co v
nich chceme uchovávat za hodnoty, dělí na několik typů:<br>
</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Typ</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Název
v PHP</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Popis</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Logický typ<br>
      </td>
      <td style="vertical-align: top;">Boolean<br>
      </td>
      <td style="vertical-align: top;">uchovává hodnotu "pravda" nebo
"nepravda". Zapisuje se jako TRUE a
FALSE (na velikosti nezáleží, můžete třeba i jako tRUE a fALSE</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Celočíselný typ<br>
      </td>
      <td style="vertical-align: top;">Integer<br>
      </td>
      <td style="vertical-align: top;">uchovává celá kladná i záporná
čísla (a nulu) od nějakých -2 biliónů po
+ 2 bilióny.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Desetinné číslo<br>
      </td>
      <td style="vertical-align: top;">Float nebo Real<br>
      </td>
      <td style="vertical-align: top;">uchovává desetinná čísla. S
přesností obyčejně na 14 desetinných míst
a rozsahem, z něhož by se nám asi zamotala hlava - číslo, které začíná
jedničkou a může mít 308 nul.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Řetězec<br>
      </td>
      <td style="vertical-align: top;">String<br>
      </td>
      <td style="vertical-align: top;">uchovává
texty neboli řetězce. Řetězec je znak nebo sada znaků, v PHP prakticky
neomezené délky.</td>
    </tr>
  </tbody>
</table>
<p><br>
Typ proměnné v PHP se určuje v okamžiku přiřazení hodnoty do proměnné.
To bývá ve většině případů přesně to, co chceme, někdy to ale může mást
programátory zvyklé na deklarování proměnných před jejich použitím z
jiných programovacích
jazyků (některé jazyky totiž umožňují, nebo dokonce vyžadují deklarovat
typ proměnné předem). Během programu může proměnná svůj typ změnit, ať
už díky
instrukci v kódu nebo v důsledku nějakého výpočtu. To se nazývá
přetypování a bude o tom ještě <a href="#000039">řeč</a>.<br>
</p>
<p>Každá proměnná musí mít jednoznačný název. Ten v PHP začíná znakem
dolaru($) a následuje (bez mezery) nějakým pojmenováním. První znak
toho pojmenování musí být buď písmeno a-z nebo podtržítko. Nesmí to být
číslo ani nic jiného. Názvy proměnných v PHP rozlišují mezi malými a
velkými písmeny, takže pozor na to. Praxe bývá většinou taková, že se
proměnné píší malými písmeny. V názvech proměnných můžete používat
české znaky včetně diakritiky; běžně se to ale moc nedělá. Desetinná
čísla se zadávají s tečkou, ne s čárkou. Řetězce se uzavírají do
uvozovek nebo do apostrofů.<br>
</p>
<p>Proměnné přiřadíte nějakou hodnotu pomocí znaku = ("rovná se"). Níže
uvedeme skript, který bude všechy ty zásady ilustrovat.<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">//logický typ<br>
</font><font color="#0000bb">$mam_malo_penez </font><font color="#007700">= </font><font color="#0000bb">TRUE</font><font color="#007700">;<br>
</font><font color="#ff8000">//celočíselný typ<br>
</font><font color="#0000bb">$plat </font><font color="#007700">= </font><font color="#0000bb">10000</font><font color="#007700">;<br>
</font><font color="#ff8000">//desetinné číslo<br>
</font><font color="#0000bb">$disketa </font><font color="#007700">= </font><font color="#0000bb">3.5</font><font color="#007700">;<br>
</font><font color="#ff8000">//řetězec<br>
</font><font color="#0000bb">$prohlaseni </font><font color="#007700">=
</font><font color="#dd0000">"Právě se vracím z pražského hradu! ..."</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$mam_malo_penez</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;"</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$plat</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;"</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$disketa</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;"</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$prohlaseni</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jak můžete vidět z výsledku, nejprve jsem proměnným přiřadil nějakou
hodnotu a pak jsem ji vypsal. Následující skript obsahuje běžné chyby,
kterých se můžete při pojmenování nebo přiřazování proměnných dopustit:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">// tohle bude špatně. proměnná nesmí
začínat číslem:<br>
</font><font color="#007700">$</font><font color="#0000bb">3sestry </font><font color="#007700">= </font><font color="#dd0000">"tři sestry"</font><font color="#007700">;<br>
</font><font color="#ff8000">// tohle sice projde, ale nic to nevypíše
(velikost písmen v názvu)<br>
</font><font color="#0000bb">$rok </font><font color="#007700">= </font><font color="#0000bb">2004</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$Rok</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V typům proměnných ještě jedna malá přátelská rada. Pokud nemusíte,
nepoužívejte typ double (float), nebo si alespoň buďte při jeho použití
vědomi
toho, že se jedná o nepřesná čísla. Jakákoli operace přiřazení nebo
porovnání takových
čísel může dávat neočekávané výsledky. Tak třeba následující skript<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$a</font><font color="#007700">=</font><font color="#0000bb">0.1</font><font color="#007700">; </font><font color="#0000bb">$b</font><font color="#007700">=</font><font color="#0000bb">0.7</font><font color="#007700">;<br>
echo </font><font color="#0000bb">0.8</font><font color="#007700">-</font><font color="#0000bb">$a</font><font color="#007700">-</font><font color="#0000bb">$b</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>nevrátí nulu, jak byste asi čekali, ale nějaké sice hodně malé, ale
přesto nenulové číslo. Kdybyste se spoléhali na to, že skript vrátí
nulu, dostanete se do potíží.
Takové chyby se navíc velmi špatně odhalují. A když se ještě k tomu
nepřesná čísla uloží do databáze, mohou se chyby kumulovat.<br>
</p>
<a name="000026"></a><h2>Operátory</h2>
<p>S proměnnými se dají, jak to ostatně vyplývá s příkladu uvedeného
výše provádět matematické operace. Více si o tom řekneme v díle o
výrazech. Už teď Vám ale mohu prozradit, že základní operace, které
znáte z matematiky (+-*/) s čísly v PHP provádět samozřejmě můžete;
řetězce se dají slučovat pomocí operátoru tečky a celou řadu dalších
možností si probereme v díle o výrazech.<br>
</p>
<a name="000027"></a><h2>Názvy proměnných</h2>
<p>Protože můžete použít malá nebo velká písmena a českou abecedu v
názvech proměnných, a protože proměnných můžete mít časem i v jednom
skriptu poměrně dost, vyplatí se už od začátku se trochu cepovat a
udělat si v jejich pojmenování nějaký systém. Těžko radit, ale
následující postřehy Vám možná přijdou vhod:<br>
</p>
<ul>
  <li>jednopísmenné názvy nebývají to nejlepší. Jak budete časem vědět,
k čemu slouží proměnná $d a $g ???<br>
  </li>
  <li>příliš dlouhé názvy taky nejsou to pravé ořechové. Když máte
napsat
$jednaodvesnatrojuhelniku + $druhaodvesnatrojuhelniku, půjde to pomalu
a můžete snadněji udělat překlep.</li>
  <li>když používáte sebepopisující názvy proměnných, bývá dobré se
rozhodnout pro češtinu nebo jiný jazyk, ale nemíchat to. Například
$tata+$mama=$dite ale ne $tata+$mama=$child. My budeme používat v tomto
seriálu převážně české názvy bez hacku a carek.</li>
  <li>Když už musí být název proměnné dlouhý, udělá občas nějaké to
velké
písmeno situaci snesitelnější. $smazsouborzdisku není tak čtivé jako
$SmazSouborZDisku. Někteří tomu říkají velbloudí notace.<br>
  </li>
  <li>Někdo si proměnné označuje prefixem podle typu. Celočíselné třeba
$intPocet, řetězce $strNazev a podobně. Nevím zda je to až tak velká
výhoda,
nedělám to.</li>
</ul>
<p>V příštím díle se podíváme na typ proměnné, který jsme zatím
vynechali. A to na pole.</p>

<a name="000028"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (7) - Pole</h2>
			<p class="perex">PHP používá samozřejmě i proměnné typu pole. Dnes si
ukážeme jak.
				<br>
			</p>
			<p>V PHP je kromě základních datových typů (celá čísla, desetinná
čísla, logické
hodnoty a řetězce) k dispozici i datový typ pole. To je speciální
struktura, která může v jedné proměnné obsahovat sadu hodnot. Hovoříme
o tom, že pole má <span style="font-weight: bold;">prvky</span>; každý
prvek má <span style="font-weight: bold;">index </span>nebo <span style="font-weight: bold;">klíč </span>a <span style="font-weight: bold;">hodnotu</span>. Proměnné typu pole patří k
těm věcem v PHP, které jsou v jazyce zpracovány opravdu dobře a znalost
polí Vám
pravděpodobně umožní napsat kód, který by bez nich byl delší, nebo
pomalejší, nebo méně přehledný.<br>
</p>
<p>Představte si, že máte dejme tomu pět lidí stojících ve frontě. Z
těchto lidí můžete udělat v PHP pole například tak, že jako index bude
sloužit jejich "frontové pořadí". Můžete tedy napsat:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$fronta</font><font color="#007700">[</font><font color="#0000bb">1</font><font color="#007700">]=</font><font color="#dd0000">"Petr"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[</font><font color="#0000bb">2</font><font color="#007700">]=</font><font color="#dd0000">"Pavel"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[</font><font color="#0000bb">3</font><font color="#007700">]=</font><font color="#dd0000">"Maruška"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[</font><font color="#0000bb">4</font><font color="#007700">]=</font><font color="#dd0000">"Eva"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[</font><font color="#0000bb">5</font><font color="#007700">]=</font><font color="#dd0000">"LinuxSoft tým"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Vznikla nám proměnná $fronta (pole), která obsahuje pět <span style="font-weight: bold;">prvků</span>, z nichž každý má svůj <span style="font-weight: bold;">index </span>(například trojku) a <span style="font-weight: bold;">hodnotu </span>(takže Maruška). Z toho
vidíme, že pole se v PHP zapisují jako každá jiná proměnná, pouze za
názvem mají v hranatých závorkách index. <br>
</p>
<a name="000029"></a><h2>Indexovaná a asociativní</h2>
<p>Pole uvedené výše bylo indexované, protože jeho prvky jsou určeny
indexem. Někdy může ale být šikovnější rozlišit od sebe prvky pole
řetězcem, čímž vznikne tzv. asociativní pole.<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$obyvatel</font><font color="#007700">[</font><font color="#dd0000">"Praha"</font><font color="#007700">]=</font><font color="#0000bb">1000000</font><font color="#007700">;<br>
</font><font color="#0000bb">$obyvatel</font><font color="#007700">[</font><font color="#dd0000">"Ústí nad Labem"</font><font color="#007700">]=</font><font color="#0000bb">100000</font><font color="#007700">;<br>
</font><font color="#0000bb">$obyvatel</font><font color="#007700">[</font><font color="#dd0000">"Horní Lhota"</font><font color="#007700">] = </font><font color="#0000bb">350</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Obecně může být asociativní pole užitečné v případě, kdy budete
chtít rozlišovat prvky podle něčeho jiného než podle čísel. Například
existují projekty, kde se asociativní pole používají k ukládání
konfiguračních hodnot programu. Proměnná $config["max_users"] je daleko
popisnější než $config[5].<br>
</p>
<a name="000030"></a><h2>Vícerozměrná pole</h2>
<p>Aby to nebylo tak úplně jednoduché, pole nemusí mít jen jeden index.
Představte si například, že byste v PHP chtěli pomocí pole popsat
postavení figurek na šachovnici před zahájením šachové partie. Protože
figurky
nestojí v jedné frontě jako lidé v našem prvním příkladu, ale jsou
naopak uspořádány na hrací ploše rozdělené do řad a sloupců, můžete
udělat něco jako:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">//[řádek] [sloupec] (zleva odspodu)<br>
</font><font color="#0000bb">$figura</font><font color="#007700">[</font><font color="#0000bb">1</font><font color="#007700">][</font><font color="#0000bb">1</font><font color="#007700">]=</font><font color="#dd0000">"bílá věž"</font><font color="#007700">;<br>
</font><font color="#0000bb">$figura</font><font color="#007700">[</font><font color="#0000bb">1</font><font color="#007700">][</font><font color="#0000bb">2</font><font color="#007700">]=</font><font color="#dd0000">"bílý jezdec"</font><font color="#007700">;<br>
</font><font color="#ff8000">//...atd...<br>
</font><font color="#0000bb">$figura</font><font color="#007700">[</font><font color="#0000bb">2</font><font color="#007700">][</font><font color="#0000bb">8</font><font color="#007700">]=</font><font color="#dd0000">"bílý pěšec"</font><font color="#007700">;<br>
</font><font color="#ff8000">//...atd...<br>
</font><font color="#0000bb">$figura</font><font color="#007700">[</font><font color="#0000bb">8</font><font color="#007700">][</font><font color="#0000bb">7</font><font color="#007700">]=</font><font color="#dd0000">"černý jezdec"</font><font color="#007700">;<br>
</font><font color="#0000bb">$figura</font><font color="#007700">[</font><font color="#0000bb">8</font><font color="#007700">][</font><font color="#0000bb">8</font><font color="#007700">]=</font><font color="#dd0000">"černá věž"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>za což mě pochopitelně žádný šachista nemůže mít rád, protože v
šachové notaci se uvádí nejprve sloupec a pak řádek a navíc sloupce se
nečíslují, ale označují se písmeny. Abychom demonstrovali pružnost PHP
při práci s poli a umlčeli nespokojené šachisty, přepíšeme to do
následující podoby:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$figura</font><font color="#007700">[</font><font color="#dd0000">"a"</font><font color="#007700">][</font><font color="#0000bb">1</font><font color="#007700">]=</font><font color="#dd0000">"bílá věž"</font><font color="#007700">;<br>
</font><font color="#0000bb">$figura</font><font color="#007700">[</font><font color="#dd0000">"b"</font><font color="#007700">][</font><font color="#0000bb">1</font><font color="#007700">]=</font><font color="#dd0000">"bílý jezdec"</font><font color="#007700">;<br>
</font><font color="#ff8000">//...atd...<br>
</font><font color="#0000bb">$figura</font><font color="#007700">[</font><font color="#dd0000">"h"</font><font color="#007700">][</font><font color="#0000bb">2</font><font color="#007700">]=</font><font color="#dd0000">"bílý pěšec"</font><font color="#007700">;<br>
</font><font color="#ff8000">//...atd...<br>
</font><font color="#0000bb">$figura</font><font color="#007700">[</font><font color="#dd0000">"g"</font><font color="#007700">][</font><font color="#0000bb">8</font><font color="#007700">]=</font><font color="#dd0000">"černý jezdec"</font><font color="#007700">;<br>
</font><font color="#0000bb">$figura</font><font color="#007700">[</font><font color="#dd0000">"h"</font><font color="#007700">][</font><font color="#0000bb">8</font><font color="#007700">]=</font><font color="#dd0000">"černá věž"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Na poli b1 je při zahájení šachové
partie "</font><font color="#007700">.</font><font color="#0000bb">$figura</font><font color="#007700">[</font><font color="#dd0000">"b"</font><font color="#007700">][</font><font color="#0000bb">1</font><font color="#007700">];<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<a name="000031"></a><h2>Inicializace pole</h2>
<p>Pole v programu samozřejmě nevznikne samo od sebe. Můžeme jej
nastavit tak, že jeho prvkům přiřadíme postupně hodnoty.
To bylo patrné ze
všech předchozích ukázek. Jde to ovšem ještě jednodušeji - index pole
můžeme vynechat a PHP jej dosadí za nás. Další možnost je použít PHP
funkci <a href="http://cz.php.net/manual/cs/function.array.php">array</a>,
která provede totéž, ale je to mnohem kratší. Úvodní příkaz z
frontou bychom tedy mohli přepsat následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$fronta</font><font color="#007700">[]=</font><font color="#dd0000">"Petr"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[]=</font><font color="#dd0000">"Pavel"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[]=</font><font color="#dd0000">"Maruška"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[]=</font><font color="#dd0000">"Eva"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[]=</font><font color="#dd0000">"LinuxSoft tým"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>nebo pomocí funkce array, což je ještě kratší:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?$fronta</font><font color="#007700">=Array(</font><font color="#dd0000">"Petr"</font><font color="#007700">, </font><font color="#dd0000">"Pavel"</font><font color="#007700">, </font><font color="#dd0000">"Maruška"</font><font color="#007700">, </font><font color="#dd0000">"Eva"</font><font color="#007700">, </font><font color="#dd0000">"LinuxSoft tým"</font><font color="#007700">);</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Je tu nicméně jeden problém. PHP standardně čísluje pole od nuly, ne
od jedničky. Takže, v našem příkladu by $fronta[1] vrátilo "Pavel", ne
"Petr". Aby
příklad skutečně fungoval jako ten úvodní, musíme PHP s inicializací
pole trochu pomoci - prozradíme, že nechceme číslovat od nuly, ale od
jedničky.<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">// buď tedy<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[</font><font color="#0000bb">1</font><font color="#007700">]=</font><font color="#dd0000">"Petr"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[]=</font><font color="#dd0000">"Pavel"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[]=</font><font color="#dd0000">"Maruška"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[]=</font><font color="#dd0000">"Eva"</font><font color="#007700">;<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">[]=</font><font color="#dd0000">"LinuxSoft tým"</font><font color="#007700">;<br>
<br>
</font><font color="#ff8000">//nebo<br>
</font><font color="#0000bb">$fronta</font><font color="#007700">=Array(</font><font color="#0000bb">1</font><font color="#007700">=&gt;</font><font color="#dd0000">"Petr"</font><font color="#007700">, </font><font color="#dd0000">"Pavel"</font><font color="#007700">, </font><font color="#dd0000">"Maruška"</font><font color="#007700">, </font><font color="#dd0000">"Eva"</font><font color="#007700">, </font><font color="#dd0000">"LinuxSoft tým"</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Pro vypsání obsahu pole se Vám může, zejména při ladění kódu hodit
šikovná funkce <a href="http://cz.php.net/manual/cs/function.print-r.php">print_r</a>.
Ta prostě vypíše obsah pole do
prohlížeče. Funguje i s vícerozměrnými poli.<br>
</p>
<p><span style="font-style: italic;">Pozn: Ona vlastně funguje i s
čísly a řetězci. Ale používá se převážně pro pole.</span><br>
</p>
<p></p>
<a name="000032"></a><h2>K čemu se pole používají<br>
</h2>
<p>Protože se pole v PHP dají využít na všechno možné, dovolím si
krátký přehled toho, k čemu by se Vám mohla hodit. Třeba budete řešit
situaci, kdy použití polí může být to "pravé ořechové". Pole mohou:<br>
</p>
<ul>
  <li>sloužit jako seznamy</li>
  <li>simulovat slovníky</li>
  <li>fungovat jako kolekce prvků</li>
  <li>pracovat jako zásobníky nebo fronty</li>
  <li>představovat stromové struktury (prvkem pole totiž může být pole)</li>
  <li>být vracena z funkcí PHP (například se to týká databází, jak
uvidíme)<br>
  </li>
</ul>
<a name="000033"></a><h2>Postřehy k polím</h2>
<p>To, že jsou pole v PHP užitečná ještě neznamená, že by se měla
používat vždy a všude. Tady jsou postřehy, které možná oceníte:<br>
</p>
<ul>
  <li>Rozsáhlá pole mohou zabírat extrémně mnoho systémových zdrojů,
zejména operační paměti. Pamatujte na to. O vícerozměrných polích to
platí dvojnásob. <br>
  </li>
  <li>Ujasněte si, jak budete organizovat indexy nebo klíče. U indexů
se ujistěte, že začínají od správného čísla (většinou od nuly nebo od
jedničky)</li>
  <li>Všechny prvky pole nemusí být stejného typu! V jednom poli můžete
mít například čísla i řetězce.</li>
  <li>Většinou se v praxi používají jedno nebo dvojrozměrná pole. <br>
  </li>
  <li>Pokud Vaše PHP aplikace pracuje s mnoha poli, možná se budete
chtít zabývat myšlenkou na zavedení databáze.</li>
</ul>
<p>S poli se dá dělat mnoho věcí. PHP ale obsahuje hodně důležitých
rysů, na které bychom se měli podívat ještě předtím, než budeme zkoušet
pracovat s poli. V dalším díle seriálu se proto podíváme na výrazy,
operace a přetypování proměnných. </p>
<a name="000034"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (8) - Výrazy, konstanty, inkrementace</h2>
			<p class="perex">Jazyk PHP je orientován na výrazy. Dnes si v našem
seriálu ukážeme co výrazy jsou a jak nám při programování budou pomocí. Zmíníme se rovněž o konstantách a inkrementaci.
				<br>
			</p>
			<p>Výrazem je v PHP zhruba řečeno "všechno, co má nějakou hodnotu". Tak
například v díle o proměnných jsme uvedli, že proměnná má hodnotu; je
to tedy výraz. Způsobu, jak zajistit že proměnná bude mít svou hodnotu
říkáme <span style="font-style: italic;">přiřazení</span>. Pro
osvěžení uveďme několik přiřazení:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$jazyk</font><font color="#007700">=</font><font color="#dd0000">"PHP"</font><font color="#007700">;<br>
</font><font color="#0000bb">$verze</font><font color="#007700">=</font><font color="#0000bb">4</font><font color="#007700">;<br>
</font><font color="#0000bb">$verzejazyka</font><font color="#007700">=</font><font color="#0000bb">$verze</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$verzejazyka</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p> Zajímavý je třetí řádek - vidíme, že do proměnné můžeme přiřadit
hodnotu jiné proměnné a celé to bude fungovat. Proměnné však nejsou
jedinými kandidáty na výrazy v PHP. <br>
</p>
<a name="000035"></a><h2>Konstanty</h2>
<p>Konstanta je v PHP něco jako proměnná, ale během programu svou
hodnotu
nemění. Je zvyk psát jejich názvy velkými písmeny. Konstanty se
definují pomocí funkce define. Dělá se to typicky na začátku skriptu.
Viz příklad níže.<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
define </font><font color="#007700">(</font><font color="#dd0000">"BROWSER"</font><font color="#007700">, </font><font color="#dd0000">"Firefox 1.0"</font><font color="#007700">);<br>
</font><font color="#0000bb">define </font><font color="#007700">(</font><font color="#dd0000">"OS"</font><font color="#007700">, </font><font color="#dd0000">"GNU/Linux"</font><font color="#007700">);<br>
echo </font><font color="#dd0000">"Váš browser je "</font><font color="#007700">.</font><font color="#0000bb">BROWSER</font><font color="#007700">.</font><font color="#dd0000">" a Váš systém je "</font><font color="#007700">.</font><font color="#0000bb">OS</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>(kéžby...) Konstanty se v PHP používají často; třeba na konfigurační
části
programu a podobně. Před názvem konstanty v PHP není znak dolaru ($).
Konstanta je výraz.<br>
</p>
<a name="000036"></a><h2>Další výrazy</h2>
<p>Výraz nemusí být jen řetězec. Prostě výraz je cokoli, co má hodnotu.
Celé pole může být například také chápáno jako výraz.
O funkcích jsme v našem seriálu sice ještě nehovořili, ale v díle
druhém jsme si již ukázali funkci Date. Funkce JE výraz, protože vrací
hodnotu. Následující kód obsahuje praktický příklad:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$dnesnidatum </font><font color="#007700">= </font><font color="#0000bb">Date</font><font color="#007700">(</font><font color="#dd0000">"r"</font><font color="#007700">);<br>
echo </font><font color="#0000bb">$dnesnidatum</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V tétu ukázce jsme udělali vlastně dvě věci: Za prvé - zavolali jsme
funkci Date, která je výrazem. A za druhé, tento výraz jsme přiřadili
výrazu $dnesnidatum a ten jsme vytiskli. Celé by to šlo zkrátit na</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">Date</font><font color="#007700">(</font><font color="#dd0000">"r"</font><font color="#007700">);</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>ale to bychom přišli o proměnnou $dnesnidatum. Vůbec nevadí, že
Date() se každou chvíli mění; pro nás je to výraz, protože "to" vrací
hodnotu.<br>
</p>
<p><span style="font-style: italic;">Pozn: Funkcím, které vracejí
pokaždé jinou hodnotu (například v závislosti na čase) se říká
nedeterministické. Funkcím, které pokaždé vrátí totéž, se naopak říká
deterministické. Oba typy jsou výrazy.</span><br>
</p>
<p></p>
<a name="000037"></a><h2>Přiřazení je výraz</h2>
<p>Samo přiřazení hodnoty proměnné je chápáno jako výraz a je
vyhodnoceno jako přiřazovaná hodnota. Takže, následující tři zápisy
jsou rovnocenné.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">// mohu přiřadit postupně<br>
</font><font color="#0000bb">$kapsa1</font><font color="#007700">=</font><font color="#dd0000">"prázdná"</font><font color="#007700">; </font><font color="#0000bb">$kapsa2</font><font color="#007700">=</font><font color="#dd0000">"prázdná"</font><font color="#007700">;<br>
</font><font color="#ff8000">// nebo $kapsa1 a hned taky $kapsa2<br>
</font><font color="#0000bb">$kapsa2</font><font color="#007700">=(</font><font color="#0000bb">$kapsa1</font><font color="#007700">=</font><font color="#dd0000">"prázdná"</font><font color="#007700">);<br>
</font><font color="#ff8000">// závorky ale můžu vynechat<br>
</font><font color="#0000bb">$kapsa2</font><font color="#007700">=</font><font color="#0000bb">$kapsa1</font><font color="#007700">=</font><font color="#dd0000">"prázdná"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Jedna kapsa "</font><font color="#007700">.</font><font color="#0000bb">$kapsa1</font><font color="#007700">.</font><font color="#dd0000">" a druhá kapsa taky "</font><font color="#007700">.</font><font color="#0000bb">$kapsa2</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Vůbec nic nám nebrání měnit hodnotu výrazu pomocí jeho samotného,
takže následující zápisy jsou platné:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$bajtu </font><font color="#007700">= </font><font color="#0000bb">0</font><font color="#007700">;<br>
</font><font color="#0000bb">$bajtu </font><font color="#007700">= </font><font color="#0000bb">$bajtu </font><font color="#007700">+ </font><font color="#0000bb">100</font><font color="#007700">;<br>
</font><font color="#0000bb">$bajtu </font><font color="#007700">= </font><font color="#0000bb">$bajtu </font><font color="#007700">* </font><font color="#0000bb">2</font><font color="#007700">;<br>
</font><font color="#0000bb">$bajtu </font><font color="#007700">= </font><font color="#0000bb">$bajtu </font><font color="#007700">/ </font><font color="#0000bb">4</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$bajtu</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Nebylo by to však PHP, kdyby nám nenabízelo jednodušší cestu, jak
něco takového napsat.<br>
</p>
<a name="000038"></a><h2>Preinkrementace a postinkrementace</h2>
<p>Za těmito strašnými slovy se skrývá mechanismus, který mění hodnotu
výrazu pomocí něj samotného. Kdybychom napříkad chtěli zvednout počet
pokojů v našem bytě pomocí PHP, můžeme napsat:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$pokoju</font><font color="#007700">=</font><font color="#0000bb">2</font><font color="#007700">;<br>
</font><font color="#0000bb">$pokoju</font><font color="#007700">++;<br>
echo </font><font color="#0000bb">$pokoju</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>nebo</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$pokoju</font><font color="#007700">=</font><font color="#0000bb">2</font><font color="#007700">;<br>
++</font><font color="#0000bb">$pokoju</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$pokoju</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Mezi těmito zápisy ve skutečnosti JE rozdíl, i když oba udělají z
našeho dvoupokojového bytu 3+1. Vysvětleme to tak, že hodnotu
inkrementovaného výrazu přiřadíme do další proměnné. Následující kód</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$pokoju</font><font color="#007700">=</font><font color="#0000bb">2</font><font color="#007700">;<br>
</font><font color="#0000bb">$pokoju_po_zmene</font><font color="#007700">=</font><font color="#0000bb">$pokoju</font><font color="#007700">++;<br>
echo </font><font color="#0000bb">$pokoju_po_zmene</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>vrátí dvojku, protože proměnná $pokoju se změnila až <span style="font-weight: bold;">poté</span>, co jsme
ji přiřadili proměnné $pokoju_po_zmene. Jedná se o <span style="font-weight: bold;">postinkrementaci</span>.
Ovšem kód</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$pokoju</font><font color="#007700">=</font><font color="#0000bb">2</font><font color="#007700">;<br>
</font><font color="#0000bb">$pokoju_po_zmene</font><font color="#007700">=++</font><font color="#0000bb">$pokoju</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$pokoju_po_zmene</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>skončí trojkou, protože proměnnou $pokoju jsme měnili ještě <span style="font-weight: bold;">předtím</span>, než jsme ji přiřadili do
proměnné $pokoju_po_zmene. Jedná se tedy o <span style="font-weight: bold;">preinkrementaci</span>.<br>
</p>
<p>Časem Vám ovšem přestane i třípokojový byt stačit a tak se nabízí
otázka, zda pre(post)inkrementace umí měnit výraz o jinou hodnotu než
jen o jedničku. Ano, umí, takže náš příklad s bajty bychom mohli
přepsat jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$bajtu </font><font color="#007700">= </font><font color="#0000bb">0</font><font color="#007700">;<br>
</font><font color="#0000bb">$bajtu </font><font color="#007700">+= </font><font color="#0000bb">100</font><font color="#007700">;<br>
</font><font color="#0000bb">$bajtu </font><font color="#007700">*= </font><font color="#0000bb">2</font><font color="#007700">;<br>
</font><font color="#0000bb">$bajtu </font><font color="#007700">/= </font><font color="#0000bb">4</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$bajtu</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Funguje to i s řetězci, což se v praxi hojně používá. Když se má
například sestavit retězec, který se pošle jako příkaz do databáze,
většinou z toho vyleze něco dlouhého. Proto, a taky kvůli přehlednosti
bývá zvykem používat místo zápisu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$sql</font><font color="#007700">=</font><font color="#dd0000">"select
id, nazev, prijmeni, jmeno, ulice, psc, mesto from zakaznik inner join
objednavka on zakaznik.id = objednavka.zakaznik where zakaznik.id =
7200"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>použít něco ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$sql</font><font color="#007700">=</font><font color="#dd0000">"select
id, nazev, prijmeni, jmeno, ulice, psc, mesto "</font><font color="#007700">;<br>
</font><font color="#0000bb">$sql</font><font color="#007700">.=</font><font color="#dd0000">"from zakaznik inner join objednavka on zakaznik.id =
objednavka.zakaznik "</font><font color="#007700">;<br>
</font><font color="#0000bb">$sql</font><font color="#007700">.=</font><font color="#dd0000">"where zakaznik.id = 7200"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>přičemž oba znamenají ve své podstatě totéž. Preinkrementaci a
postinkrementaci byste <span style="font-style: italic;">měli</span>
používat, kdykoli je k tomu příležitost. Je totiž optimalizována na
rychlost. Na druhou stranu uznávám, že pokud přecházíte na PHP z
jazyků, které tuto konstrukci neměly (třeba asp), může Vám to zpočátku
dělat problém.<br>
</p>
<p>Různé kejkle s výrazy nás přivádějí k zajímavé otázce - a tou je
změna
<span style="font-style: italic;">typu </span>proměnné. Jak to
například dopadne, když budeme proměnnou dělit?
Bude výsledkem typ celočíselný, desetinný nebo pokaždé jiný? Těmito
otázkami se budeme zabývat v dalším díle seriálu, věnovaném přetypování
proměnných.</p>
<a name="000039"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (9) - Přetypování proměnných</h2>
			<p class="perex">Přetypování proměnných v PHP - požehnání nebo prokletí?
				<br>
			</p>
			<p>V našem seriálu jsme již uvedli, že PHP nevyžaduje definici proměnné
před jejím použitím. Typ proměnné je v zásadě určen tím, co do ní
vložíme. Co když ale výsledkem výrazu bude v PHP něco, co má jiný
datový typ? Například, co se stane, když budeme dělit dvě celá čísla?
Odpověď je - PHP se pokusí provést tzv. přetypování. Přetypování je
změna typu proměnné během provádění programu. Připomeňme ještě na úvod,
že proměnné v PHP mohou být čtyř základních typů: Integer, Float,
Boolean a String.</p>
<p>S přetypováním může být legrace. Především - přetypovat proměnnou
můžeme sami. Slouží k tomu příkaz <a href="http://cz.php.net/manual/en/function.settype.php">settype</a>,
který nenávratně změní typ
proměnné na jiný. Další důležitá informace je ta, že můžeme kdykoli
zjistit typ proměnné pomocí funkce <a href="http://cz.php.net/manual/en/function.gettype.php">gettype</a>.
Tyto věci ilustrujme na
příkladu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$muj_string</font><font color="#007700">=</font><font color="#dd0000">"Pepa"</font><font color="#007700">;<br>
</font><font color="#0000bb">$muj_integer</font><font color="#007700">=</font><font color="#0000bb">2</font><font color="#007700">;<br>
</font><font color="#0000bb">$muj_float</font><font color="#007700">=</font><font color="#0000bb">3.5</font><font color="#007700">;<br>
</font><font color="#0000bb">$muj_boolean</font><font color="#007700">=</font><font color="#0000bb">FALSE</font><font color="#007700">;<br>
</font><font color="#ff8000">// pokusíme se nějak přetypovat každou
proměnnou...<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Typ
proměnné muj_string byl &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$muj_string</font><font color="#007700">).</font><font color="#dd0000">"&lt;/B&gt;"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">" a hodnota byla &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$muj_string</font><font color="#007700">.</font><font color="#dd0000">"&lt;/B&gt;. "</font><font color="#007700">;<br>
</font><font color="#0000bb">settype</font><font color="#007700">(</font><font color="#0000bb">$muj_string</font><font color="#007700">, </font><font color="#dd0000">"boolean"</font><font color="#007700">);<br>
echo </font><font color="#dd0000">"Po změně na &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$muj_string</font><font color="#007700">).</font><font color="#dd0000">"&lt;/B&gt; je hodnota
&lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$muj_string</font><font color="#007700">.</font><font color="#dd0000">"&lt;/B&gt;.&lt;BR&gt;\n"</font><font color="#007700">;<br>
<br>
echo </font><font color="#dd0000">"Typ proměnné muj_integer byl
&lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$muj_integer</font><font color="#007700">).</font><font color="#dd0000">"&lt;/B&gt;"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">" a hodnota byla &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$muj_integer</font><font color="#007700">.</font><font color="#dd0000">"&lt;/B&gt;. "</font><font color="#007700">;<br>
</font><font color="#0000bb">settype</font><font color="#007700">(</font><font color="#0000bb">$muj_integer</font><font color="#007700">, </font><font color="#dd0000">"float"</font><font color="#007700">);<br>
echo </font><font color="#dd0000">"Po změně na &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$muj_integer</font><font color="#007700">).</font><font color="#dd0000">"&lt;/B&gt; je hodnota
&lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$muj_integer</font><font color="#007700">.</font><font color="#dd0000">"&lt;/B&gt;.&lt;BR&gt;\n"</font><font color="#007700">;<br>
<br>
echo </font><font color="#dd0000">"Typ proměnné muj_float byl
&lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$muj_float</font><font color="#007700">).</font><font color="#dd0000">"&lt;/B&gt;"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">" a hodnota byla &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$muj_float</font><font color="#007700">.</font><font color="#dd0000">"&lt;/B&gt;. "</font><font color="#007700">;<br>
</font><font color="#0000bb">settype</font><font color="#007700">(</font><font color="#0000bb">$muj_float</font><font color="#007700">, </font><font color="#dd0000">"integer"</font><font color="#007700">);<br>
echo </font><font color="#dd0000">"Po změně na &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$muj_float</font><font color="#007700">).</font><font color="#dd0000">"&lt;/B&gt; je hodnota
&lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$muj_float</font><font color="#007700">.</font><font color="#dd0000">"&lt;/B&gt;.&lt;BR&gt;\n"</font><font color="#007700">;<br>
<br>
echo </font><font color="#dd0000">"Typ proměnné muj_boolean byl
&lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$muj_boolean</font><font color="#007700">).</font><font color="#dd0000">"&lt;/B&gt;"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">" a hodnota byla &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$muj_boolean</font><font color="#007700">.</font><font color="#dd0000">"&lt;/B&gt;. "</font><font color="#007700">;<br>
</font><font color="#0000bb">settype</font><font color="#007700">(</font><font color="#0000bb">$muj_boolean</font><font color="#007700">, </font><font color="#dd0000">"integer"</font><font color="#007700">);<br>
echo </font><font color="#dd0000">"Po změně na &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$muj_boolean</font><font color="#007700">).</font><font color="#dd0000">"&lt;/B&gt; je hodnota
&lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$muj_boolean</font><font color="#007700">.</font><font color="#dd0000">"&lt;/B&gt;.&lt;BR&gt;\n"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Kód je to trošku delší (zvykejte si), takže něco komentářů. Nejprve
jsme si vytvořili čtyři proměnné a naplnili jsme je takovými hodnotami,
že
reprezentují 4 základní datové typy. Potom děláme čtyřikrát totéž -
nejprve vypíšeme "starý" typ a hodnotu proměnné pomocí gettype, pak ji
přetypujeme a vypíšeme typ a hodnotu novou.</p>
<p>Další věc, kterou byste si měli uvědomit je ta, že PHP může
přetypovat samo. Zvažme následující situaci:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$cislo</font><font color="#007700">=</font><font color="#0000bb">5</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Typ je "</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$cislo</font><font color="#007700">).</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
</font><font color="#0000bb">$cislo</font><font color="#007700">/=</font><font color="#0000bb">2</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Teď je typ "</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$cislo</font><font color="#007700">).</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Tady jsme pětku dělili dvojkou; což vedlo k tomu, že z výsledku, a
tudíž ze samotné proměnné $cislo se stal typ float.<br>
</p>
<p>Přetypování se řídí několika pravidly, které jsem se pokusil shrnout
v
následující tabulce:</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; width: 20%;">Nový typ
(vpravo)-&gt;<br>
Původní typ (dole)<br>
      </td>
      <td style="vertical-align: top; width: 20%;">String<br>
      </td>
      <td style="vertical-align: top; width: 20%;">Integer<br>
      </td>
      <td style="vertical-align: top; width: 20%;">Float<br>
      </td>
      <td style="vertical-align: top; width: 20%;">Boolean<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 20%;">String<br>
      </td>
      <td style="vertical-align: top; width: 20%;">--<br>
      </td>
      <td style="vertical-align: top; width: 20%;">Začíná-li číslem
toto číslo, jinak nula. Když neobsahuje '.', 'e', nebo 'E'</td>
      <td style="vertical-align: top; width: 20%;">Začíná-li číslem
toto číslo, jinak nula. Když obsahuje '.', 'e', nebo 'E'</td>
      <td style="vertical-align: top; width: 20%;">"" a "0"=false,
ostatní True<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 20%;">Integer<br>
      </td>
      <td style="vertical-align: top; width: 20%;">Převede na řetězec<br>
      </td>
      <td style="vertical-align: top; width: 20%;">--<br>
      </td>
      <td style="vertical-align: top; width: 20%;">Není problém<br>
      </td>
      <td style="vertical-align: top; width: 20%;">0=False, ostatní True<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 20%;">Float<br>
      </td>
      <td style="vertical-align: top; width: 20%;">Převede na řetězec<br>
      </td>
      <td style="vertical-align: top; width: 20%;">První integer směrem
k nule<br>
      </td>
      <td style="vertical-align: top; width: 20%;">--<br>
      </td>
      <td style="vertical-align: top; width: 20%;">0.0=False, ostatní
True<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 20%;">Boolean<br>
      </td>
      <td style="vertical-align: top; width: 20%;">false="" true="1"<br>
      </td>
      <td style="vertical-align: top; width: 20%;">false=0 true=1<br>
      </td>
      <td style="vertical-align: top; width: 20%;">false=0.0 true=1.0<br>
      </td>
      <td style="vertical-align: top; width: 20%;">--<br>
      </td>
    </tr>
  </tbody>
</table>
<p>Z tabulky je vidět, že to většinou je intuitivní.<br>
</p>
<a name="000040"></a><h2>Související funkce</h2>
<p>Někdy může být užitečné změnit typ proměnné jen na chvilku a pak ji
zase používat starým způsobem. Toho dosáhneme tak, že před název
proměnné napíšeme do závorky, jaký typ by v okamžiku vyhodnocení měla
mít.
Když si vypůjčíme část kódu z prvního příkladu a trochu to rozšíříme,
bude:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$muj_float</font><font color="#007700">=</font><font color="#0000bb">3.5</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Typ proměnné muj_float byl
&lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$muj_float</font><font color="#007700">).</font><font color="#dd0000">"&lt;/B&gt;"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">" a hodnota byla &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$muj_float</font><font color="#007700">.</font><font color="#dd0000">"&lt;/B&gt;.&lt;BR&gt;\n"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Na řetězec -&gt;"</font><font color="#007700">.(string)</font><font color="#0000bb">$muj_float</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Na celé číslo -&gt;"</font><font color="#007700">.(int)</font><font color="#0000bb">$muj_float</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Na boolean -&gt;"</font><font color="#007700">.(boolean)</font><font color="#0000bb">$muj_float</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Po všech těch změnách je ale typ
proměnné stále &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">gettype</font><font color="#007700">(</font><font color="#0000bb">$muj_float</font><font color="#007700">).</font><font color="#dd0000">"&lt;/B&gt; a hodnota &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$muj_float</font><font color="#007700">.</font><font color="#dd0000">"&lt;/B&gt;.&lt;BR&gt;\n"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Kromě funkce gettype, která vrátí řetězec obsahující název typu
proměnné existuje ještě sada funkcí, které vrací TRUE v případě, že
proměnná je odpovídajícího typu. Existují tedy funkce <a href="http://cz.php.net/manual/en/function.is-bool.php">is_bool</a>,
<a href="http://cz.php.net/manual/en/function.is-int.php">is_integer</a>,
<a href="http://cz.php.net/manual/en/function.is-string.php">is_string</a>
a <a href="http://cz.php.net/manual/en/function.is-float.php">is_float</a>.<br>
</p>
<a name="000041"></a><h2>Poznámky k přetypování</h2>
<ul>
  <li>Jelikož příkaz echo vyžaduje řetězce, jsou proměnné před tiskem
zkonvertovány podle zásad v tabulce uvedené výše. Logická hodnota FALSE
vrací prázdný řetězec, pozor na to.</li>
  <li>Při konverzi na logický typ pamatujte na to, že všechno kromě
nuly a prázdného řetězce je považováno za TRUE.</li>
  <li>Buďte rozumní. Pokud si nejste jisti, že ve Vašem kódu budou
fungovat automatické konverze, konvertujte ručně, nebo testujte typ
proměnné.</li>
  <li>Funkci gettype byste podle nápovědy k PHP měli používat s
rozmyslem, protože je pomalá a v dalších verzích PHP se může měnit</li>
</ul>
<p>Znám programy, které používají celkem zbytečně přetypování takových
proměnných, které již daný typ mají. To může program poměrně dost
zpomalit. Na druhou stranu by se mělo vzít v úvahu to, že PHP
přetypovává poměrně ochotně - a to někdy vadí. Čili, cílem je najít
kompromis.</p>
<a name="000042"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (10) - Logické výrazy a operátory</h2>
			<p class="perex">Logické výrazy a operátory v PHP.
				<br>
			</p>
			<p>Logické operátory se v PHP víceméně neliší od stejných operátorů v
jiných programovacích jazycích, ale to neznamená, že je v našem
tutoriálu vynecháme. Pojďme se tedy podívat, jak se používají. Pokud
logické výrazy chronicky znáte z jiných programovacích jazyků, možná
můžete tento díl přeskočit.<br>
</p>
<p>Již jsme si uvedli, že PHP má datový typ boolean reprezentovaný
hodnotami TRUE a FALSE. Má také operátory, které Vám umožní s nimi
pracovat. Především bychom si měli ale říci, že pro logické operace se
nedoporučuje používat klasické operátory "+", "-", "*" a "/". Když to
uděláme, neskončí to chybou, protože PHP provede <a href="#000039">přetypování</a>.
Nicméně,
chování programu bude většinou zvláštní. Dokázali byste si například
tipnout, co vrátí následující kód?</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$pravda </font><font color="#007700">=</font><font color="#0000bb">TRUE</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Logický nesmysl "</font><font color="#007700">.</font><font color="#0000bb">$pravda </font><font color="#007700">+ </font><font color="#0000bb">$pravda</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Asi se Vám to první pohled bude zdát divné, ale výsledkem bude pouhá
jednička. PHP totiž první řetězec převedl na LOGICKOU hodnotu a pak s
ní tak pracoval. Z toho je myslím patřičně vidět, že potřebujeme
logické operátory. V PHP existují následující:<br>
</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; font-weight: bold;">Operátor<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Význam<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Pravda když<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">and<br>
      </td>
      <td style="vertical-align: top;">Logický součin<br>
      </td>
      <td style="vertical-align: top;">Jsou obě hodnoty pravdivé<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">or<br>
      </td>
      <td style="vertical-align: top;">Logický součet<br>
      </td>
      <td style="vertical-align: top;">Je alespoň jedna hodnota pravdivá<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">xor<br>
      </td>
      <td style="vertical-align: top;">Exkluzivní OR<br>
      </td>
      <td style="vertical-align: top;">Je právě jedna hodnota pravdivá<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">!<br>
      </td>
      <td style="vertical-align: top;">Negace<br>
      </td>
      <td style="vertical-align: top;">True když bylo False a naopak<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&amp;&amp;<br>
      </td>
      <td style="vertical-align: top;">Logický součin<br>
      </td>
      <td style="vertical-align: top;">Jsou obě hodnoty pravdivé</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">||<br>
      </td>
      <td style="vertical-align: top;">Logický součet<br>
      </td>
      <td style="vertical-align: top;">Je alespoň jedna hodnota pravdivá</td>
    </tr>
  </tbody>
</table>
<p>Několik příkladů to vysvětlí:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">// jestliže například<br>
</font><font color="#0000bb">$mam_papir</font><font color="#007700">=</font><font color="#0000bb">TRUE</font><font color="#007700">; </font><font color="#0000bb">$mam_inkoust</font><font color="#007700">=</font><font color="#0000bb">TRUE</font><font color="#007700">;<br>
</font><font color="#ff8000">// ... je jasné, že<br>
</font><font color="#0000bb">$mohu_tisknout</font><font color="#007700">=</font><font color="#0000bb">$mam_papir </font><font color="#007700">&amp;&amp; </font><font color="#0000bb">$mam_inkoust</font><font color="#007700">;<br>
</font><font color="#ff8000">// což je totéž jako<br>
</font><font color="#0000bb">$mohu_tisknout</font><font color="#007700">=</font><font color="#0000bb">$mam_papir </font><font color="#007700">and </font><font color="#0000bb">$mam_inkoust</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Tady se jednalo o logický <span style="font-weight: bold;">součin</span>.
Pokud chci tisknout, musím mít <span style="font-weight: bold;">jak </span>papír,
<span style="font-weight: bold;">tak </span>i inkoust. <br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">// jestliže například<br>
</font><font color="#0000bb">$mam_penize_doma</font><font color="#007700">=</font><font color="#0000bb">FALSE</font><font color="#007700">; </font><font color="#0000bb">$mam_penize_v_bance</font><font color="#007700">=</font><font color="#0000bb">TRUE</font><font color="#007700">;<br>
</font><font color="#ff8000">// ... je jasné, že<br>
</font><font color="#0000bb">$mam_penize</font><font color="#007700">=</font><font color="#0000bb">$mam_penize_doma </font><font color="#007700">|| </font><font color="#0000bb">$mam_penize_v_bance</font><font color="#007700">;<br>
</font><font color="#ff8000">// což je totéž jako<br>
</font><font color="#0000bb">$mam_penize</font><font color="#007700">=</font><font color="#0000bb">$mam_penize_doma </font><font color="#007700">or </font><font color="#0000bb">$mam_penize_v_bance</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Tady se jednalo o logický <span style="font-weight: bold;">součet</span>.
Peníze mám <span style="font-weight: bold;">jak </span>v případě, že
jsou doma, <span style="font-weight: bold;">tak </span>i v případě,
že jsou v bance ;-))). Peníze mám dokonce i případě, že jsou jak doma
tak i v bance, proto se jedná o <span style="font-weight: bold;">neexkluzivní
</span>OR.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$mam_malo_penez </font><font color="#007700">= </font><font color="#0000bb">true</font><font color="#007700">;<br>
</font><font color="#0000bb">$jsem_bohaty </font><font color="#007700">=
!</font><font color="#0000bb">$mam_malo_penez</font><font color="#007700">;<br>
echo (integer)</font><font color="#0000bb">$jsem_bohaty</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Negace je myslím jasná. Jestliže <span style="font-weight: bold;">mám
</span>málo peněz, pak <span style="font-weight: bold;">nejsem </span>bohatý.
Ve skriptu si můžete všimnout jedné věci: nevypsal jsem hodnotu
proměnné $jsem_bohaty, ale její reprezentaci jakožto celého čísla. Echo
$jsem_bohaty by vrátilo prázdný řetězec, současný kód však vrací nulu.
Proč je to tak bylo popsáno v díle o přetypování proměnných.<br>
</p>
<p>Logické exkluzivní OR (XOR) se používá v programování především na
šifrovací algoritmy a pro psaní webů se bez něj asi obejdate. Ať
přemýšlím jak přemýšlím, nepodařil se mi najít žádký příklad z praxe,
který by jej dostatečně ilustroval a ve svých skriptech jsem ho nikdy
nepoužil. <br>
</p>
<p>Dva operátory pro logický součet a dva operátory pro logický součit
se od sebe liší prioritou. Bude o tom řeč v příštím díle našeho seriálu.</p>
<a name="000043"></a><h2>Poznámky k logickým výrazům</h2>
<ul>
  <li>Naučte se je. Bude to potřeba.</li>
  <li>PHP nemá logický operátor NOT. Má místo toho vykřičník (!), který
se píše před negovaný výraz.</li>
  <li>Některé PHP funkce vracejí logické hodnoty, například TRUE v
případě úspěchu, FALSE v případě neúspěchu</li>
  <li>Nepleťte si toto: AND není logický součet, ale součin.
Zapamatujte si "a zároveň".</li>
  <li>Když si nebudete jisti tím, jak se vyhodnocuje složitější logický
výraz, není žádná ostuda rozdělit jej na několik jednodušších.<br>
  </li>
</ul>
<p>K logickým operátorům ještě jedna důležitá poznámka. Vždycky nemáme
při programování to štěstí, že logické výrazy jsou rovny buď FALSE nebo
TRUE. Při práci s databázemi se velice často stává, že musíme sáhnout k
"třístavové logice". Více o tom bude pojednáno v některém <a href="#000148">díle o MySQL</a>,
ale měli bychom poznamenat, že z hlediska databází je někdy logická
hodnota buď <span style="font-weight: bold;">TRUE</span>, nebo <span style="font-weight: bold;">FALSE </span>nebo <span style="font-weight: bold;">NEZNÁMÁ </span>(NULL). Pozor na to.
Setkáte se s tím.<br>
</p>
<p>Příště se v našem seriálu podíváme na operátory, na které se zatím
nedostalo, a na prioritu operátorů.</p>
<a name="000044"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (11) - Operátory porovnání; priorita operátorů</h2>
			<p class="perex">V dnešním díle našeho Mega-PHP seriálu se podíváme
na zbytek operátorů, o kterých ještě nebyla řeč. Zmíním se i o prioritě operátorů.

				<br>
			</p>
			<p>Většinu operátorů, které budete při práci s PHP potřebovat,
jsme v tomto seriálu již probrali. Podívejme se teď na zbytek těch,
které by se nám při práci s PHP mohly hodit.<br>
</p>
<p>Zatím jsme žili s PHP ve světě, v němž nebyla řeč o chybách. Chyby
se ale v programování vyskytují a bude jim později věnován celý <a href="#000117">jeden
článek seriálu</a>. Nyní si uveďme, že PHP umí použít operátor zavináče
před <span style="font-weight: bold;">výrazem</span>, což způsobí, že
případná chyba při vyhodnocování tohoto
výrazu bude neokázale ignorována. Příklad:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#0000bb">1</font><font color="#007700">/</font><font color="#0000bb">0</font><font color="#007700">; </font><font color="#ff8000">// skončí chybou
Division by zero<br>
</font><font color="#007700">echo @(</font><font color="#0000bb">1</font><font color="#007700">/</font><font color="#0000bb">0</font><font color="#007700">); </font><font color="#ff8000">// půjde dál<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Je to myslím dostatečně jasné. Jen dodejme, že zavináč nepatří před
příkaz echo, protože echo je jazykový konstrukt a ne výraz. Chyby se
ale vždy takto neřeší, je to jen jedna možnost. Více později.<br>
</p>
<a name="000045"></a><h2>Operátory porovnání</h2>
<p>Jiná skupina operátorů, kterou jsme zatím vynechali, jsou
porovnávací operátory. Protože fungují podobně jako v matematice,
pojďme si nejprve ukázat
příklad a pak probrat zvláštnosti:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$a</font><font color="#007700">=</font><font color="#0000bb">5</font><font color="#007700">; </font><font color="#0000bb">$b</font><font color="#007700">=</font><font color="#0000bb">6</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$a</font><font color="#007700">&lt;</font><font color="#0000bb">$b</font><font color="#007700">; </font><font color="#ff8000">// vrátí TRUE<br>
</font><font color="#007700">echo </font><font color="#0000bb">$b</font><font color="#007700">&gt;</font><font color="#0000bb">$a</font><font color="#007700">; </font><font color="#ff8000">// rovněž TRUE<br>
</font><font color="#007700">echo </font><font color="#0000bb">$b</font><font color="#007700">&gt;=</font><font color="#0000bb">$a</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$a</font><font color="#007700">&lt;=</font><font color="#0000bb">$b</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$a</font><font color="#007700">&lt;&gt;</font><font color="#0000bb">$b</font><font color="#007700">; </font><font color="#ff8000">//nerovnost, stejné jako<br>
</font><font color="#007700">echo </font><font color="#0000bb">$a</font><font color="#007700">!=</font><font color="#0000bb">$b</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Tohle bylo snadné. Můžeme porovnávat proměnné pomocí rovnítka (=)?
NE. V PHP, jak již bylo řečeno, slouží rovnítko k přiřazování, takže
zápis $a=$b je sice možný, ale způsobí zkopírování "béčka" do "áčka" a
ne jejich porovnání. Toto byste měli pochopit předtím, než začnete
pracovat s porovnávacími operátory. Co například vrátí následující kód?</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$a</font><font color="#007700">=</font><font color="#0000bb">5</font><font color="#007700">; </font><font color="#0000bb">$b</font><font color="#007700">=</font><font color="#0000bb">6</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$a</font><font color="#007700">=</font><font color="#0000bb">$b</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Vrátí šestku! Řádek s echo bychom totiž měli číst odzadu. Nejprve se
do proměnné $a přiřadilo to, co bylo v proměnné $b. Celé přiřazení je
ovšem v PHP bráno jako výraz, takže má hodnotu pravé strany. Proto
příkaz echo (který se provede až po přiřazení) vrátí hodnotu 6.
Kdybychom chtěli proměnné porovnat, používá se na to operátor == (dvě
rovnítka), jak je uvedeno níže:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$a</font><font color="#007700">=</font><font color="#0000bb">5</font><font color="#007700">; </font><font color="#0000bb">$b</font><font color="#007700">=</font><font color="#0000bb">6</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$a</font><font color="#007700">==</font><font color="#0000bb">$b</font><font color="#007700">; </font><font color="#ff8000">//vrátí FALSE (nic nevypíše)<br>
// ale hodnoty proměnných se nezměnily<br>
</font><font color="#007700">echo </font><font color="#0000bb">$a</font><font color="#007700">,</font><font color="#0000bb">$b</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V PHP se můžete setkat ještě s operátorem === (tři rovnítka). Ten
porovnává nejen hodnotu proměnné, ale i její typ. Říká se mu operátor
identity a platí, že operace porovnání identity vrátí TRUE tehdy, když
jsou si porovnávané výrazy rovny jak do hodnoty, tak do typu. Kraťounký
příkad:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$muj_integer</font><font color="#007700">=</font><font color="#0000bb">5</font><font color="#007700">;<br>
</font><font color="#0000bb">$muj_float </font><font color="#007700">=
</font><font color="#0000bb">5.0</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$muj_integer</font><font color="#007700">==</font><font color="#0000bb">$muj_float</font><font color="#007700">; </font><font color="#ff8000">//to je pravda<br>
</font><font color="#007700">echo </font><font color="#0000bb">$muj_integer</font><font color="#007700">===</font><font color="#0000bb">$muj_float</font><font color="#007700">; </font><font color="#ff8000">//tohle pravda není<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Dodejme pro úplnost, že existuje i operátor pro neidentitu (!==),
který vrátí FALSE i v případě, že hodnoty výrazů rovnají, když se
zároveň jejich typy liší. Operace neidentity vrátí samozřejmě FALSE i v
případě, kdy se liší jak typy porovnávaných proměnných, tak i jejich
hodnoty.<br>
</p>
<a name="000046"></a><h2>Ternální operátor</h2>
<p>Na tomto operátoru je zajímavé, že pracuje ne se dvěma, ale se třemi
výrazy a od toho pochází i jeho název. Striktně řečeno patří k
operátorům porovnání. Funguje tak, že vyhodnocuje jeden výraz. Když ten
výraz platí, je výsledkem operace druhý výraz, když ne, výsledkem je
třetí výraz. Podobá se to slovním vyjádřením typu: "Když bude na účtu
víc než 10000 tak vyber 5000, ale jinak vyber jen 2000". V PHP bychom
to zapsali takto (oba řádky fungují stejně, záleží ne Vašem vkusu):</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$vyber </font><font color="#007700">= </font><font color="#0000bb">$stav_uctu</font><font color="#007700">&gt;</font><font color="#0000bb">10000 </font><font color="#007700">? </font><font color="#0000bb">5000 </font><font color="#007700">: </font><font color="#0000bb">2000</font><font color="#007700">; </font><font color="#ff8000">// nebo<br>
</font><font color="#0000bb">$stav_uctu</font><font color="#007700">&gt;</font><font color="#0000bb">10000 </font><font color="#007700">? </font><font color="#0000bb">$vyber</font><font color="#007700">=</font><font color="#0000bb">5000 </font><font color="#007700">: </font><font color="#0000bb">$vyber</font><font color="#007700">=</font><font color="#0000bb">2000</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Ternální operátor patří k těm prvkům jakzyka PHP, které si buď
oblíbíte nebo se jim budete vyhýbat, ale většinou budete mít na ně
vyhraněný názor. Je pravda, že bez ternálního operátoru se můžete
obejít; ale zápis s jeho použitím bývá kratší.<br>
</p>
<a name="000047"></a><h2>Priorita operátorů</h2>
<p>Operátory v PHP mají svou prioritu, takže kód se vždy nevykonává
tupě zleva doprava. Například kód</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">2</font><font color="#007700">+</font><font color="#0000bb">3</font><font color="#007700">*</font><font color="#0000bb">4?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>vrátí matematicky správných 14 a nikoli 20, protože PHP ví, že
násobení
má přednost před sčítáním. Pokud budeme chtít vestavěnou prioritu
vyhodnocování výrazu změnit, použijeme závorky jako v matematice.
Závorky mohou být vnořené, v takovém případě se výraz vyhodnocuje od
nejvnitřnějších závorek. K tomu zase kratičký kód:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?</font><font color="#007700">echo ((</font><font color="#0000bb">2</font><font color="#007700">+</font><font color="#0000bb">3</font><font color="#007700">)*</font><font color="#0000bb">4</font><font color="#007700">)/</font><font color="#0000bb">8?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Protože prioritu operátorů někteří nenosí v hlavě, není žádná ostuda
"uzávorkovat" výraz i v případě, že by se stejně vyhodnocoval i se
závorkami. Někdy to vede k tomu, že je kód čitelnější.<br>
</p>
<a name="000048"></a><h2>Poznámky k článku</h2>
<ul>
  <li>Existují i operátory, které jsme neprobírali. V praxi se s nimi
ale většinou nesetkáte.</li>
  <li>Pozor na rozdíl mezi přiřazením a porovnáním. Není to totéž.</li>
  <li>Ternální operátor vyhodnocuje vždy jen větev, kterou se vydá. To
je rozdíl od např. ASP, kde se vyhodnocují obě větve. To může být
důležité pro správu chyb - ASP selže, pokud je chyba ve větvi, kterou
se nakonec nepůjde, PHP neselže.<br>
  </li>
</ul>
<a name="000049"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (12) - Podmínky</h2>
			<p class="perex">PHP má samozřejmě příkazy pro řízení toku programu. Dnes se podíváme na podmínky.
				<br>
			</p>
			<p>Tok programu, tedy i tok skriptu v PHP jen zřídkakdy probíhá od
začátku
do konce po jedné linii. Většinou chcete reagovat na okolní podmínky. K
tomu slouží v PHP, stejně jako snad ve všech ostatních exisujících
programovacích jazycích <span style="font-style: italic;">podmínky</span>.<br>
</p>
<p>Podmínky fungují v tom nejjednodušším případě tak, že nejprve je
vyhodnocen určitý výraz. Je-li
výraz pravdivý, provede se příkaz. PHP má pro podmínku klíčové slovo
if. Typický příklad můžeme vidět níže:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$pristup_odepren </font><font color="#007700">= </font><font color="#0000bb">TRUE</font><font color="#007700">;<br>
if (</font><font color="#0000bb">$pristup_odepren</font><font color="#007700">) echo </font><font color="#dd0000">"Na tuto stránku
se nemůžete dostat bez autorizace"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Vidíme, že logický výraz je v tomto příkladu reprezentován
proměnnou.
Když je podmínka splněna, provede se příkaz echo; to bude v našem
případě vždy. Co když ale budeme chtít provést více než jeden příkaz? A
co když budeme chtít specifikovat i příkaz, který se má provést při
<span style="font-style: italic;">nesplnění </span>podmínky? To
demonstrujeme v následující ukázce, která je
rozšířením původního příkladu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$pristup_odepren </font><font color="#007700">= </font><font color="#0000bb">FALSE</font><font color="#007700">;<br>
if (</font><font color="#0000bb">$pristup_odepren</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Na tuto stránku se
nemůžete dostat bez autorizace &lt;BR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Vaše IP adresa byla
zaznamenána do protokolu."</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Vítejte na této
stránce&lt;BR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;echo </font><font color="#0000bb">$pocetnavstev</font><font color="#007700">++;<br>
&nbsp;&nbsp;}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jak vidíte, při nesplnění podmínky postupuje program větví, která
začíná slovem else. Z příkladu také vyplývá, že více příkazů může bých
chápáno jako jeden příkaz, když jsou uzavřeny do složených závorek { a
}. Známe ještě jednu formu příkazu if. Její rozšíření spočívá v tom, že
zavádí klíčové slovo elseif a program tak může reagovat na několik
podmínek za sebou. Dejme tomu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">if (</font><font color="#0000bb">$browser</font><font color="#007700">==</font><font color="#dd0000">"Mozilla"</font><font color="#007700">) echo </font><font color="#dd0000">"Výborně !!!"</font><font color="#007700">;<br>
elseif (</font><font color="#0000bb">$browser</font><font color="#007700">==</font><font color="#dd0000">"Konqueror"</font><font color="#007700">) echo </font><font color="#dd0000">"Dobře ."</font><font color="#007700">;<br>
elseif (</font><font color="#0000bb">$browser</font><font color="#007700">==</font><font color="#dd0000">"Explorer"</font><font color="#007700">) echo </font><font color="#dd0000">";-("</font><font color="#007700">;<br>
else echo </font><font color="#dd0000">"Nepodařilo se zjistit Váš
browser"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Kód je myslím výmluvný; všimněte si, že větví <span style="font-style: italic;">elseif </span>může být i
více. Není vůbec nutné v každé větvi vyhodnocovat stejný výraz,
důležité je pouze to, aby se vyhodnocoval výraz vracející logickou
hodnotu.<br>
</p>
<p>Podmínka if má v PHP i alternativní syntaxi zápisu. Níže uveďme naše
tři příklady přepsané alternativně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">//příklad první<br>
</font><font color="#0000bb">$pristup_odepren </font><font color="#007700">= </font><font color="#0000bb">TRUE</font><font color="#007700">;<br>
if (</font><font color="#0000bb">$pristup_odepren</font><font color="#007700">):<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Na tuto
stránku se nemůžete dostat bez autorizace"</font><font color="#007700">;<br>
endif;<br>
</font><font color="#ff8000">//příklad druhý<br>
</font><font color="#007700">if (</font><font color="#0000bb">$pristup_odepren</font><font color="#007700">):<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Na tuto stránku se
nemůžete dostat bez autorizace &lt;BR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Vaše IP adresa byla
zaznamenána do protokolu."</font><font color="#007700">;<br>
else:<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Vítejte na této
stránce&lt;BR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;echo </font><font color="#0000bb">$pocetnavstev</font><font color="#007700">++;<br>
endif;<br>
</font><font color="#ff8000">// příklad třetí<br>
</font><font color="#007700">if (</font><font color="#0000bb">$browser</font><font color="#007700">==</font><font color="#dd0000">"Mozilla"</font><font color="#007700">):<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Výborně !!!"</font><font color="#007700">;<br>
elseif (</font><font color="#0000bb">$browser</font><font color="#007700">==</font><font color="#dd0000">"Konqueror"</font><font color="#007700">):<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Dobře ."</font><font color="#007700">;<br>
elseif (</font><font color="#0000bb">$browser</font><font color="#007700">==</font><font color="#dd0000">"Explorer"</font><font color="#007700">):<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">";-("</font><font color="#007700">;<br>
else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Nepodařilo
se zjistit Váš browser"</font><font color="#007700">;<br>
endif;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jak je z ukázky pěkně vidět, někdy to kód zkrátí, jindy ne. Praxe je
ta, že se to většinou mixuje.<br>
</p>
<a name="000050"></a><h2>Příkaz switch</h2>
<p>Jak bylo vidět z příkladu s browsery, často potřebujeme opakovaně
vyhodnocovat stejný výraz a podle jeho hodnoty provést odpovídající
akci
ve skriptu. K tomu může sloužit příkaz if, nebo má PHP příkaz switch.
Přepišme náš "browserový" příklad pomocí switch:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">switch (</font><font color="#0000bb">$browser</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;case </font><font color="#dd0000">"Mozilla"</font><font color="#007700">:<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Výborně !!!"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;case </font><font color="#dd0000">"Konqueror"</font><font color="#007700">:<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Dobře ."</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;case </font><font color="#dd0000">"Explorer"</font><font color="#007700">:<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">";-("</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;default:<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Nepodařilo
se zjistit Váš browser"</font><font color="#007700">;<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>K dispozici je rovněž alternativní syntaxe</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">switch (</font><font color="#0000bb">$browser</font><font color="#007700">):<br>
&nbsp;&nbsp;case </font><font color="#dd0000">"Mozilla"</font><font color="#007700">:<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Výborně !!!"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;case </font><font color="#dd0000">"Konqueror"</font><font color="#007700">:<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Dobře ."</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;case </font><font color="#dd0000">"Explorer"</font><font color="#007700">:<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">";-("</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;default:<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Nepodařilo
se zjistit Váš browser"</font><font color="#007700">;<br>
endswitch;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Funguje to následovně: Jedřív se zjistí hodnota proměnné
$browser. Pak se procházejí jednotlivé větve a když se narazí na
odpovídající případ, provede se větev až k příkazu <span style="font-style: italic;">break</span>, nebo do <span style="font-style: italic;">endswitch</span>. Default je větev, kterou
můžeme volitelně zařadit pro případ, že
nevyhoví nic z předchozích. Když zapomenete na příkaz break, provede se
kód až k nejbližšímu dalšímu příkazu break nebo do konce podmínky (což
se někdy dělá schválně a jindy to vede k chybám).<br>
</p>
<a name="000051"></a><h2>Poznámky k podmínkám</h2>
<ul>
  <li>Bez podmínek se v programování neobejdete. Naučte se je. Z hlavy.<br>
  </li>
  <li>Příkaz v některé větvi podmínky může být zase podmínka. Vnořené
podmínky jsou někdy potřeba, ale mohou pěkně znepřehlednit kód.</li>
  <li>Zvažte použití větve else v podmínce vždy, když si nejste
absolutně jisti, že větve elseif pokrývají všechny alternativy.
Stejnětak větev default v příkazu switch.<br>
  </li>
  <li>Formátujte kód tak, abyste se v něm vyznali. Někdy může
formátovací plugin Vašeho oblíbeného PHP editoru udělat hotový zázrak.</li>
  <li>KOMENTUJTE. Podmínky mohou být složité a za půl roku, když budete
potřebovat skript oprášit už nebudete vědět, proč jste je psali.</li>
  <li>Vyhodnocovaný výraz musí být v závorkách a PHP nemá klíčové slovo
THEN. To je zvláště potřeba si uvědomit, pokud přecházíte na PHP z ASP.</li>
  <li>Jestliže je příkaz v některé větvi podmínky složený z mnoha
dílčích příkazů, zvažte použití funkcí. Bude o nich v seriálu
zanedlouho řeč.</li>
  <li>Jestliže podmínka slouží k vložení html kódu v jedné nebo více
větvích, možná budete chtít uzavřít kód PHP (?&gt;), abyste se vyhnuli
dlouhým sadám příkazů echo.<br>
  </li>
</ul>
<a name="000052"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (13) - Příkazy cyklu</h2>
			<p class="perex">V dnešním díle seriálu o PHP se podíváme na příkazy cyklů. Půjde o cykly s podmínkami.
				<br>
			</p>
			<p>Příkazy cyklů jsou v každém programovacím jazyce jedním z
nejdůležitějších prvků. Ve většině kódů najdeme příklady činností,
které se opakují. Dobrým příkladem může být třeba tvorba tabulek, tam
se opakují tagy &lt;TR&gt; a &lt;TD&gt; pro každý řádek, respektive
buňku. V PHP
rozeznáváme podle toho, jak jsou cykly řízeny celkem tři jejich typy a
dnes bude řeč o prvních dvou. <br>
</p>
<p>Počínaje tímto dílem našeho seriálu už si budeme uvádět trochu
složitělší příklady. Základy syntaxe jsme již převážně prošli, uvidíme,
jak můžeme
jednotlivé poznatky pospojovat do kódu, který již "něco umí". Takže,
smyčky například budou řešit
následující zadání: Sestavit tabulku, která vypíše čísla od 1 do 10 a
jejich druhé mocniny.<br>
</p>
<a name="000053"></a><h2>Smyčka s podmínkou na začátku</h2>
<p>Smyčka s podmínkou na začátku testuje výraz; a pokud výraz platí
provádí příkaz nebo sadu příkazů. Odpovídající slovní vyjádření je: <span style="font-weight: bold;">Zatímco </span>platí výraz, proveď příkaz.
V PHP se použije jazyková konstrukce <a href="http://cz.php.net/manual/en/control-structures.while.php">while</a>.
<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE&gt;<br>
&lt;TR&gt;&lt;TD&gt;Číslo&lt;/TD&gt;&lt;TD&gt;Druhá
mocnina&lt;/TD&gt;&lt;/TR&gt;<br>
<font color="#0000bb">&lt;?<br>
$i</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">;<br>
while (</font><font color="#0000bb">$i</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TR&gt;&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$i</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$i</font><font color="#007700">*</font><font color="#0000bb">$i</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;&lt;/TR&gt;\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$i</font><font color="#007700">++;<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font>&lt;/TABLE&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Náš příklad s druhými mocninami jsme tedy vyřešili následujícím
způsobem: Zavedli jsme proměnnou, přiřadili jsme jí hodnotu 1 a pak
jsme vypsali tuto proměnnou a její druhou mocninu. Pomocí <a href="#000034">inkrementace</a>
jsme následně zvýšili hodnotu proměnné $i o jedničku a celý cyklus se
opakoval. Komu nebude jasné, jak skript funguje, ať si zobrazí zdrojový
kód
výsledného souboru v prohlížeči (všimněte si použití \n kvůli
formátování;kód to neovlivní).<br>
</p>
<p>Smyčky s podmínkou na začátku se nemusí provést ani jednou. Pokud
již při prvním testování výraz s <span style="font-style: italic;">while
</span>vrátí hodnotu <span style="font-style: italic;">false</span>,
tělo smyčky se vůbec
neprovede. K dispozici je i alternativní syntaxe, která vypadá asi
následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE&gt;<br>
&lt;TR&gt;&lt;TD&gt;Číslo&lt;/TD&gt;&lt;TD&gt;Druhá
mocnina&lt;/TD&gt;&lt;/TR&gt;<br>
<font color="#0000bb">&lt;?<br>
$i</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">;<br>
while (</font><font color="#0000bb">$i</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">):<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TR&gt;&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$i</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$i</font><font color="#007700">*</font><font color="#0000bb">$i</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;&lt;/TR&gt;\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$i</font><font color="#007700">++;<br>
endwhile;<br>
</font><font color="#0000bb">?&gt;<br>
</font>&lt;/TABLE&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Tady se hodí trochu odbočit od tématu a všimnout si jiné zajímavé
věci - a sice toho, že značky
ohraničující kód PHP nutně nemusejí být vždy na začátku a konci
skriptu.
Komu to více vyhovuje, může to přepsat způsobem, kde se kódy HTML a PHP
budou těsněji prolínat. Třeba nějak takhle:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE&gt;<br>
&lt;TR&gt;&lt;TD&gt;Číslo&lt;/TD&gt;&lt;TD&gt;Druhá
mocnina&lt;/TD&gt;&lt;/TR&gt;<br>
<font color="#0000bb">&lt;? $i</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; while (</font><font color="#0000bb">$i</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">):</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&lt;TR&gt;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$i?&gt;</font>&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$i</font><font color="#007700">*</font><font color="#0000bb">$i?&gt;</font>&lt;/TD&gt;&lt;/TR&gt;<br>
<font color="#0000bb">&lt;?&nbsp;&nbsp;$i</font><font color="#007700">++;
endwhile; </font><font color="#0000bb">?&gt;<br>
</font>&lt;/TABLE&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Který způsob je lepší? Těžko říct - někdy to může znamenat zkrácení
kódu na úkor
čitelnosti, někomu to ale může vyhovovat.<br>
</p>
<a name="000054"></a><h2>Smyčka s podmínkou na konci</h2>
<p>Smyčka s podmínkou na konci se nedrží oblíbeného pravidla "stokrát
měř, jednou řež" a funguje tak, že se nejprve minimálně jednou provede
tělo smyčky a teprve potom se testuje podmínka. Česky bychom řekli:
Proveď příkaz, <span style="font-weight: bold;">dokud </span>platí
výraz. Náš příklad s mocninami by docela dobře mohl používat i <a href="http://cz.php.net/manual/en/control-structures.do.while.php">cyklus
s
podmínkou
na konci</a>, vypadalo by to asi takhle</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE&gt;<br>
&lt;TR&gt;&lt;TD&gt;Číslo&lt;/TD&gt;&lt;TD&gt;Druhá
mocnina&lt;/TD&gt;&lt;/TR&gt;<br>
<font color="#0000bb">&lt;?<br>
$i</font><font color="#007700">=</font><font color="#0000bb">0</font><font color="#007700">;<br>
do<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$i</font><font color="#007700">++;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TR&gt;&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$i</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$i</font><font color="#007700">*</font><font color="#0000bb">$i</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;&lt;/TR&gt;\n"</font><font color="#007700">;<br>
} while (</font><font color="#0000bb">$i</font><font color="#007700">&lt;</font><font color="#0000bb">10</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font>&lt;/TABLE&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Ke smyčce s podmínkou na konci
však neexistuje alternativní syntaxe.</p>
<a name="000055"></a><h2>Nekonečné smyčky</h2>
<p>Se smyčkami je většinou hodně zábavy. Například se může snadno stát,
že vytvoříme nekonečnou smyčku. Zvažme následující příklad (ale
nespouštějme to):</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$i</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">;<br>
while (</font><font color="#0000bb">$i</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">) </font><font color="#0000bb">$i</font><font color="#007700">++;<br>
echo </font><font color="#0000bb">$i</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Myslíte, že příkaz vrátí dvojku? Na první pohled by se to mohlo
zdát. Ve skutečnosti jsme vytvořili nekonečnou smyčku. Za while jsme
totiž nenapsali příkaz porovnání, ale přiřazení. Prostě místo dvou
rovnítek jen jedno. Tím pádem bude celý výraz $i=1 roven jedné a
převedeno na logickou hodnotu to bude TRUE. Příkaz se nám zacyklí a
skončí nejspíše až tehdy, když uplyne maximální čas pro vykonávání
skriptu.<br>
</p>
<a name="000056"></a><h2>Poznámky ke smyčkám</h2>
<ul>
  <li>Nemám to zjištěno empiricky, ale většinou jsou oblíbenější smyčky
s podmínkou na začátku. Tak například funkce, která prochází data
vrácená z databáze používá cyklus s podmínkou na začátku proto, že
nejprve testuje, zda jsou vůbec nějaká data k dispozici. Kdybychom se
pokusili pracovat s neexistujícími daty pomocí smyčky s podmínku na
konci, skončíme nejspíš chybou.</li>
  <li>Smyčky se mohou vnořovat. Formátujte si kód.<br>
  </li>
  <li>Zvažte použití komentářů, zejména u delších smyček. Vůbec totiž
nemusí být jasné, kde smyčka začala, když je kód dlouhý. Komentujte
konce smyček.<br>
  </li>
</ul>
<p>V dalším díle seriálu se podíváme na smyčku s parametrem a rovněž na
příkazy <span style="font-style: italic;">break </span>a <span style="font-style: italic;">continue</span>, které možnosti smyček
podstatným způsobem rozšiřují.</p>
<a name="000057"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (14) - Cyklus for</h2>
			<p class="perex">PHP má samozřejmě také smyčku s parametrem. Dnes se podíváme, jak funguje.
				<br>
			</p>
			<p>V minulém díle našeho seriálu jsme se zaměřili na smyčky s
podmínkou.
Dnes uvidíme, jak funguje smyčka s parametrem. Narozdíl od smyčky s
podmínku, kde není předem jisté kolikrát se daná smyčka bude opakovat,
má smyčka s parametrem jinou filozofii. Většinou (ne však vždy) má
takzvaný parametr
smyčky, který určuje počet opakování celého cyklu. Pokud si ještě
vzpomínáte na minulý díl, řešili jsme otázku jak vypsat tabulku čísel a
jejich druhých mocnin. Smyčku s parametrem bychm použili následujícím
způsobem:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE&gt;<br>
&lt;TR&gt;&lt;TD&gt;Číslo&lt;/TD&gt;&lt;TD&gt;Druhá
mocnina&lt;/TD&gt;&lt;/TR&gt;<br>
<font color="#0000bb">&lt;?<br>
</font><font color="#007700">for (</font><font color="#0000bb">$i</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; </font><font color="#0000bb">$i</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">; </font><font color="#0000bb">$i</font><font color="#007700">++) echo </font><font color="#dd0000">"&lt;TR&gt;&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$i</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$i</font><font color="#007700">*</font><font color="#0000bb">$i</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;&lt;/TR&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font>&lt;/TABLE&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Krátké, že? Celý ten mechanismus funguje asi následovně: Před
započetím
vlastního "cyklování" se vyhodnotí první výraz v závorce za příkazem
for (v našem příkladu je to výraz $i=1). Pak se po řadě provedou
následující tři věci:<br>
</p>
<ol>
  <li>Před započetím konkrétního cyklu se vyhodnotí výraz druhý (pro
nás tedy $i&lt;=10). Když neplatí, cyklus se ukončí. Když platí,
pokračujeme dále.<br>
  </li>
  <li>Provede se tělo smyčky. V našem příkladu reprezentované jedním
příkazem, ale mohou se použít složené závorky a vykonat i více příkazů.</li>
  <li>Po ukončení těla smyčky se provede třetí výraz (my v příkladu
zvýšíme $i o
jedničku, na což existuje šikovný příkaz $i++) a vracíme se k bodu 1.</li>
</ol>
<p>Pro uživatelé jazyka C je to normální chování, pokud jste předtím
pracovali v jazycích typu asp, vbs a podobně bude vám pochopení této
smyčky možná trochu trvat. Smyčky <span style="font-style: italic;">for
</span>mají i alternativní synaxi, takže
bychom klidně mohli napsat:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE&gt;<br>
&lt;TR&gt;&lt;TD&gt;Číslo&lt;/TD&gt;&lt;TD&gt;Druhá
mocnina&lt;/TD&gt;&lt;/TR&gt;<br>
<font color="#0000bb">&lt;?<br>
</font><font color="#007700">for (</font><font color="#0000bb">$i</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; </font><font color="#0000bb">$i</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">; </font><font color="#0000bb">$i</font><font color="#007700">++):<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TR&gt;&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$i</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$i</font><font color="#007700">*</font><font color="#0000bb">$i</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;&lt;/TR&gt;"</font><font color="#007700">;<br>
endfor;<br>
</font><font color="#0000bb">?&gt;<br>
</font>&lt;/TABLE&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Což je totéž jako v předchozím případě. Volitelně můžeme libovolný
parametr smyčky vynechat. Jestliže například vynecháme druhý ze tří
parametrů příkazu for, získáme nekonečnou smyčku. To se moc nepoužívá
;-)). Rovněž můžeme v těle smyčky měnit parametr, tedy v našm příkladu
$i. To se sice někdy používá, ale může to kód znepřehlednit.</p>
<p>Smyčky mohou být vnořené. Následující příklad vytvoří tabulku s
malou
násobilkou.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE&gt;<br>
<font color="#0000bb">&lt;?<br>
</font><font color="#007700">for (</font><font color="#0000bb">$radek</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; </font><font color="#0000bb">$radek</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">; </font><font color="#0000bb">$radek</font><font color="#007700">++):<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;for (</font><font color="#0000bb">$sloupec</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; </font><font color="#0000bb">$sloupec</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">; </font><font color="#0000bb">$sloupec</font><font color="#007700">++):<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$radek</font><font color="#007700">*</font><font color="#0000bb">$sloupec</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;endfor;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/TR&gt;"</font><font color="#007700">;<br>
endfor;<br>
</font><font color="#0000bb">?&gt;<br>
</font>&lt;/TABLE&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Kód je přímočarý. Proměnná $sloupec se změní 10x od jedné do deseti
a proměnná $radek jen jednou od jedné do deseti.<br>
</p>
<a name="000058"></a><h2>Příkazy break a continue</h2>
<p>Smyčky, ať už s podmínkou nebo s parametrem nemusejí probíhat vždy
řádně celým cyklem. Někdy může být výhodné provádění cyklu přerušit. K
tomu slouží příkaz <a href="http://cz.php.net/manual/en/control-structures.break.php">break</a>,
se kterým jsme se v tomto seriálu již
setkali. Mluvili jsme o něm v souvislosti s příkazem switch, kde break
ukončoval určitou větev v konstrukci case. Break ale může ukončovat i
cykly <span style="font-style: italic;">do</span>,
<span style="font-style: italic;">while</span> nebo <span style="font-style: italic;">for</span>. Kdybychom předchozí příklad
chtěli upravit tak, aby
vracel pouze čísla do padesáti, můžeme provést něco jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE&gt;<font color="#0000bb">&lt;?<br>
</font><font color="#007700">for (</font><font color="#0000bb">$radek</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; </font><font color="#0000bb">$radek</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">; </font><font color="#0000bb">$radek</font><font color="#007700">++):<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;for (</font><font color="#0000bb">$sloupec</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; </font><font color="#0000bb">$sloupec</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">; </font><font color="#0000bb">$sloupec</font><font color="#007700">++):<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$radek </font><font color="#007700">* </font><font color="#0000bb">$sloupec</font><font color="#007700">&gt;</font><font color="#0000bb">50</font><font color="#007700">) break; </font><font color="#ff8000">// to je ten
přidaný řádek<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">echo </font><font color="#dd0000">"&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$radek</font><font color="#007700">*</font><font color="#0000bb">$sloupec</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;endfor;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/TR&gt;"</font><font color="#007700">;<br>
endfor;<br>
</font><font color="#0000bb">?&gt;</font>&lt;/TABLE&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Příkaz break ukončí vypisování výsledků vždy, když by hrozilo, že
násobením dojdeme k číslu většímu než 50. Všimněte si, že příkaz break
ukončí pouze vnitřní smyčku, ale vnější smyčka pokračuje dalším krokem.
Kdybychom chtěli ukončit smyčky obě, použijeme příkaz break(2).</p>
<p>Příkaz <a href="http://cz.php.net/manual/en/control-structures.continue.php">continue</a>
naproti tomu nezpůsobí ukončení smyčky, jen přeskočí
zbytek těla smyčky a začne provádět další iteraci (tedy další průchod
smyčkou). Takže, kdybychom v našem
násobilkovém příkladu chtěli vytisknout jen čísla větší než 50, mohlo
by to vypadat třeba takto nějak:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE&gt;<font color="#0000bb">&lt;?<br>
</font><font color="#007700">for (</font><font color="#0000bb">$radek</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; </font><font color="#0000bb">$radek</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">; </font><font color="#0000bb">$radek</font><font color="#007700">++):<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;for (</font><font color="#0000bb">$sloupec</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; </font><font color="#0000bb">$sloupec</font><font color="#007700">&lt;=</font><font color="#0000bb">10</font><font color="#007700">; </font><font color="#0000bb">$sloupec</font><font color="#007700">++):<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$radek </font><font color="#007700">* </font><font color="#0000bb">$sloupec</font><font color="#007700">&lt;</font><font color="#0000bb">50</font><font color="#007700">) continue; </font><font color="#ff8000">// to je ten
přidaný řádek<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">echo </font><font color="#dd0000">"&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$radek</font><font color="#007700">*</font><font color="#0000bb">$sloupec</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;endfor;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/TR&gt;"</font><font color="#007700">;<br>
endfor;<br>
</font><font color="#0000bb">?&gt;</font>&lt;/TABLE&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>I příkaz continue má nepovinný parametr určující, kolik vnořených
cyklů for, do nebo while se má začít vykonávat od začátu. V praxi se s
tím ale moc nesetkáte.<br>
</p>
<a name="000059"></a><h2>Poznámky ke smyčkám</h2>
<ul>
  <li>Smyčky v programování potřeba budou, většinou je programátor musí
dobře znát.</li>
  <li>Jako parametr smyčky nemusí být použito celé číslo, krok může být
záporný
a v těle smyčky se parametr může měnit.</li>
  <li>Pro procházení polí se spíše hodí smyčke foreach, o které jsme
ještě nemluvili. Bude o ní řeč později.</li>
  <li>Smyčky s parametrem bývají "čitelnější" než smyčky s podmínkami.
Pokud je předem znám počet opakování, použijte spíše parametrické cykly.</li>
</ul>
<p>V dalším díle se podíváme na funkce a přespříště se pokusíme z toho,
co
už umíme, sestavit nějaký opravdu použitelný skript.</p>
<a name="000060"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (15) - Funkce</h2>
			<p class="perex">Funkce jsou v PHP nezbytným programovacím
prostředkem. Ukažme si, jak na ně.
				<br>
			</p>
			<p>Jako v každém programovacím jazyce, i v PHP mají nezastupitelnou
úlohu
funkce. Aby nedošlo k matení pojmů, uveďme hned, že většina jazyků
rozlišuje mez procedurami a funkcemi - a to tak, že zatímco procedura
vykonává nějakou činnost, funkce navíc vrací hodnotu. v PHP existuje
obojí, ale obojí se (možná trochu nešťastně) definuje klíčovým slovem
function. Podívejme se tedy nejprve na procedury.</p>
<p>Procedura je jednoduše řečeno kus kódu, který se může volat
samostatně.
Většinou se do procedury umisťují ty části kódu, které se v programu
opakují nebo se procedury používají pro větší přehlednost. Například,
jak nám ukázal <a target="_blank" href="http://www.linuxsoft.cz/article.php?id_article=185">Pavel Kácha
v seriálu o HTML</a>, stránka by měla mít hlavičku. Když budete psát
PHP skript vytvářející stránku, možná si budete chtít rutinu pro
vytvoření hlavičky uložit do samostatné procedury. Mohlo by to vypadat
třeba takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">hlavicka</font><font color="#007700">()<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD
HTML 4.01 Transitional//EN"; "http://www.w3.org/TR/html4/loose.dtd"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;html&gt;&lt;head&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta http-equiv="Content-Type"
content="text/html; charset=ISO-8859-2"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;Moje první stránka&lt;/title&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt;<br>
&nbsp;&nbsp;<font color="#0000bb">&lt;?<br>
</font><font color="#007700">}<br>
</font><font color="#ff8000">// použití<br>
</font><font color="#0000bb">hlavicka</font><font color="#007700">();<br>
echo </font><font color="#dd0000">"&lt;BODY&gt;Tělo
stránky&lt;/BODY&gt;&lt;/HTML&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Z toho vyplývá několik věcí: Předně si můžeme všimnout, že procedury
(a funkce) v PHP začínají klíčovým slovem function a názvem. Tělo
procedury je ohraničeno složenými závorkami podobně, jako složené
příkazy. Uvnitř procedury (nebo funkce)
může být prakticky jakýkoli myslitelný PHP kód. My jsme tam dokonce
vložili HTML.<br>
</p>
<a name="000061"></a><h2>Procedury versus funkce</h2>
<p>Funkce se od procedur liší jednou podstatnou věcí - vracejí hodnotu
a jsou tedy podle definice v PHP <span style="font-style: italic;">výrazem</span>.
Kdybychom například chtěli napsat triviální funkci vracející výsledek
výpočtu 2+2, napíšeme:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">dvaplusdva</font><font color="#007700">()<br>
{<br>
&nbsp;&nbsp;return </font><font color="#0000bb">2</font><font color="#007700">+</font><font color="#0000bb">2</font><font color="#007700">;<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Právě použitím klíčového slova <a href="http://cz.php.net/manual/en/function.return.php">return</a> se
funkce liší od procedur.
Výraz, který je uveden za return se vrátí jako výsledná hodnota a
provádění funkce tím končí. Cokoli, co je uvedeno jako příkaz za
klíčovým slovem <span style="font-style: italic;">return</span>
už se neprovede.<br>
</p>
<a name="000062"></a><h2>Parametry</h2>
<p>Uvedená procedura a uvedená funkce jsou pro nás pramálo užitečné.
Nedovolují nám totiž předávat vstupní parametry. Většina procedur a
funkcí ale obvykle parametry potřebuje. Například si pojďme sestavit
funkci vracející TRUE v případě, že předaný den (vstupní parametr) je
neděle. </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">JeNedele</font><font color="#007700">(</font><font color="#0000bb">$den</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;return (</font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"w"</font><font color="#007700">, </font><font color="#0000bb">strtotime</font><font color="#007700">(</font><font color="#0000bb">$den</font><font color="#007700">))==</font><font color="#0000bb">0</font><font color="#007700">);<br>
}<br>
if (</font><font color="#0000bb">JeNedele</font><font color="#007700">(</font><font color="#dd0000">"2004-06-20"</font><font color="#007700">)) echo </font><font color="#dd0000">"Je neděle"</font><font color="#007700">; else echo </font><font color="#dd0000">"Není neděle"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Krátké vysvětlení: Předávaný parametr je $den. Předává se řetězec, z
něhož se funkce strtotime pokusí vyluštit datum. To se předá vestavěné
PHP funkci
date, která s parametrem "w" vrací pořadové číslo dne v týdnu (0-6 je
neděle - sobota). Abychom to nekomplikovali, je uveden příklad s datem
ve formátu, který funkce bezpečně pozná.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Kromě funkcí, které si
napíšeme sami, má tedy PHP celou řadu funkcí již připravených.</span></p>
<p>Někdy bychom potřebovali funkci, které se parametry mohou a nemusejí
zadávat. Tak třeba v příkladu s nedělí by se nám mohlo hodit, aby
funkce buď vyhodnotila zadané datum, nebo dnešní datum v případě, že se
nic nezadá. Tím by se vlastně parametr $den stal nepovinný. V PHP to
lze zařídit. Upravený
příklad by fungoval takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">JeNedele</font><font color="#007700">(</font><font color="#0000bb">$den</font><font color="#007700">=</font><font color="#dd0000">"now"</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;return (</font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"w"</font><font color="#007700">, </font><font color="#0000bb">strtotime</font><font color="#007700">(</font><font color="#0000bb">$den</font><font color="#007700">))==</font><font color="#0000bb">0</font><font color="#007700">);<br>
}<br>
if (</font><font color="#0000bb">JeNedele</font><font color="#007700">())
echo </font><font color="#dd0000">"Je neděle"</font><font color="#007700">; else echo </font><font color="#dd0000">"Není neděle"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Ještě krátké vysvětlení - když se den nezadá, použije se řetězec
"now". Funkce strtime, která převádí řetězec na datum tomu rozumí a
dosadí dnešek.<br>
</p>
<a name="000063"></a><h2>Rozsah platnosti proměnných</h2>
<p>Za poměrně mrzutou vlastnost jazyka PHP lze považovat fakt, že
uvnitř, v těle funkce nemáme automaticky přístup ke globálním
proměnným. Například budeme chtít napsat funkci, která vrací buď
stručná nebo upovídaná hlášení podle toho, jak je nastavená proměnná
$VracetUpovidaneHlasky. Následující kód <span style="font-style: italic;">nebude </span>fungovat podle
očekávání, protože tělo funkce nemá ponětí o hodnotě globální proměnné
$VracetUpovidaneHlasky.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">Hlaska
</font><font color="#007700">()<br>
{<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$VracetUpovidaneHlasky</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Já jsem
velmi upovídaná hláška."</font><font color="#007700">;<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Hláška"</font><font color="#007700">;<br>
}<br>
</font><font color="#0000bb">$VracetUpovidaneHlasky </font><font color="#007700">= </font><font color="#0000bb">TRUE</font><font color="#007700">; </font><font color="#0000bb">Hlaska</font><font color="#007700">();<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Lze to řešit pomocí klíčového slova global, které nás v těle funkce
donutí použít globání proměnnou, ale je potřeba na to myslet. Vypadalo
by to asi takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">Hlaska
</font><font color="#007700">()<br>
{<br>
&nbsp;&nbsp;global </font><font color="#0000bb">$VracetUpovidaneHlasky</font><font color="#007700">;<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$VracetUpovidaneHlasky</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Já jsem
velmi upovídaná hláška."</font><font color="#007700">;<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Hláška"</font><font color="#007700">;<br>
}<br>
</font><font color="#0000bb">$VracetUpovidaneHlasky </font><font color="#007700">= </font><font color="#0000bb">TRUE</font><font color="#007700">; </font><font color="#0000bb">Hlaska</font><font color="#007700">();<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Další možnost (podle mého soudu ještě mnohem horší) by spočívala v
tom, že by se nutné údaje "zvnějšku" předávaly jako parametry funkce.</p>
<a name="000064"></a><h2>Poznámky k funkcím</h2>
<p>Protože cílem seriálu není psát referenční příručku, zmíníme se o
některých vlastnostech funkcí jen letmo:<br>
</p>
<ul>
  <li>Funkce může mít více vstupních parametrů. Ty se pak oddělují
čárkou.</li>
  <li>Funkce v PHP mohou předávat parametry odkazem. To se provede tak,
že před název proměnné v hlavičce funkce se uvede ampresand (&amp;)</li>
  <li>V těle funkce mohou být definovány proměnné s klíčovým slovem
static. Hodnotu takových proměnných si PHP mezi jednotlivými voláními
funkce pamatuje.</li>
  <li>Funkce v PHP mohou být rekurzivní. To znamená, že funkce může
volat sebe samu. Kromě učebnicového příkladu výpočtu faktoriálu se v
PHP používají rekurze na úlohy typu procházení adresářem.<br>
  </li>
  <li>Funkce nemůže vracet více než jeden výstupní parametr. Ale může
vracet pole, takže se to dá obejít.</li>
  <li>Jedna uživatelská funkce může volat jinou. Na pořadí, v jakém
jsou uvedeny ve skriptu, přitom nezáleží. Volání funkce může být
uvedeno dokonce již dříve než definice funkce samotné.<br>
  </li>
</ul>
<a name="000065"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (16) - Vyrobme si kalendář</h2>
			<p class="perex">Náš první "větší" program v PHP bude zobrazovat
na stránce kalendář. Vzhůru do boje!

				<br>
			</p>
			<p>Dost bylo teorie. Pokud jste sledovali úvodní díly našeho PHP
seriálu, pravděpodobně jste se těšili na nějaké příklady z praxe. Tady
jeden bude - cílem je sestavit PHP skript, který pro daný měsíc a rok
sestaví asi takhle vypadající kalendář:</p>
<!-- Zaza PHP sample BEGIN -->
<table style="border-collapse: collapse;" align="center" border="1" width="180">
  <tbody>
    <tr>
      <td colspan="6" align="center" width="180">červenec&nbsp;2004</td>
    </tr>
    <tr align="center">
      <td width="30">Po</td>
      <td width="30">&nbsp;</td>
      <td width="30">5</td>
      <td width="30">12</td>
      <td width="30">19</td>
      <td width="30">26</td>
    </tr>
    <tr align="center">
      <td width="30">Út</td>
      <td width="30">&nbsp;</td>
      <td width="30">6</td>
      <td width="30">13</td>
      <td width="30">20</td>
      <td width="30">27</td>
    </tr>
    <tr align="center">
      <td width="30">St</td>
      <td width="30">&nbsp;</td>
      <td width="30">7</td>
      <td width="30">14</td>
      <td width="30">21</td>
      <td width="30">28</td>
    </tr>
    <tr align="center">
      <td width="30">Čt</td>
      <td width="30">1</td>
      <td width="30">8</td>
      <td width="30">15</td>
      <td width="30">22</td>
      <td width="30">29</td>
    </tr>
    <tr align="center">
      <td width="30">Pá</td>
      <td width="30">2</td>
      <td width="30">9</td>
      <td width="30">16</td>
      <td width="30">23</td>
      <td width="30">30</td>
    </tr>
    <tr align="center">
      <td width="30">So</td>
      <td width="30">3</td>
      <td width="30">10</td>
      <td width="30">17</td>
      <td width="30">24</td>
      <td width="30">31</td>
    </tr>
    <tr align="center">
      <td width="30">Ne</td>
      <td width="30">4</td>
      <td width="30">11</td>
      <td width="30">18</td>
      <td width="30">25</td>
      <td width="30">&nbsp;</td>
    </tr>
  </tbody>
</table>
<!-- Zaza PHP sample END -->
<p>To může mít v reálu celou řadu solidních uplatnění, například na
domovské stránce naší komunitní WiFi sítě se používá podobná věc pro
zobrazní naplánováných akcí. Celkem dobrý zvyk je každý větší projekt
si nejdřív naplánovat; takže to pro účely našeho seriálu pojďme za
větší projekt považovat a...<br>
</p>
<a name="000066"></a><h2>Nejprve plánujme</h2>
<p>Takováhle aplikace přímo volá po použití tabulek, jak vám asi
zanedlouho vysvětlí <a href="http://www.linuxsoft.cz/user_page.php?user_id=697&amp;part=article">Pavel
Kácha</a> v <a href="http://www.linuxsoft.cz/article_list.php?id_kategory=172">seriálu
o HTML</a> (doplnění při korektuře - <a href="http://www.linuxsoft.cz/article.php?id_article=305">skutečně to
udělal</a>). Při psaní vlastního kódu ale přijdeme na
některé
špeky.
Například nebudeme spoléhat na to, že server umí zkratky českých dnů v
týdnu (i když by po správném nastavení jistě mohl) a rovněž nebudeme
spoléhat na to, že server umí české názvy měsíců v roce. Místo toho
vytvoříme pole, která budou tyto zkratky obsahovat. Další problém bude
spočívat v tom, jak zjistit počet dní v daném měsíci, a to zejména
vezmeme-li v úvahu přechodné roky. Jiný "vážný problém" bude
zjistit, kterým dnem daný měsíc začíná. A ještě dvě věci: jak víte
(nebo se dozvíte při studiu HTML) tabulky jsou v HTML sestavovány po
řádcích a to nám zde moc nevyhovuje. My bychom je spíše potřebovali
sestavovat po sloupcích. Taky nebude k zahození ještě před vytvořením
tabulky zjistit, kolik sloupců bude mít - samotné dny mohou zabírat 4,
5 nebo i 6 sloupců a další sloupec bude na jejich názvy.<br>
</p>
<p>Ještě malá poznámka k rozsáhlejším programům v tomto seriálu: Cílem
zde uvedených příkladů není vytvořit "nejkratší možný" nebo
"nejrychleji běžící" PHP kód. Cílem je spíše ukázat co možná nejvíc
věcí, které jsme se naučili. Takže s tímto pohledem přisupujte i k
následujícímu
příkladu.<br>
</p>
<a name="000067"></a><h2>Budou tam funkce</h2>
<p>Abychom splnili nepříjemnou povinnost nějak se vypořádat s
přechodnými roky a zároveň si ilustrovali jednu oblíbenou začátečnickou
chybu, zkusme nejprve sestavit funkci vracející TRUE v případě, že
zadaný rok je přechodný (to je každý rok dělitelný čtyřmi kromě (let
dělitelných stem ale ne let dělitelných 400)). Neboli, rok 1900
přechodný nebyl, ale rok 2000 ano. Možná budete chtít napsat něco
masochistického ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">JePrechodny</font><font color="#007700">(</font><font color="#0000bb">$rok</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return((</font><font color="#0000bb">$rok</font><font color="#007700">%</font><font color="#0000bb">4</font><font color="#007700">==</font><font color="#0000bb">0</font><font color="#007700">) &amp;&amp; (</font><font color="#0000bb">$rok</font><font color="#007700">%</font><font color="#0000bb">100</font><font color="#007700">&lt;&gt;</font><font color="#0000bb">0 </font><font color="#007700">|| </font><font color="#0000bb">$rok</font><font color="#007700">%</font><font color="#0000bb">400</font><font color="#007700">==</font><font color="#0000bb">0</font><font color="#007700">));<br>
&nbsp;&nbsp;&nbsp;}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Ačkoli by to fungovalo, obecně to není moc dobrý přístup k problému.
Takové konstrukce přímo volají po zapomenuté závorce nebo rovnítku.
Bystřejší se podívají do manuálu PHP a zajásají nad možnostmi funkce
date a napíší již elegantnější kód ve stylu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">JePrechodnyRok
</font><font color="#007700">(</font><font color="#0000bb">$rok</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;return (boolean) </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"L"</font><font color="#007700">, </font><font color="#0000bb">mktime</font><font color="#007700">(</font><font color="#0000bb">0</font><font color="#007700">,</font><font color="#0000bb">0</font><font color="#007700">,</font><font color="#0000bb">0</font><font color="#007700">,</font><font color="#0000bb">1</font><font color="#007700">,</font><font color="#0000bb">1</font><font color="#007700">,</font><font color="#0000bb">$rok</font><font color="#007700">));<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a ti nejbystřejší se asi zeptají PROČ vlastně potřebujeme zjistit
který rok je přechodný. Odpověď je - abychom věděli, jaký počet dnů má
jeho únor, kdyby se na něj zrovna dostalo. A na to je v PHP nádherná
funkce </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">PocetDnu
</font><font color="#007700">(</font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;return </font><font color="#0000bb">cal_days_in_month</font><font color="#007700">(</font><font color="#0000bb">CAL_GREGORIAN</font><font color="#007700">, </font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">);<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Doufám, že z toho dostatečně vyplývá především jedna věc - a to sice
že se vyplatí přemýšlet nad nejjednodušším řešením dříve, než to
uděláme zbytečně složitě. Manuál PHP obsahuje popis stovek funkcí -
nebudeme je všechny rozebírat. Při vlastních projektech nejprve
zkoumejte, co se dá použít.<br>
</p>
<p>Teď k tomu prvnímu dni v měsíci - tady už je situace jednodušší a
použijeme schopností funkcí <a href="http://cz.php.net/manual/en/function.date.php">date</a> a <a href="http://cz.php.net/manual/en/function.mktime.php">mktime</a>.
Mktime sestaví datum z
hodnot "hodina", "minuta", "vteřina", "měsíc", "den", "rok", z čehož
my sestavíme datum prvního dne daného měsíce. A funkce date toto datum
formátuje - jedna z voleb nám umožní vrátit pořadové číslo dne v týdnu.
Poslední záludnost je ta, že tento výraz vrací 1 pro pondělí a tak
dále, ale <span style="font-style: italic;">nulu </span>pro neděli.
Což nás, znalé <a href="#000046">ternálního
operátoru</a> vůbec
nemůže rozházet.
Takže výsledná funkce by mohla vypadat třeba takto:
<!-- Zaza PHP kód BEGIN --></p>
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">PrvniDen
</font><font color="#007700">(</font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">$anglickeporadi </font><font color="#007700">= </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"w"</font><font color="#007700">, </font><font color="#0000bb">mktime</font><font color="#007700">(</font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">1</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">));<br>
&nbsp;&nbsp;return (</font><font color="#0000bb">$anglickeporadi</font><font color="#007700">==</font><font color="#0000bb">0</font><font color="#007700">) ? </font><font color="#0000bb">7 </font><font color="#007700">: </font><font color="#0000bb">$anglickeporadi</font><font color="#007700">;<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Proč jsme použili proměnnou $anglickeporadi? Za prvé proto, že nám
to umožnilo čitelnější kód. A také proto, že funkci date teď nemusíme
volat dvakrát, což bychom bez použití proměnné při vyhodnocování
ternálního operátoru museli (a to by bylo pomalé).<br>
</p>
<a name="000068"></a><h2>Testování funkcí</h2>
<p>Je jasné, že napsat několik funkcí a čekat, že budou všechny hned
fungovat je většinou nereálné. Každou napsanou funkci bychom tedy měli
před jejím začleněním do projektu otestovat. V případě takto
jednoduchých funkcí bude pravděpodobně stačit napsat krátký skript,
který ji vyzkouší pomocí jednoho či dvou příkazů echo. Na to při
progamování pamatujte, protože pokud neodladíte více než jednu funkci a
v programu bude chyba, už nevíte, kde ji hledat. V případě
rozsáhlejších projektů se vyplatí instalovat debugger; o tom bude v
tomto tutoriálu ještě <a href="#000277">řeč později</a>.<br>
</p>
<p>V příštím článku naší série to celé domyslíme a sestavíme do
fungující podoby.</p>
<a name="000069"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (17) - Dokončujeme kalendář</h2>
			<p class="perex">V této části seriálu o PHP dokončíme kalendář, který
jsme začali psát v minulém dílu.
				<br>
			</p>
			<p>Připomeňme jen, že v minulém dílu jsme začali sestavovat kalendář,
který bude nakonec vypadat nějak takhle:</p>
<!-- Zaza PHP sample BEGIN -->
<table style="border-collapse: collapse;" align="center" border="1" width="180">
  <tbody>
    <tr>
      <td colspan="6" align="center" width="180">červenec&nbsp;2004</td>
    </tr>
    <tr align="center">
      <td width="30">Po</td>
      <td width="30">&nbsp;</td>
      <td width="30">5</td>
      <td width="30">12</td>
      <td width="30">19</td>
      <td width="30">26</td>
    </tr>
    <tr align="center">
      <td width="30">Út</td>
      <td width="30">&nbsp;</td>
      <td width="30">6</td>
      <td width="30">13</td>
      <td width="30">20</td>
      <td width="30">27</td>
    </tr>
    <tr align="center">
      <td width="30">St</td>
      <td width="30">&nbsp;</td>
      <td width="30">7</td>
      <td width="30">14</td>
      <td width="30">21</td>
      <td width="30">28</td>
    </tr>
    <tr align="center">
      <td width="30">Čt</td>
      <td width="30">1</td>
      <td width="30">8</td>
      <td width="30">15</td>
      <td width="30">22</td>
      <td width="30">29</td>
    </tr>
    <tr align="center">
      <td width="30">Pá</td>
      <td width="30">2</td>
      <td width="30">9</td>
      <td width="30">16</td>
      <td width="30">23</td>
      <td width="30">30</td>
    </tr>
    <tr align="center">
      <td width="30">So</td>
      <td width="30">3</td>
      <td width="30">10</td>
      <td width="30">17</td>
      <td width="30">24</td>
      <td width="30">31</td>
    </tr>
    <tr align="center">
      <td width="30">Ne</td>
      <td width="30">4</td>
      <td width="30">11</td>
      <td width="30">18</td>
      <td width="30">25</td>
      <td width="30">&nbsp;</td>
    </tr>
  </tbody>
</table>
<!-- Zaza PHP sample END -->
<p>Už jsme vyřešili jak zjistit počet dnů v měsíci a rovněž jak
stanovit, který den v týdnu připadne na prvního. Dnes nás čeká napsat
kód na zjištění počtu sloupců, kód na sestavení jednotlivých buněk a
musíme to celé nějak dostat dohromady.<br>
</p>
<a name="000070"></a><h2>Počet sloupců</h2>
<p>Je zřejmé, že jeden sloupec bude muset být vždy rezervován na názvy
dnů. Dále je zřejmé, že vlastní kalednář si může vyžádat čtyři (únor v
nepřechodném roce začínající pondělím), pět nebo i šest sloupců pro
svoje data. Počet sloupců musíme znát ještě dříve, než budeme tabulku
sestavovat.<br>
</p>
<p>Sám jsem při psaní kódu podlehl chybě popisované v minulém díle, a
sice té, že jsem se pokusil sestavit matematické pravidlo, z něhož by
počet sloupců vypadl. Jde to však jednodušeji - postačí nám donutit PHP
k tomu, aby nám řeklo, zda daný měsíc zabírá rozmezí čtyř, pěti nebo
šesti týdnů. Neboli, v kolikátém týdnu roku je prvního v měsíci a v
kolikátém týdnu je posledního. Protože už máme funkci PocetDnu, je
zjištění obojího záležitost jednoho řádku kódu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
$sloupcu </font><font color="#007700">= </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"W"</font><font color="#007700">, </font><font color="#0000bb">mktime</font><font color="#007700">(</font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$PocetDnu</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">)) - </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"W"</font><font color="#007700">, </font><font color="#0000bb">mktime</font><font color="#007700">(</font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">1</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">))+</font><font color="#0000bb">2</font><font color="#007700">; </font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Dva sloupce se přičítají proto, že jeden je na názvy dnů, kdežto
druhý je kvůli matematickému rozdílu mezi základními a řadovými
číslovkami (31. mínus 27. týden je 5 ne 4).<br>
</p>
<p>Korektura: To jsem tomu dal! Praxe ukázala, že to v některých
případech nebude fungovat. Například první leden roku 2000 má číslo
týdne 52, zatímco poslední prosinec roku 2007 spadá do týdne číslo 1
následujícího roku. Je to snad nějaká chyba? Ani ne. Kdybych si přečetl
manuál, zjistím, že PHP funkce <a href="http://cz.php.net/manual/en/function.date.php">date</a> se při
vracení pořadového čísla týdne v roce chová podle normy <a href="http://www.cl.cam.ac.uk/%7Emgk25/iso-time.html">ISO-8601</a>.
Tato norma specifikuje formáty data a mimo jiné stanoví způsob, jakým
se číslují týdny na přelomu měsíců prosince a ledna. jednoduše řečeno
je to tak, že pokud více než tři dny přelomového měsíce spadají do
ledna, je týden považován za první v novém roce, v opačném případě je
považován za poslední týden v roce minulém.<br>
</p>
<p>Dlouho jsem přemýšlel, jak to jednoduše ošetřit, aniž bych
zjišťování týdnů musel nějak dramaticky od základu přepsat. Výsledek
je, že zjišťuji a odečítám ne počet týdnů mezi prvním a posledním dnem
v měsíci, ale počet týdnů mezi osmým dnem od začátku a osmým dnem od
konce. Vynechané
dva týdny sice musím v závěru přičíst, ale zase se úplně vyhnu
problémům s prosinci a ledny některých let. Opravený a funkční způsob
zjištění počtu sloupců tedy je:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
$sloupcu </font><font color="#007700">= </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"W"</font><font color="#007700">, </font><font color="#0000bb">mktime</font><font color="#007700">(</font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$PocetDnu</font><font color="#007700">-</font><font color="#0000bb">7</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">)) - </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"W"</font><font color="#007700">, </font><font color="#0000bb">mktime</font><font color="#007700">(</font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">1</font><font color="#007700">+</font><font color="#0000bb">7</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">))+</font><font color="#0000bb">4</font><font color="#007700">; </font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Aneb: Člověk se stále učí.</p>
<a name="000071"></a><h2>Sestavení buňek</h2>
<p>Je zřejmé, že dobrý nápad by byl použít dvě vnořené smyčky a
sestavovat tabulku zleva doprava a odzhora dolů (ostatně jinak to ani
nejde). Naspišme si tedy funkci, které pošleme řádek, sloupec, který
den je prvního a kolik má měsíc dnů - a chtějme po ní jako výsledek
obsah buňky kalendáře! Mohlo by to vypadat nějak takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">Bunka
</font><font color="#007700">(</font><font color="#0000bb">$radek</font><font color="#007700">, </font><font color="#0000bb">$sloupec</font><font color="#007700">, </font><font color="#0000bb">$PrvniDen</font><font color="#007700">, </font><font color="#0000bb">$PocetDnu</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">$dny</font><font color="#007700">=Array(</font><font color="#0000bb">1</font><font color="#007700">=&gt;</font><font color="#dd0000">"Po"</font><font color="#007700">, </font><font color="#dd0000">"Út"</font><font color="#007700">, </font><font color="#dd0000">"St"</font><font color="#007700">, </font><font color="#dd0000">"Čt"</font><font color="#007700">, </font><font color="#dd0000">"Pá"</font><font color="#007700">, </font><font color="#dd0000">"So"</font><font color="#007700">, </font><font color="#dd0000">"Ne"</font><font color="#007700">);<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$sloupec</font><font color="#007700">==</font><font color="#0000bb">1</font><font color="#007700">) return </font><font color="#0000bb">$dny</font><font color="#007700">[</font><font color="#0000bb">$radek</font><font color="#007700">];<br>
&nbsp;&nbsp;</font><font color="#0000bb">$chcivratit </font><font color="#007700">= (</font><font color="#0000bb">$sloupec</font><font color="#007700">-</font><font color="#0000bb">2</font><font color="#007700">)*</font><font color="#0000bb">7 </font><font color="#007700">+ </font><font color="#0000bb">$radek </font><font color="#007700">- </font><font color="#0000bb">$PrvniDen</font><font color="#007700">+</font><font color="#0000bb">1</font><font color="#007700">;<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$chcivratit</font><font color="#007700">&lt;</font><font color="#0000bb">1 </font><font color="#007700">|| </font><font color="#0000bb">$chcivratit</font><font color="#007700">&gt;</font><font color="#0000bb">$PocetDnu</font><font color="#007700">) return </font><font color="#dd0000">"&amp;nbsp;"</font><font color="#007700">; else return </font><font color="#0000bb">$chcivratit</font><font color="#007700">;<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>První dva řádky jsou myslím jasné; jestliže je v proměnné $sloupec
jednička, nemůže to dopadnout jinak než že vrátíme zkratku dne. Ve
třetím řádku zjišťujeme pomocí matematiky, jaké číslo v dané buňce
pravděpodobně bude. Pravděpodobně proto, že to není jisté. Neexistují
totiž záproné dny a nemůžeme zobrazit víc dnů, než kolik jich daný
měsíc opravdu má. Což se testuje na řádku čtvrtém. Pokud jsme "v
rozsahu", vrátí funkce dané číslo, pokud ne, vrátí HTML kód
neoddělitelné mezery. To proto, abychom se vyhnuli problémům při
zobrazování prázdných buněk v tabulkách. <br>
</p>
<a name="000072"></a><h2>Výsledek</h2>
<p>Výsledkem našeho snažení bude funkce, která převezme dvě proměnné
(měsíc, rok), sestaví kalendář a pošle jej do prohlížeče. Bude to
vypadat takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">Kalendar
</font><font color="#007700">(</font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">$mesice</font><font color="#007700">=Array(</font><font color="#0000bb">1</font><font color="#007700">=&gt;</font><font color="#dd0000">"leden"</font><font color="#007700">, </font><font color="#dd0000">"únor"</font><font color="#007700">, </font><font color="#dd0000">"březen"</font><font color="#007700">, </font><font color="#dd0000">"duben"</font><font color="#007700">, </font><font color="#dd0000">"květen"</font><font color="#007700">, </font><font color="#dd0000">"červen"</font><font color="#007700">, </font><font color="#dd0000">"červenec"</font><font color="#007700">, </font><font color="#dd0000">"srpen"</font><font color="#007700">, </font><font color="#dd0000">"září"</font><font color="#007700">, </font><font color="#dd0000">"říjen"</font><font color="#007700">, </font><font color="#dd0000">"listopad"</font><font color="#007700">, </font><font color="#dd0000">"prosinec"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#ff8000">//kontroly<br>
&nbsp;&nbsp;</font><font color="#007700">if (!</font><font color="#0000bb">is_numeric</font><font color="#007700">(</font><font color="#0000bb">$mesic</font><font color="#007700">)) return </font><font color="#dd0000">"Měsíc musí být číslo!"</font><font color="#007700">;<br>
&nbsp;&nbsp;if (!</font><font color="#0000bb">is_numeric</font><font color="#007700">(</font><font color="#0000bb">$rok</font><font color="#007700">)) return </font><font color="#dd0000">"Rok musí být
číslo!"</font><font color="#007700">;<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$mesic</font><font color="#007700">&lt;</font><font color="#0000bb">1 </font><font color="#007700">|| </font><font color="#0000bb">$mesic</font><font color="#007700">&gt;</font><font color="#0000bb">12</font><font color="#007700">) return </font><font color="#dd0000">"Měsíc musí být
číslo od 1 do 12"</font><font color="#007700">;<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$rok</font><font color="#007700">&lt;</font><font color="#0000bb">1980 </font><font color="#007700">|| </font><font color="#0000bb">$rok</font><font color="#007700">&gt;</font><font color="#0000bb">2050</font><font color="#007700">) return </font><font color="#dd0000">"Rok musí být
číslo od 1980 do 2050"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zjištění počtu sloupců<br>
&nbsp;&nbsp;</font><font color="#0000bb">$PocetDnu </font><font color="#007700">= </font><font color="#0000bb">PocetDnu </font><font color="#007700">(</font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">); </font><font color="#0000bb">$PrvniDen </font><font color="#007700">= </font><font color="#0000bb">PrvniDen</font><font color="#007700">(</font><font color="#0000bb">$mesic</font><font color="#007700">,</font><font color="#0000bb">$rok</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$sloupcu </font><font color="#007700">= </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"W"</font><font color="#007700">, </font><font color="#0000bb">mktime</font><font color="#007700">(</font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$PocetDnu</font><font color="#007700">-</font><font color="#0000bb">7</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">)) - </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"W"</font><font color="#007700">, </font><font color="#0000bb">mktime</font><font color="#007700">(</font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">1</font><font color="#007700">+</font><font color="#0000bb">7</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">))+</font><font color="#0000bb">4</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#ff8000">// vlastní kód<br>
&nbsp;&nbsp;</font><font color="#007700">echo </font><font color="#dd0000">"&lt;TABLE border=\"1\" style=\"border-collapse:
collapse\" width=\""</font><font color="#007700">,</font><font color="#0000bb">$sloupcu</font><font color="#007700">*</font><font color="#0000bb">30</font><font color="#007700">,</font><font color="#dd0000">"\"&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TR&gt;&lt;TD
colspan=$sloupcu width=</font><font color="#007700">\"</font><font color="#dd0000">"</font><font color="#007700">,</font><font color="#0000bb">$sloupcu</font><font color="#007700">*</font><font color="#0000bb">30</font><font color="#007700">,</font><font color="#dd0000">"\" align=\"center\"&gt;"</font><font color="#007700">.</font><font color="#0000bb">$mesice</font><font color="#007700">[</font><font color="#0000bb">$mesic</font><font color="#007700">].</font><font color="#dd0000">"&amp;nbsp;"</font><font color="#007700">.</font><font color="#0000bb">$rok</font><font color="#007700">.</font><font color="#dd0000">"&lt;/TD&gt;&lt;/TR&gt;\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;for (</font><font color="#0000bb">$radek</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">;</font><font color="#0000bb">$radek</font><font color="#007700">&lt;=</font><font color="#0000bb">7</font><font color="#007700">;</font><font color="#0000bb">$radek</font><font color="#007700">++)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TR
align=\"center\"&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;for (</font><font color="#0000bb">$sloupec</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; </font><font color="#0000bb">$sloupec</font><font color="#007700">&lt;=</font><font color="#0000bb">$sloupcu</font><font color="#007700">; </font><font color="#0000bb">$sloupec</font><font color="#007700">++) echo </font><font color="#dd0000">"&lt;TD
width=\"30\"&gt;"</font><font color="#007700">.</font><font color="#0000bb">Bunka</font><font color="#007700">(</font><font color="#0000bb">$radek</font><font color="#007700">, </font><font color="#0000bb">$sloupec</font><font color="#007700">, </font><font color="#0000bb">$PrvniDen</font><font color="#007700">, </font><font color="#0000bb">$PocetDnu</font><font color="#007700">).</font><font color="#dd0000">"&lt;/TD&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/TR&gt;\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/TABLE&gt;"</font><font color="#007700">;<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/17_kalendar.html" target="_blank">Ukázat
skript</a></p>
<p>Při psaní reálného kódu je potřeba příliš nespoléhat na to, že
vstupní parametry budou v pořádku, a proto je hned v úvodu funkce
ověřujeme. Je zřejmé, že pokus o zobrazení například kalendáře za
třináctý měsíc by skončil chybou, takže to víceméně musíme udělat. Co
se týče vlastního kódu, začíná tím, že vypíše záhlaví tabulky. Protože
už v té době víme, kolik bude sloupců, můžeme si troufnout i na tabulku
s pevně danou šířkou (je to mimo jiné hezčí). Pak se píše záhlaví
(například "červenec 2004") a nakonec se ve dvou vnořených smyčkách
tvoří jednotlivé buňky; jejich hodnoty jsou zjišťovány opakovaným
voláním funkce Bunka().<br>
</p>
<p>Pokud Vám nejsou jasné některé souvislosti, podívejte se v
prohlížeči na zdrojový kód stránky, která kalendář zobrazuje. Věci,
které patří spíše do znalostí HTML než k PHP (jako je třeba použití
stylu) tady vysvětlovat nebudeme. Jedna věc by Vám ale přesto mohla
vrtat hlavou, a to je způsob použití proměnné $sloupcu jako hodnoty
atributu colspan ve druhém příkazu echo. Pokud to tak je, pak vězte, že
se jedná o tzv. automatickou expanzi proměnné.<br>
</p>
<a name="000073"></a><h2>Automatická expanze proměnné</h2>
<p>Za tímto strašným názvem se skrývá mechanismus, který nám při psaní
kódu v PHP ušetří něco málo času při práci s řetězci. Nejlépe to
vysvětlíme na příkladu. Následující kód provede dvakrát totéž:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$uzivatel</font><font color="#007700">=</font><font color="#dd0000">"Petr"</font><font color="#007700">;<br>
</font><font color="#0000bb">$server</font><font color="#007700">=</font><font color="#dd0000">"Linuxsoft"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Uživatel "</font><font color="#007700">.</font><font color="#0000bb">$uzivatel</font><font color="#007700">.</font><font color="#dd0000">" je vítán na serveru "</font><font color="#007700">.</font><font color="#0000bb">$server</font><font color="#007700">.</font><font color="#dd0000">"!&lt;BR&gt;"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Uživatel $uzivatel je vítán na
serveru $server!&lt;BR&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Neboli, pokud píšete řetězec v uvozovkách, můžete v něm použít
proměnnou a ona se automaticky expanduje. Není to nic převratného, ale
může to ušetřit nějaký čas při psaní kódu.</p>
<p>V dalším díle našeho seriálu se podíváme na fukce, které jsme zatím
přeskočili - jsou to funkce pro práci s poli.</p>
<a name="000074"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (18) - Funkce pro práci s poli</h2>
			<p class="perex">Dnes se podíváme na ty funkce v PHP, které Vám
značně usnadní práci s poli.
				<br>
			</p>
			<p>O polích jsme již mluvili v sedmém dílu našeho seriálu. Podívejme se
dnes na některé funkce, které pro práci s poli téměř určitě využijeme.
Zejména to budou věci týkající se práce s polem jako celkem.</p>
<p>Především, jak již bylo naťuknuto, obsah pole se dá přehledně <span style="font-weight: bold;">vypsat </span>do prohlížeče, což
oceníte
zejména při ladění skriptů obsahujících nějaké to pole. Pokud budeme
mít následující pole,
můžeme jej vypsat pomocí funkce <a href="http://cz.php.net/manual/en/function.print-r.php">print_r</a>
(ta funguje i s vícerozměrnými
poli):</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$os</font><font color="#007700">=Array(</font><font color="#dd0000">"Linux"</font><font color="#007700">, </font><font color="#dd0000">"Windows"</font><font color="#007700">, </font><font color="#dd0000">"Solaris"</font><font color="#007700">, </font><font color="#dd0000">"FreeBSD"</font><font color="#007700">);<br>
</font><font color="#0000bb">print_r</font><font color="#007700">(</font><font color="#0000bb">$os</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->

<p>Další užitečnou kejklí je <span style="font-weight: bold;">seřazení
</span>pole. K tomu můžeme použít funkci
<a href="http://cz.php.net/manual/en/function.sort.php">sort</a>,
takhle nějak:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$os</font><font color="#007700">=Array(</font><font color="#dd0000">"Linux"</font><font color="#007700">, </font><font color="#dd0000">"Windows"</font><font color="#007700">, </font><font color="#dd0000">"Solaris"</font><font color="#007700">, </font><font color="#dd0000">"FreeBSD"</font><font color="#007700">);<br>
</font><font color="#0000bb">sort</font><font color="#007700">(</font><font color="#0000bb">$os</font><font color="#007700">);<br>
</font><font color="#0000bb">print_r</font><font color="#007700">(</font><font color="#0000bb">$os</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Smysl této funkce pro našince poněkud kazí fakt, že nebude řadit
česky, přesto může být využitelná. PHP má k dispozici ještě sadu funkcí
které řadí pole sestupně, bez ohledu na velikost písmen anebo podle
klíčů v asociativních polích. Pro puntičkáře existuje dokonce způsob
umožňující řazení podle uživatelem definované porovnávací funkce. Jak
ale uvidíme v části o
databázích, většinou PHP dostane data již seřazená, takže potřeba
silných národních třídících algoritmů pro tento jazyk není zas až tak
palčivá.<br>
</p>
<a name="000075"></a><h2>Kdo jsi, pole?</h2>
<p>O něco šikovnější jsou prvky jazyka PHP které umožňují pole
procházet, aniž bychom předem věděli, jak je veliké. K tomu slouží
třeba konstrukce <a href="http://cz.php.net/manual/en/control-structures.foreach.php">foreach</a>();
v následujícím příkladu si naše vekolepé
pole vypíšeme do prohlížeče po řádcích:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$os</font><font color="#007700">=Array(</font><font color="#dd0000">"Linux"</font><font color="#007700">, </font><font color="#dd0000">"Windows"</font><font color="#007700">, </font><font color="#dd0000">"Solaris"</font><font color="#007700">, </font><font color="#dd0000">"FreeBSD"</font><font color="#007700">);<br>
foreach (</font><font color="#0000bb">$os </font><font color="#007700">as
</font><font color="#0000bb">$my_os</font><font color="#007700">) {<br>
&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Systém:
$my_os&lt;br&gt;</font><font color="#007700">\n</font><font color="#dd0000">"</font><font color="#007700">;<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jelikož se tato funkce sama postará o to, aby prošla celým polem od
začátku do konce, bývá hojně používaná.<br>
</p>
<a name="000076"></a><h2>Cesta tam a zase zpátky</h2>
<p>Šikovné příkazy existují pro rozdělení řetězce na pole menších
řetězců pomocí nějakého "oddělovacího" řetězce (třeba mezery). Toho
můžeme využít například pro rychlou definici pole, aniž bychom museli
použít příkaz Array. Slouží k tomu příkaz <a href="http://cz.php.net/manual/en/function.explode.php">explode</a>.
Následující příklad
tak známou okřídlenou větu rozdělí
na pole po jednotlivých slovech a vypíše pod sebe:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$pravda</font><font color="#007700">=</font><font color="#dd0000">"Software
is like sex... it's better when it's free"</font><font color="#007700">;<br>
</font><font color="#0000bb">$pole</font><font color="#007700">=</font><font color="#0000bb">explode</font><font color="#007700">(</font><font color="#dd0000">" "</font><font color="#007700">, </font><font color="#0000bb">$pravda</font><font color="#007700">);<br>
foreach (</font><font color="#0000bb">$pole </font><font color="#007700">as </font><font color="#0000bb">$cast</font><font color="#007700">) {<br>
&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"$cast&lt;br&gt;</font><font color="#007700">\n</font><font color="#dd0000">"</font><font color="#007700">;<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Opakem příkazu explode je příkaz <a href="http://cz.php.net/manual/en/function.implode.php">implode</a>,
který vytvoří jeden
řetězec z pole a separátoru.<br>
</p>
<a name="000077"></a><h2>Příklad k polím</h2>
<p>Na práci s poli je poměrně obtížné vymyslet nějaký neotřepaný
příklad, jeden mě ale napadl. Pomocí funkcí pro práci s poli popsaných
výše můžeme napsat třeba jednoduchý program, který nám bude cenzurovat
zadaný text. Když se v něm objeví nějaké nevhodné slovo, bude nahrazeno
oznámením o cenzuře. Využít se to dá třeba jako součást programu pro
chat. Celé to zpracujeme jako funkci, která obdrží necenzurovaný text
jako vstupní parametr a cenzurovaný text vrátí jako parametr výstupní.
Toto zadání má mnoho dobrých řešení, jedno z nich je například
následující:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
define </font><font color="#007700">(</font><font color="#dd0000">"CENZUROVANO"</font><font color="#007700">, </font><font color="#dd0000">"[ !!! Censored !!!]"</font><font color="#007700">);<br>
<br>
function </font><font color="#0000bb">cenzuruj</font><font color="#007700">(</font><font color="#0000bb">$text</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">$SpatnaSlova </font><font color="#007700">= Array(</font><font color="#dd0000">"Windows"</font><font color="#007700">, </font><font color="#dd0000">"Microsoft"</font><font color="#007700">, </font><font color="#dd0000">"databáze"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$RozdelText </font><font color="#007700">= </font><font color="#0000bb">explode</font><font color="#007700">(</font><font color="#dd0000">" "</font><font color="#007700">, </font><font color="#0000bb">$text</font><font color="#007700">);<br>
&nbsp;&nbsp;foreach (</font><font color="#0000bb">$RozdelText </font><font color="#007700">as </font><font color="#0000bb">$TestovaneSlovo</font><font color="#007700">) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;foreach (</font><font color="#0000bb">$SpatnaSlova
</font><font color="#007700">as </font><font color="#0000bb">$SpatneSlovo</font><font color="#007700">) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$TestovaneSlovo</font><font color="#007700">==</font><font color="#0000bb">$SpatneSlovo</font><font color="#007700">) </font><font color="#0000bb">$TestovaneSlovo</font><font color="#007700">=</font><font color="#0000bb">CENZUROVANO</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$PoCenzure</font><font color="#007700">=</font><font color="#0000bb">$PoCenzure</font><font color="#007700">.</font><font color="#dd0000">" "</font><font color="#007700">.</font><font color="#0000bb">$TestovaneSlovo</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;return </font><font color="#0000bb">$PoCenzure</font><font color="#007700">;<br>
}<br>
echo </font><font color="#0000bb">cenzuruj</font><font color="#007700">(</font><font color="#dd0000">"Nejlepší softwarová firma na světě je Microsoft"</font><font color="#007700">);<br>
echo </font><font color="#0000bb">cenzuruj</font><font color="#007700">(</font><font color="#dd0000">" Její operační systém Windows je ukázkou výkonu,
stability a bezpečnosti."</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->

<p>Řešení spočívá v tom, že jsme nejprve rozdělili cenzurovanou větu na
slova, která se pak procházela pomocí smyčky foreach. V ní je další,
vnořená smyčka, která porovnává získané slovo se slovy, která se ve
výstupu nesmějí objevit. Proměnná $PoCenzure pak obsahuje výsledný
"bezpečný" text. Skript je spíše náčrtem než hotovým řešením, protože
nedomýšlí některé situace (třeba kdyby za slovem Microsoft v prvním
příkazu echo byla tečka, tak jej nezcenzuruje), ale jako ukázka využití
polí jistě postačí. Všimněte si rovněž, že globální konstanty se
narozdíl od globálních proměnných v těle funkce použít dají.<br>
</p>
<p>Pro práci s poli existuje ještě několik desítek příkazů a funkcí.
Jsou uvedeny v manuálu k PHP. Pro běžnou práci s poli by Vám však
většinou měly stačit ty, které jsme uvedli. V dalším díle se podíváme
na tolik diskutované objekty a na prvky jazyka PHP, které s objekty umí
pracovat.</p>
<a name="000078"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (19) - Objekty</h2>
			<p class="perex">PHP umí pracovat s objekty. Podívejme se jak.
				<br>
			</p>
			<p>PHP umí pracovat s objekty. Podívejme se jak.
</p>
<p>Původně jsem si pohrával s myšlenkou objektově orientované
programování do tohoto seriálu vůbec nezařadit. Nakonec mi to nedalo,
takže následující řádky budou pokus shrnout <span style="font-style: italic;">základy</span> OOP (což je zkratka pro
objektově orientované programování) a převést příklad s kalednářem,
který jsme již dříve v tomto seriálu použili do "objektové" podoby.
Pokud jste pomocí objektů
nikdy neprogramovali, nemyslím si, že PHP je tou nejlepší volbou do
začátku, ale jeho znalost Vás určitě obohatí.<br>
</p>
<p>Myšlenka objektového programování je prostá. Zatímco procedurální
programování používá při vykonávání výpočetních úloh proměnné a funkce,
objektové programování používá zvláštní struktury nazvané objekty.
Objekt obsahuje jak data (například proměnné) tak i popis způsobů, jak
s nimi manipulovat (členské metody). Díky tomu může obecně řečeno
objektové programování řešit některé věci pružněji než procedurální.<br>
</p>
<p>Hlavní výhodou objektů je fakt, že umožňují popisovat věci tak, jak
fungují v běžném životě. Například mobilní telefon má určité vlastnosti
(barvu, typ, výdrž baterie apod.), ale rovněž určité věci umí (tak
třeba bychom ho mohli popsat metodami VytocCislo, PrijmiHovor,
ZobrazSeznam a podobně). V objektově orientovaných jazycích hovoříme o
tom, že objekty mají stav ("co to je") a chování ("co to umí").<br>
</p>
<p>Objekty se v OOP musejí nejprve nadefinovat. K definici objektu
slouží takzvané třídy. Třída je něco jako šablona nebo prototyp, na
jehož základě se budou objekty tvořit; v PHP se třída definuje pomocí
klíčového slova class. Protože jsem slíbil, že upravím příklad z
kalednářem z našeho seriálu, vytvoříme třídu, která se bude
jmenovat kalendar:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">class </font><font color="#0000bb">kalendar<br>
</font><font color="#007700">{<br>
&nbsp;&nbsp;</font><font color="#ff8000">//zatím toho moc neumím, ale
až vyrostu, budu třída...<br>
</font><font color="#007700">}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Třída by měla definovat nějaké atributy. V našem případě budeme
zobrazovat kalendář pro nějaký měsíc a rok, a to jsou ty atributy,
které hledáme. V PHP se zapisují pomocí klíčového slova var.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">class </font><font color="#0000bb">kalendar<br>
</font><font color="#007700">{<br>
&nbsp;&nbsp;var </font><font color="#0000bb">$mesic</font><font color="#007700">;<br>
&nbsp;&nbsp;var </font><font color="#0000bb">$rok</font><font color="#007700">;<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Většina tříd definuje také chování objektu. My použijeme metodu
vypis(), která nám celý kalendář vypíše do prohlížeče. Podstatná část
kódu je stejná jako v původním příkladu s funkcemi,
takže uvedu hned celý kód:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">class </font><font color="#0000bb">kalendar<br>
&nbsp;&nbsp;</font><font color="#007700">{<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$mesic</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$rok</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000bb">PocetDnu
</font><font color="#007700">()<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">cal_days_in_month</font><font color="#007700">(</font><font color="#0000bb">CAL_GREGORIAN</font><font color="#007700">, </font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">mesic</font><font color="#007700">, </font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">rok</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">// zkráceno. Celý
skript zobrazíte pomocí odkazu níže.<br>
&nbsp;&nbsp;</font><font color="#007700">}<br>
</font><font color="#0000bb">$prvni_kalendar</font><font color="#007700">=
new </font><font color="#0000bb">kalendar</font><font color="#007700">;<br>
</font><font color="#0000bb">$prvni_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">mesic</font><font color="#007700">=</font><font color="#0000bb">7</font><font color="#007700">;<br>
</font><font color="#0000bb">$prvni_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">rok</font><font color="#007700">=</font><font color="#0000bb">2004</font><font color="#007700">;<br>
</font><font color="#0000bb">$prvni_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">vypis</font><font color="#007700">();<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/19_1.html" target="_blank">Ukázat
skript</a></p>
<p>Z ukázky můžeme vidět několik věcí. Tak třeba to, že uvnitř těla
třídy se metody definují úplně stejně jako funkce, které už známe.
Jestliže se chceme odkázat na členskou proměnnou (třeba na $mesic),
pokužívá se klíčové slovo $this. Nejzajímavější jsou ale poslední čtyři
řádky ukázky, které předvádějí ne <span style="font-weight: bold;">tvorbu
</span>třídy (už je hotová), ale <span style="font-weight: bold;">práci
</span>s ní. Pomocí klíčového slova new jsme vytvořili <span style="font-weight: bold;">instanci neboli objekt</span> třídy
kalendar. Našemu konkrétnímu objektu jsme přiřadili <span style="font-weight: bold;">atributy </span>(měsíc a
rok) a následně jsme použili jeho <span style="font-weight: bold;">metodu
</span>vypis(), která způsobila
vypsání kalendáře. Ještě poznámka: jelikož metody nevracejí hodnotu,
upravili jsme v testu platnosti proměnných kontroly tak, že místo
return používají echo.<br>
</p>
<p>Samozřejmě, že bychom mohli vytvořit více instancí třídy kalendar a
každá by mohla mít jiné atributy. Tak třeba, následující kód by
zobrazil celé čtvrtletí:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">// (Zkráceno)<br>
</font><font color="#0000bb">$prvni_kalendar</font><font color="#007700">=
new </font><font color="#0000bb">kalendar</font><font color="#007700">;<br>
</font><font color="#0000bb">$prvni_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">mesic</font><font color="#007700">=</font><font color="#0000bb">7</font><font color="#007700">;<br>
</font><font color="#0000bb">$prvni_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">rok</font><font color="#007700">=</font><font color="#0000bb">2004</font><font color="#007700">;<br>
</font><font color="#0000bb">$prvni_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">vypis</font><font color="#007700">();<br>
<br>
</font><font color="#0000bb">$druhy_kalendar</font><font color="#007700">=
new </font><font color="#0000bb">kalendar</font><font color="#007700">;<br>
</font><font color="#0000bb">$druhy_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">mesic</font><font color="#007700">=</font><font color="#0000bb">8</font><font color="#007700">;<br>
</font><font color="#0000bb">$druhy_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">rok</font><font color="#007700">=</font><font color="#0000bb">2004</font><font color="#007700">;<br>
</font><font color="#0000bb">$druhy_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">vypis</font><font color="#007700">();<br>
<br>
</font><font color="#0000bb">$treti_kalendar</font><font color="#007700">=
new </font><font color="#0000bb">kalendar</font><font color="#007700">;<br>
</font><font color="#0000bb">$treti_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">mesic</font><font color="#007700">=</font><font color="#0000bb">9</font><font color="#007700">;<br>
</font><font color="#0000bb">$treti_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">rok</font><font color="#007700">=</font><font color="#0000bb">2004</font><font color="#007700">;<br>
</font><font color="#0000bb">$treti_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">vypis</font><font color="#007700">();<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/19_2.html" target="_blank">Ukázat
skript</a></p>
<a name="000079"></a><h2>Konstruktor</h2>
<p>Třída nemusí, ale může definovat metodu, která se jmenuje stejně
jako třída samotná a nazývá se konstruktor. Konstruktor se spustí
automaticky při vytvoření instance a my jej použijeme pro definici
požadovaného měsíce a roku. Jak uvidíme, povede to k tomu, že si
později při volání objektu ušetříme psaní. Přepsaný příklad
tedy bude:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">class </font><font color="#0000bb">kalendar<br>
&nbsp;&nbsp;</font><font color="#007700">{<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$mesic</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$rok</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000bb">kalendar
</font><font color="#007700">(</font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">mesic</font><font color="#007700">=</font><font color="#0000bb">$mesic</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">rok</font><font color="#007700">=</font><font color="#0000bb">$rok</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#ff8000">//
atd....&nbsp;&nbsp;&nbsp;&nbsp;<br>
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$prvni_kalendar</font><font color="#007700">= new </font><font color="#0000bb">kalendar</font><font color="#007700">(</font><font color="#0000bb">7</font><font color="#007700">,</font><font color="#0000bb">2004</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$prvni_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">vypis</font><font color="#007700">();<br>
<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/19_3.html" target="_blank">Ukázat
skript</a></p>
<p>Neboli, konstruktory nejčastěji slouží k usnadnění úkonů, které jsou
spojeny s inicializací objektů. Objekt byste samozřejmě i nadále mohli
inicializovat pomocí toho prvního způsobu, je to pouze na
programátorovi. Většina objektově orientovaných jazyků používá ještě
tzv. destruktory, což jsou metody volané při ničení objektu. PHP nic
takového nemá, především proto, že objekty v PHP "žijí" pouze od svého
vytvoření do doby, než stránka dorazí do prohlížeče.<br>
</p>
<p>V dalším díle si ukážeme něco o dědičnosti objektů a probereme
některé důvody, proč se někteří rozhodli objekty v PHP <span style="font-style: italic;">nepoužívat</span>.</p>
<a name="000080"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (20) - Objekty podruhé</h2>
			<p class="perex">Objekty v PHP umožňují používat dědičnost. Podívejme se jak a
ukažme si na některá úskalí, která s sebou používání objektů v PHP nese.
				<br>
			</p>
			<p>V minulém díle našeho seriálu jsme vytvořili objektový kalendář. A
slíbili jsme si, že dnes bude řeč o dědičnosti a nebezpečí spojených s
objekty v PHP. Podívejme se tedy na tyto dva aspekty objektově
orientovaného programování v PHP:<br>
</p>
<a name="000081"></a><h2>Dědičnost</h2>
<p>PHP, ostatně jako každý jiný objektově orientovaný jazyk umožňuje
rozšiřovat objekty pomocí mechanizmu dědičnosti. V reálném světě dědí
děti po
rodičích a prarodičích některé vlastnosti, zatímco jinými vlastnostmi
se liší. Kdybychom použili příklad s mobilními telefony, tak můžeme
sestavit následující analogii: Objekt NOKIA 6210 bude potomkem třídy
telefonů s tím, že bude (stejně jako každý jiný telefon) umět vytočit
číslo, přijmout hovor a podobně. Narozdíl od "obecného" telefonu bude
"šedesátdvadesítka" ovšem mít některé vlastnosti a metody, které jsou
pro ni specifické. Tak třeba narozdíl od telefonu na pevné lince může
specifikovat vlastnosti NabijBaterii, PřenesVizitkuPoInfraportu a tak
dále.<br>
</p>
<p>V PHP může jedna třída dědit vlastnosti a metody jiné, rodičovské
třídy s
tím, že některé věci bude dělat jinak a některé bude možná umět navíc.
Například bychom chtěli, aby náš skvělý kalendář uměl nejenom dny v
měsíci zobrazit, ale aby rovněž uměl některé z nich zvýrazit. To může
být užitečné třeba v případě, kdy má kalendář informovat o dnech, v
nichž se něco děje. Mělo by to vypadat nějak takhle:</p>
<table style="border-collapse: collapse;" align="center" border="1" width="180">
  <tbody>
    <tr align="center">
      <td colspan="6" width="180">červenec&nbsp;</td>
    </tr>
    <tr align="center">
      <td width="30">Po</td>
      <td width="30">&nbsp;</td>
      <td width="30">5</td>
      <td width="30">12</td>
      <td width="30">19</td>
      <td width="30"><b><big>26</big></b></td>
    </tr>
    <tr align="center">
      <td width="30">Út</td>
      <td width="30">&nbsp;</td>
      <td width="30">6</td>
      <td width="30"><b><big>13</big></b></td>
      <td width="30">20</td>
      <td width="30">27</td>
    </tr>
    <tr align="center">
      <td width="30">St</td>
      <td width="30">&nbsp;</td>
      <td width="30"><b><big>7</big></b></td>
      <td width="30">14</td>
      <td width="30">21</td>
      <td width="30">28</td>
    </tr>
    <tr align="center">
      <td width="30">Čt</td>
      <td width="30"><b><big>1</big></b></td>
      <td width="30"><b><big>8</big></b></td>
      <td width="30">15</td>
      <td width="30">22</td>
      <td width="30">29</td>
    </tr>
    <tr align="center">
      <td width="30">Pá</td>
      <td width="30">2</td>
      <td width="30">9</td>
      <td width="30">16</td>
      <td width="30">23</td>
      <td width="30">30</td>
    </tr>
    <tr align="center">
      <td width="30">So</td>
      <td width="30">3</td>
      <td style="text-align: center;" width="30">10</td>
      <td width="30">17</td>
      <td width="30">24</td>
      <td width="30">31</td>
    </tr>
    <tr align="center">
      <td width="30">Ne</td>
      <td width="30">4</td>
      <td width="30">11</td>
      <td width="30">18</td>
      <td width="30">25</td>
      <td width="30">&nbsp;</td>
    </tr>
  </tbody>
</table>
<p>Půjdeme na to tak, že vyvineme novou třídu,
nazvanou lepsi_kalendar, která bude danou vlastnost implementovat.
Třídy potomků se v PHP tvoří pomocí klíčového slova extends. My
použijeme třídu, která bude mít oproti předchozí třídě jednu vlastnost
navíc - bude umět zpracovat pole nazvané zvyrazni_dny; v našem případě
tedy dny prvního, sedmého, osmého, třináctého a šestadvacátého. Bude to
vypadat
nějak takhle:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">class </font><font color="#0000bb">lepsi_kalendar </font><font color="#007700">extends </font><font color="#0000bb">kalendar<br>
&nbsp;&nbsp;</font><font color="#007700">{<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$zvyrazni_dny</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//atd.<br>
&nbsp;&nbsp;</font><font color="#007700">}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Kde se v našem kalendáři tvoří obsahy jednotlivých buněk? Tvoří se v
metodě Bunka(). A právě tuto metodu bude naše nová třída implementovat
lepším způsobem než ta původní. Půjde se na to tak, že se prozkoumá
pole $zvyrazni_dny, a jestliže se v něm najde číslo, které chceme právě
vepsat do buňky, napíše se větším písmem a tučně. Pavel Kácha v seriálu
o HTML nám vysvětlil <a target="_blank" href="http://www.linuxsoft.cz/article.php?id_article=224">jak na to</a>,
takže to bude maličkost. V následujícím kódu si všimněte, jak jednoduše
se dceřiné třídy píší:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">class </font><font color="#0000bb">lepsi_kalendar </font><font color="#007700">extends </font><font color="#0000bb">kalendar<br>
&nbsp;&nbsp;</font><font color="#007700">{<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$zvyrazni_dny</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000bb">Bunka </font><font color="#007700">(</font><font color="#0000bb">$radek</font><font color="#007700">, </font><font color="#0000bb">$sloupec</font><font color="#007700">, </font><font color="#0000bb">$PrvniDen</font><font color="#007700">, </font><font color="#0000bb">$PocetDnu</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$dny</font><font color="#007700">=Array(</font><font color="#0000bb">1</font><font color="#007700">=&gt;</font><font color="#dd0000">"Po"</font><font color="#007700">, </font><font color="#dd0000">"Út"</font><font color="#007700">, </font><font color="#dd0000">"St"</font><font color="#007700">, </font><font color="#dd0000">"Čt"</font><font color="#007700">, </font><font color="#dd0000">"Pá"</font><font color="#007700">, </font><font color="#dd0000">"So"</font><font color="#007700">, </font><font color="#dd0000">"Ne"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$sloupec</font><font color="#007700">==</font><font color="#0000bb">1</font><font color="#007700">) return </font><font color="#0000bb">$dny</font><font color="#007700">[</font><font color="#0000bb">$radek</font><font color="#007700">];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$chcivratit
</font><font color="#007700">= (</font><font color="#0000bb">$sloupec</font><font color="#007700">-</font><font color="#0000bb">2</font><font color="#007700">)*</font><font color="#0000bb">7 </font><font color="#007700">+ </font><font color="#0000bb">$radek </font><font color="#007700">- </font><font color="#0000bb">$PrvniDen</font><font color="#007700">+</font><font color="#0000bb">1</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$chcivratit</font><font color="#007700">&lt;</font><font color="#0000bb">1 </font><font color="#007700">|| </font><font color="#0000bb">$chcivratit</font><font color="#007700">&gt;</font><font color="#0000bb">$PocetDnu</font><font color="#007700">) return </font><font color="#dd0000">"&amp;nbsp;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">in_array</font><font color="#007700">(</font><font color="#0000bb">$chcivratit</font><font color="#007700">, </font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">zvyrazni_dny</font><font color="#007700">))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#dd0000">"&lt;B&gt;&lt;BIG&gt;"</font><font color="#007700">.</font><font color="#0000bb">$chcivratit</font><font color="#007700">.</font><font color="#dd0000">"&lt;/BIG&gt;&lt;/B&gt;"</font><font color="#007700">;
else return </font><font color="#0000bb">$chcivratit</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$muj_kalendar</font><font color="#007700">= new </font><font color="#0000bb">lepsi_kalendar</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$muj_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">mesic</font><font color="#007700">=</font><font color="#0000bb">7</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$muj_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">rok</font><font color="#007700">=</font><font color="#0000bb">2004</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$muj_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">zvyrazni_dny </font><font color="#007700">= Array(</font><font color="#0000bb">1</font><font color="#007700">,</font><font color="#0000bb">7</font><font color="#007700">,</font><font color="#0000bb">8</font><font color="#007700">,</font><font color="#0000bb">13</font><font color="#007700">,</font><font color="#0000bb">26</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$muj_kalendar</font><font color="#007700">-&gt;</font><font color="#0000bb">vypis</font><font color="#007700">();<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/20_1.html" target="_blank">Ukázat
skript</a></p>
<p>Kód jako takový si vyžadá jeden komentář a tím je použití funkce
<a href="http://cz.php.net/manual/en/function.in-array.php">in_array</a>,
o níž jsme zatím nemluvili. Je to na pochopení jednoduchá
funkce - vrátí TRUE, pokud je daná hodnota (v našem případě
$chcivratit) v daném poli (v našem případě $this-&gt;zvyrazni_dny).
Pokud tam ten den je, vrátíme jako obsah buňky zvýrazněný text, pokud
ne, vrátíme text normální.<br>
</p>
<p>Daleko zajímavější je, jak funguje celý skript. Protože třída
lepsi_kalendar rozšiřuje třídu kalendar, dědí z této rodičovské třídy
všechno, co sama nedělá jinak. Tak například dědí vlastnosti <span style="font-weight: bold;">mesic</span> a <span style="font-weight: bold;">rok</span>, a dědí rovněž metodu <span style="font-weight: bold;">vypis</span>. Co nedědí je metoda <span style="font-weight: bold;">Bunka</span>, protože tu si upravuje k
obrazu svému. Je tedy jasné, že děděním můžeme získat řadu tříd, které
rozšiřují možnosti nějaké základní třídy.<br>
</p>
<p>To, co jsme uvedli nejsou všechny možnosti, které PHP pro práci s
objekty nabízí. Například existuje sada funkcí pro práci s objekty
a&nbsp; několik dalších možností při jejich vytváření. Co bychom ale
určitě vědět měli je skutečnost, že práce s objekty v PHP přináší svá
úskalí.<br>
</p>
<a name="000082"></a><h2>PHP, objekty a úskalí</h2>
<p>PHP nemá <span style="font-weight: bold;">privátní metody</span>.
To znamená, že v našem případě například neexistuje způsob, jak
zabránit tomu, aby se dala zavolat metoda <span style="font-weight: bold;">Bunka</span> zvnějšku třídy, ačkoli je to
metoda prospěšná pouze třídě jako takové a okolní svět by o ní vůbec
nemusel vědět. Odborně se principu, kdy je implementace metody ukryta
říká zapouzdření.<br>
</p>
<p>PHP zbaští <span style="font-weight: bold;">nedeklarované atributy</span>.
To může být hotová katastrofa.
Následující kód například bohužel bude fungovat přesto, že
stupidni_trida atribut $b vůbec nedeklaruje:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">class </font><font color="#0000bb">stupidni_trida<br>
</font><font color="#007700">{<br>
&nbsp;&nbsp;var </font><font color="#0000bb">$a</font><font color="#007700">;<br>
}<br>
<br>
</font><font color="#0000bb">$moje_trida</font><font color="#007700">=new
</font><font color="#0000bb">stupidni_trida</font><font color="#007700">;<br>
</font><font color="#0000bb">$moje_trida</font><font color="#007700">-&gt;</font><font color="#0000bb">b</font><font color="#007700">=</font><font color="#0000bb">3</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$moje_trida</font><font color="#007700">-&gt;</font><font color="#0000bb">b</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V PHP je neintuitivní <span style="font-weight: bold;">přiřazování
objektů</span>. Co myslíte, že bude
výsledkem následujícího skriptu?</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">class </font><font color="#0000bb">stupidni_trida<br>
</font><font color="#007700">{<br>
&nbsp;&nbsp;var </font><font color="#0000bb">$a</font><font color="#007700">;<br>
}<br>
<br>
</font><font color="#0000bb">$prvni_trida</font><font color="#007700">=new
</font><font color="#0000bb">stupidni_trida</font><font color="#007700">;<br>
</font><font color="#0000bb">$prvni_trida</font><font color="#007700">-&gt;</font><font color="#0000bb">a</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">;<br>
<br>
</font><font color="#0000bb">$druha_trida</font><font color="#007700">=</font><font color="#0000bb">$prvni_trida</font><font color="#007700">;<br>
</font><font color="#0000bb">$druha_trida</font><font color="#007700">-&gt;</font><font color="#0000bb">a</font><font color="#007700">=</font><font color="#0000bb">2</font><font color="#007700">;<br>
<br>
echo </font><font color="#0000bb">$prvni_trida</font><font color="#007700">-&gt;</font><font color="#0000bb">a</font><font color="#007700">; </font><font color="#ff8000">// není 2 ale 1<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Rovnítko (bohužel) nezpůsobí vytvoření odkazu na objekt, ale
vytvoření kopie objektu. Na to je třeba myslet.<br>
</p>
<p>Zda a jak budete v PHP používat objekty je samozřejmě na Vás. Níže
je ješě několik věcí a postřehů k objektům a PHP, které byste měli znát:<br>
</p>
<ul>
  <li>Mnoho hotových knihoven a částí kódů PHP objekty používá</li>
  <li>Můžete klidně mít jen jednu "úroveň" objetů bez dědičností</li>
  <li>Objekt může existovat bez metod, jen s atributy. Ale někdy je pak
lepší použít pole.</li>
  <li>Někdo zase v PHP pro "přiřazení" každého atributu vytváří metodu
nebo metody</li>
  <li>Při použití objektů platí více než kdy dříve, že byste si měli
vymyslet a dodržovat konvence (třeba, někdo začíná metody, které by se
neměly volat zvnějšku objektu podtržítkem)</li>
  <li>PHP 5 bude některé vlastnosti objektů měnit. K lepšímu, jistá
omezení uvedená výše by mohla padnout. Více o tom bude v dokumentaci.</li>
</ul>
<p>V dalším díle našeho seriálu opustíme OOP a podíváme se, jaké
možnosti máme v PHP pro rozdělování zdrojových kódů do více fyzických
souborů a jejich načítání.</p>
<p>
<a name="000083"></a></p><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (21) - Vkládání souborů</h2>
			<p class="perex">PHP umožňuje mít jeden web v několika zdrojových
souborech. V tomto díle seriálu se podíváme, jak tyto soubory skládat
dohromady.
				<br>
			</p>
			<p>Často bývá potřeba rozdělit jeden web na několik souvisejících
souborů. Respektive to bývá potřeba skoro vždycky. Dnes se podíváme,
jak PHP vkládání souboru řeší a jak to použít v praxi.<br>
</p>
<p>PHP, jak jsme již v tomto seriálu uvedli, je jazyk interpretovaný,
nikoliv kompilovaný. Při provádění skriptu lze do sebe celkem
bezbolestně vkládat několik
zdrojových souborů. Když budeme chtít například stvořit web se
sloupcovou úpravou, možná budeme chtít mít každý sloupec v samostatném
souboru php. Taková věc je někdy životní nutností - kvůli orientaci.
Celé by to mohlo vypadat nějak takhle:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"levá
část"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>(levá část)</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Tohle
bude prostředek"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>(prostřední část)</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Něco
bude vpravo"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>(pravá část)</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE height="100%"
width="100%" border="1"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD width=20% valign="top"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?</font><font color="#007700">require </font><font color="#dd0000">"21_left.php"</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD width=60% valign="top"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?</font><font color="#007700">include </font><font color="#dd0000">"21_middle.php"</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD width=20% valign="top"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?</font><font color="#007700">include </font><font color="#dd0000">"21_right.php"</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TR&gt;<br>
&lt;/TABLE&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->

<a name="000084"></a><h2>include, require</h2>
<p>Příkazy <a href="http://cz.php.net/manual/en/function.include.php">include</a>
a <a href="http://cz.php.net/manual/en/function.require.php">require</a>
se používají pro vložení zdrojového
souboru php na určité místo v jiném souboru. Vložený soubor se ve
výsledku chová tak, jako by byl na daném místě odjakživa. To znamená,
že pokud je v něm kód jazyka PHP, normálně se provede. Require se chová
úplně stejně jako include; rozdíl je pouze v tom, co se stane, když
požadovaný
soubor k začlenění chybí. Include vyprodukuje varování, require fatální
chybu. Umístění include a require souborů vůči souboru, do nějž se bude
vkládat může být být dáno buď relativní cestou, nebo pomocí
konfigurační proměnné include_path při instalaci PHP. Začleněné soubory
se chovají skutečně "jako by tam byly odjakživa", takže jestliže je
například v začleňovaném souboru definována funkce, skript, do něhož se
začleňuje může tuto funkci využít.<br>
</p>
<a name="000085"></a><h2>include_once, require_once</h2>
<p>Tyto příkazy fungují stejně jako předchozí dva, jen s tím rozdílem,
že zabrání opětovnému vložení dvakrát stejného souboru. Při sestavování
složitějších projektů může situace, kdy nevíte zda soubor byl či nebyl
vložen, skutečně nastat, takže se to hodí. Vložení dvakrát téhož
souboru může celý skript snadno zablokovat, protože například definovat
dvakrát funkci se stejným názvem je nepřípustné.<br>
</p>
<a name="000086"></a><h2>readfile</h2>
<p>Funkce <a href="http://cz.php.net/manual/en/function.readfile.php">readfile</a>
přečte nějaký soubor a tak jak je ho vloží do
výstupního proudu. To znamená, že soubor není zpracován jako PHP
skript, ale je tupě převzat a odeslán prohlížeči. Zajímavostí pěti výše
uvedených příkladů je také to, že dokáží číst nejen soubory operačního
systému, ale i
soubory získané pomocí protokolů http nebo ftp. Přebírání informací z
cizích zdrojů <span style="font-style: italic;">tímto způsobem</span>
byste se však měli pokud možno vyhnout, protože mohou představovat
vysoká bezpečností rizika.<br>
</p>
<a name="000087"></a><h2>die a exit<br>
</h2>
<p>V souvislosti se začleňováním souborů vzniká otázka, jak je to s
přerušováním běhu skriptů. K tomu slouží příkazy <a href="http://cz.php.net/manual/en/function.die.php">die</a>, <a href="http://cz.php.net/manual/en/function.exit.php">exit</a> a <a href="http://cz.php.net/manual/en/function.return.php">return</a>.
Příkaz die je trochu zákeřný. Provede okamžité ukončení provádění
skriptu. Jesliže ale byl skript vložen v jiném skriptu, ukončí se ten
rodičovský také. To může mít neblahé důsledky, protože tak například
může vzniknout neplatný kód. Příkaz die proto používám dost nerad.<br>
</p>
<p>Die akceptuje nepovinný řetězcový parametr, který se předá do
prohlížeče jako poslední text předtím, než PHP přeruší provádění
skriptu. Příkaz exit funguje stejně jako die, jen nepřebírá žádné
parametry a končí hned. Takže, kdybychom ve výše uvedeném příkladu
modifikovali soubor 21_middle.php takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Tohle
bude prostředek"</font><font color="#007700">;<br>
die (</font><font color="#dd0000">"Pokračuj v pekle..."</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>zjistíte,
že zbytek skriptu se neprovedl a odeslali jsme neplatný kód HTML,
protože máme neuzavřenou tabulku.</p>
<a name="000088"></a><h2>return</h2>
<p>Return přece známe: Doposud jsme jej používali jako příkaz pro
vrácení hodnoty z funkce. Ale jestliže je return použit v těle skriptu
a ne ve funkci, ukončí provádění aktuálního skriptu. Narozdíl od die a
exit však umožňuje pokračovat "rodičovským" skriptem v případě, kdo
voláme return z vloženého souboru. Takže takto upravený "prostřední"
soubor
ke vložení:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Tohle
bude prostředek"</font><font color="#007700">;<br>
return;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>způsobí, že následující kód se provede.</p>
<a name="000089"></a><h2>Poznámky</h2>
<ul>
  <li>Vkládání souborů se používá často. Většinou se v nich dělá
pořádek pomocí názvů.</li>
  <li>Pozor na die. Může Vám vzniknout syntakticky neplatná stránka,
když jej zavoláte s příliš horkou hlavou.</li>
  <li>Vkládání vzdálených souborů není dobrý nápad z hlediska
bezpečnosti. Zejména pokud nemáte možnost ovlivnit, co vkládáte.</li>
  <li>Include soubor se dá použít s výhodou například ke vložení
konfiguračních hodnot.</li>
  <li>Vložené soubory mohou obsahovat další vložené soubory. Ale
vyznáte se v tom?</li>
</ul>
<p>V dalším díle seriálu o PHP se podíváme na regulární výrazy.</p>
<a name="000090"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (22) - Regulární výrazy</h2>
			<p class="perex">PHP obsahuje nástroje pro práci s regulárními výrazy. Ukažme si, jak tyto funkce použít v praktickém programování.
				<br>
			</p>
			<p>Pokud jste na PHP přešli z ASP (jako kdysi já) pravděodobně Vám
regulární výrazy nic neříkají. A přitom jsou tak zábavné. Podívejme se,
jak celá ta věc funguje. </p>
<p>Název "výrazy" je trochu matoucí. V <a href="#000034">díle seriálu
o výrazech</a> jsme prohlásili, že výraz je cokoli, co má hodnotu.
Regulární výrazy jsou naproti tomu jen vžitým pojmenováním mechanismu,
který nám umožňuje pracovat s řetězci a maskami. Nejlepší bude opustit
šedivou teorii a vrhnout se hned na nějaké příklady.<br>
</p>
<p>Mějme například masku "Petr". Této masce vyhoví řetězce "Petr je
borec", "Je doma Petr?" i "Honza, Petr a Pavel", protože všechny
obsahují slovo Petr. Výraz "Franta je taky borec" pochopitelně masce
nevyhoví, neb slovo Petr neobsahuje. V PHP přesně na tohle testování
existuje funkce <a href="http://cz.php.net/manual/en/function.ereg.php">ereg</a>,
která vrací TRUE nebo FALSE pro případy, kdy
řetězec vyhoví nebo nevyhoví masce:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">echo (integer) </font><font color="#0000bb">ereg</font><font color="#007700">(</font><font color="#dd0000">"Petr"</font><font color="#007700">, </font><font color="#dd0000">"Petr je borec"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">ereg</font><font color="#007700">(</font><font color="#dd0000">"Petr"</font><font color="#007700">, </font><font color="#dd0000">"Je doma Petr?"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">ereg</font><font color="#007700">(</font><font color="#dd0000">"Petr"</font><font color="#007700">, </font><font color="#dd0000">"Honza, Petr a Pavel"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">ereg</font><font color="#007700">(</font><font color="#dd0000">"Petr"</font><font color="#007700">, </font><font color="#dd0000">"Franta je taky borec"</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>To bylo jednoduché. Síla regulárních výrazů však spočívá v něčem
trochu jiném. Teď budeme postupovat tak, že nejdřív si vysvětlíme, co
všechno lze použít pro definici masky, pak se podíváme na funkce v PHP
s maskami pracující a nakonec si ukážeme na nějaké praktické příklady.<br>
</p>
<a name="000091"></a><h2>Masky</h2>
<p>Situaci kolem regulárních výrazů komplikuje fakt, že maska může
obsahovat takzvané metaznaky. Některé častější jsem se pokusil shrnout
do
tabulky:</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; font-weight: bold;">Metaznak<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Znamená<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Výrazu:<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Vyhoví<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Nevyhoví<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">^<br>
      </td>
      <td style="vertical-align: top;">Začátek řetězce<br>
      </td>
      <td style="vertical-align: top;">^Petr</td>
      <td style="vertical-align: top;">Petr je borec<br>
Petr není borec<br>
      </td>
      <td style="vertical-align: top;">Borec je Petr<br>
Franta a Petr jsou borci<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">$<br>
      </td>
      <td style="vertical-align: top;">Konec řetězce<br>
      </td>
      <td style="vertical-align: top;">PC$<br>
      </td>
      <td style="vertical-align: top;">Mám PC<br>
Pracuji na PC<br>
      </td>
      <td style="vertical-align: top;">Moje PC je rozbité<br>
PC má dnes každý<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">.<br>
      </td>
      <td style="vertical-align: top;">Libovolný znak<br>
      </td>
      <td style="vertical-align: top;">s.x<br>
      </td>
      <td style="vertical-align: top;">sex<br>
six<br>
      </td>
      <td style="vertical-align: top;">tix<br>
sad<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">*<br>
      </td>
      <td style="vertical-align: top;">Předchozí znak se smí
libovolněkrát opakovat (i nulakrát)<br>
      </td>
      <td style="vertical-align: top;">s*t<br>
      </td>
      <td style="vertical-align: top;">prst<br>
půst<br>
prut<br>
      </td>
      <td style="vertical-align: top;">prase<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">+<br>
      </td>
      <td style="vertical-align: top;">Předchozí znak tam bude
minimálně jednou<br>
      </td>
      <td style="vertical-align: top;">s+t<br>
      </td>
      <td style="vertical-align: top;">prst<br>
srst<br>
      </td>
      <td style="vertical-align: top;">prut<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">?<br>
      </td>
      <td style="vertical-align: top;">Předchozí znak tam bude
maximálně jednou</td>
      <td style="vertical-align: top;">s?t<br>
      </td>
      <td style="vertical-align: top;">prejt<br>
prst<br>
psst<br>
      </td>
      <td style="vertical-align: top;">síť<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">[]<br>
      </td>
      <td style="vertical-align: top;">Libovolný znak ze znaků v závorce<br>
      </td>
      <td style="vertical-align: top;">[0123456789]<br>
      </td>
      <td style="vertical-align: top;">12<br>
356<br>
8 kusů<br>
      </td>
      <td style="vertical-align: top;">kusy<br>
kila<br>
litry<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">()<br>
      </td>
      <td style="vertical-align: top;">Všechny znaky ze znaků v závorce<br>
      </td>
      <td style="vertical-align: top;">(obec)<br>
      </td>
      <td style="vertical-align: top;">obecný<br>
obecní<br>
všeobecný<br>
      </td>
      <td style="vertical-align: top;">věcný<br>
jablečný<br>
všeobjímající<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">|<br>
      </td>
      <td style="vertical-align: top;">Rozdělení na podvýrazy<br>
      </td>
      <td style="vertical-align: top;">A|B<br>
      </td>
      <td style="vertical-align: top;">Astronaut<br>
Babička<br>
      </td>
      <td style="vertical-align: top;">edém<br>
čistě<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">\<br>
      </td>
      <td style="vertical-align: top;">Následující metaznak bude chápán
jako znak<br>
      </td>
      <td style="vertical-align: top;">\+<br>
      </td>
      <td style="vertical-align: top;">Vše, co obsahuje "+"<br>
      </td>
      <td style="vertical-align: top;">Co neobsahuje "+"<br>
      </td>
    </tr>
  </tbody>
</table>
<p>Existují ovšem i další metaznaky, které si můžete nastudovat v
manuálu. Většinou Vám tyto budou stačit. Pochopitelně, že v jedné masce
může být více metaznaků, čímž mohou regulární výrazy extrémně nabýt na
složitosti (a síle).<br>
</p>
<a name="000092"></a><h2>PHP a funkce pro regulární výrazy</h2>
<p>O funkci ereg, která vrátí TRUE v případě, že daný řetězec vyhovuje
masce, jsme již psali. Funkce <a href="http://cz.php.net/manual/en/function.ereg-replace.php">ereg_replace</a>
funguje tak, že části
řetězce vyhovující masce nejen pozná, ale nahradí jiným řetězcem. Její
použití si ukážeme v závěru. Funcke ereg i ereg_replace rozlišují
velikost písmen. Existují funkce <a href="http://cz.php.net/manual/en/function.eregi.php">eregi</a> a <a href="http://cz.php.net/manual/en/function.eregi-replace.php">eregi_replace</a>,
které provádějí
totéž jako jejich protějšky, ale velikost písmen přitom nerozlišují.<br>
</p>
<p>Konečně existuje funkce <a href="http://cz.php.net/manual/en/function.split.php">split</a> (a <a href="http://cz.php.net/manual/en/function.spliti.php">spliti</a>
nerozlišující velikost
písmen) pro dělení řetězce maskou. Výsledkem je pole řetězců vzniklých
tímto rozdělením a funkce se svojí filozofií podobá funkci explode,
kterou jsme již v tomto seriálu popisovali.<br>
</p>
<p>Ony existují ještě další funkce pro práci s regulárními výrazy v
PHP, stejně jako existují i další masky. Pojďme se ale nyní podívat,
jak nám taková kupa nových informací může nějak pomoci v praktických
příkladech. <br>
</p>
<a name="000093"></a><h2>Praxe</h2>
<p>V praxi například budete chtít zjistit, jestli se dá zadaný řetězec
chápat jako celé číslo. K tomu byste mohli využít něco jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">function </font><font color="#0000bb">JeCeleCislo </font><font color="#007700">(</font><font color="#0000bb">$cislo</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">ereg</font><font color="#007700">(</font><font color="#dd0000">"^</font><font color="#007700">[</font><font color="#dd0000">\+\-</font><font color="#007700">]</font><font color="#dd0000">?</font><font color="#007700">[</font><font color="#dd0000">1234567890</font><font color="#007700">]</font><font color="#dd0000">+</font><font color="#007700">$</font><font color="#dd0000">"</font><font color="#007700">,</font><font color="#0000bb">$cislo</font><font color="#007700">);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">JeCeleCislo </font><font color="#007700">(</font><font color="#dd0000">"1"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">JeCeleCislo </font><font color="#007700">(</font><font color="#dd0000">"-6"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">JeCeleCislo </font><font color="#007700">(</font><font color="#dd0000">"3.5"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">JeCeleCislo </font><font color="#007700">(</font><font color="#dd0000">"4 kusy"</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Celé je to založeno na výsledku funkce ereg a jeji vyhodnocování
bychom mohli číst následovně (v závorkách uvádím zápis toho, co bylo
právě řečeno, jako metaznak): Abych jakožto funkce ereg vrátila TRUE,
musel by řetězec $cislo nějak vypadat. Měl by začínat (<span style="font-weight: bold;">^</span>) znakem plus (<span style="font-weight: bold;">\+</span>) nebo (<span style="font-weight: bold;">[]</span>) mínus (<span style="font-weight: bold;">\-</span>), který tam bude maximálně jednou
(<span style="font-weight: bold;">?</span>). Pak musí následovat
některá z číslic (<span style="font-weight: bold;">[1234567890]</span>),
což je věc, která se může opakovat, ale nejmíň jednou (<span style="font-weight: bold;">+</span>) tam být musí. Tím celá záležitost
musí končit (<span style="font-weight: bold;">$</span>). Hezké, že?<br>
</p>
<p>Nebo budete chtít testovat, jestli předaný řetězec může představovat
platnou e-mailovou adresu. Třeba to bude vypadat nějak takhle:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">function </font><font color="#0000bb">JeEmail </font><font color="#007700">(</font><font color="#0000bb">$cislo</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">ereg</font><font color="#007700">(</font><font color="#dd0000">"^.+@.+\..+</font><font color="#007700">$</font><font color="#dd0000">"</font><font color="#007700">,</font><font color="#0000bb">$cislo</font><font color="#007700">);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">JeEmail </font><font color="#007700">(</font><font color="#dd0000">"nekdo@neco.cz"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">JeEmail </font><font color="#007700">(</font><font color="#dd0000">"nekdoneco.cz"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">JeEmail </font><font color="#007700">(</font><font color="#dd0000">"@neco.cz"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">JeEmail </font><font color="#007700">(</font><font color="#dd0000">"neco.cz"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">JeEmail </font><font color="#007700">(</font><font color="#dd0000">"nekdo@necocz"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo (integer) </font><font color="#0000bb">JeEmail </font><font color="#007700">(</font><font color="#dd0000">"nekdo@neco."</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Zase vysvětlení: Výraz by měl začínat (<span style="font-weight: bold;">^</span>) libovolným znakem (<span style="font-weight: bold;">.</span>), který se může opakovat, ale
minimálně jednou tam být musí (<span style="font-weight: bold;">+</span>).
Pak bude zavináč, pak opět jeden nebo více znaků (<span style="font-weight: bold;">.+</span>) a konečně doslovná tečka (<span style="font-weight: bold;">\.</span>) a nějaké ty znaky (<span style="font-weight: bold;">.+</span>). Tím to celé končí (<span style="font-weight: bold;">$</span>).<br>
</p>
<p><span style="font-style: italic;">Pozn.: Není to tak úplně
jednoduché. RFC definuje daleko složitější věci, které mohou
představovat platnou e-milovou adresu, ale jako příklad už by to nebylo
tak názorné.</span><br>
</p>
<p>A ještě jeden příklad do třetice. Slibuji, že už to nebude tak
složité. Pomocí ereg_replace nahraďme všechna místa s více mezerami jen
jednou mezerou:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$retezec</font><font color="#007700">= </font><font color="#dd0000">"Mám&nbsp;&nbsp;&nbsp;řetězec&nbsp;&nbsp;&nbsp;se&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zbytečně&nbsp;&nbsp;mnoho
mezerami,&nbsp;&nbsp;&nbsp;že&nbsp;&nbsp;&nbsp;&nbsp;????"</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$retezec</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
echo </font><font color="#0000bb">ereg_replace</font><font color="#007700">(</font><font color="#dd0000">" +"</font><font color="#007700">, </font><font color="#dd0000">" "</font><font color="#007700">, </font><font color="#0000bb">$retezec</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Neboli: Všechny výskyty řetěce, který obsahuje nejméně (<span style="font-weight: bold;">+</span>) jednu mezeru, nahraď jednou
mezerou. Ono to skutečně funguje. Nechte si zobrazit zdrojový kód
stránky v prohlížeči, než to začnete považovat za nefunkční kus kódu.<br>
</p>
<p>Pokud máte nějaké další příklady použití regulárních výrazů (nejlépe
z praxe), uvítám jejich uvedení v diskusi. Sám jsem v PHP mnoho jiných
příkladů než ty výše uvedené neviděl.</p>
<a name="000094"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (23) - Neztraťte se ve funkcích</h2>
			<p class="perex">Funkcí v PHP je nepřeberné množství. Dnes si
letmo shrneme, co všechno tento jazyk vlastně umí a co z toho se
vyplatí vědět z hlavy.
				<br>
			</p>
			<p>PHP je jazyk vybavený mnoha funkcemi. Když se s ním setkal poprvé,
trochu mě to odradilo. Dnešní díl seriálu má za cíl
čtenáře uklidnit. Není totož nutné všechno si pamatovat, ale je
dobré alespoň vědět, že nějaké možnosti existují. I profesionál
pracující s PHP běžně využívá jen asi 10% existujících prvků tohoto
mocného programovacího nástroje.<br>
</p>
<a name="000095"></a><h2>Základní okruhy funkcí</h2>
<p>Již jsme se podívali na převážnou většinu toho, co budete při práci
s PHP potřebovat neustále. Jsou to základní příkazy a funkce. Čistě pro
osvěžení - byla řeč o následujících prvcích PHP: Echo,
operátory, výrazy, pole, příkazy pro řízení toku a některé příkazy pro
formátování data a času. Shrňme si teď určité okruhy funkcí v PHP,
které se vyplatí při vážné práci znát, nejlépe z hlavy. To samozřejmě
neznamená, že se je musíte hned naučit. Spíš jsou to věci, které
pravděpodobně budete potřebovat opakovaně.<br>
</p>
<p><span style="font-weight: bold;">Funkce pro práci z řetězci</span><br>
Ty budete v PHP potřebovat neustále. Ořezání, nahrazení řetězce,
vyjmutí jeho části anebo formátování jsou dobrý příklad. Tyto funkce
budete muset znát téměř jistě, protože prohlížeči se nakonec ke
zobrazení posílají stejně řetězce.<br>
</p>
<p><span style="font-weight: bold;">Odesílání e-mailů</span><br>
PHP umí odeslat e-mail. To je funkce, kterou velmi oceníte a jistě
využijete při tvorbě vlastních stránek. Pomocí rozšiřujících knihoven
dokonce PHP umí posílat i zprávy s přílohami a tak dále.<br>
</p>
<p><span style="font-weight: bold;">Funkce pro práci se soubory</span><br>
Umět soubory vytvořit, odstarit, zapsat do nich, nahrát je na server
nebo smazat se vždycky hodí.
Tomuto
tématu se v našem seriálu budeme zanedlouho podrobně věnovat, takže se
máte na co těšit.<br>
</p>
<p><span style="font-weight: bold;">Funkce pro práci s databázemi</span><br>
PHP podporuje spolupráci s mnoha databázemi. Tomu se při vážné práci
nevyhneme. A nevyhneme se tomu ani v našem seriálu. Téma databází je
velice rozsáhlé a bude to na několik dílů.<br>
</p>
<a name="000096"></a><h2>Co si pamatovat nemusíte</h2>
<p>Pokud nemáte fenomenální paměť nebo pokud ji máte, ale nechcete se
zatěžovat zbytčnostmi, můžete na zbytek funkcí PHP s klidným svědomím
zapomenout. Existují úzce specializované skupiny úloh, na které PHP má
celé sady funkcí, ale které se nepoužívají tak často. Patří mezi ně
funkce pro komprimaci a dekomprimaci, funkce pro práci s přesnou
matematikou, funkce pro práci se specifickými protokoly (třeba LDAP),
funkce pro přenosy souborů pomocí FTP, funkce pro kreslení obrázků,
šifrovací funkce, funkce specifické pro práci s nějakým serverem
(hlavně Apache), funkce specifické pro práci s nějakým operačním
systémem (dokonce i Windows) a
mnoho dalších. <br>
</p>
<p>Pamatujte si, že tolik funkcí zde není proto, aby to
uživatele děsilo, ale proto, aby mu to ulehčilo život. Budete-li
programovat něco speciálního (třeba tvorbu PDF pomocí PHP),
pravděpodobně se související funkce budete chtít naučit. Pokud ale
budete dělat běžné webové aplikace, vystačíte s minimem. </p>
<a name="000097"></a><h2>Manuál</h2>
<p>Pro věci, které si pamatovat nemusíte je tu PHP manuál. Narozdíl od
mnoha manuálů, které jsem viděl je tenhle docela užitečný, protože
obsahuje kromě věcí jako jsou popisy funkcí a příklady použití také
komentáře jednotlivých
uživatelů. Manuál najdete na adrese <a href="http://cz.php.net/manual/cs">http://cz.php.net/manual/cs</a>. Je
to rádoby česká, částečně přeložená verze. Uživatelské komentáře bývají
většinou v angličtině, ale často obsahují příklady a pochopíte je i
tehdy, pokud v angličtině nejste moc zběhlí.<br>
</p>
<p>Jednotlivé funkce mají logicky pojmenované související stránky v
doumentaci. Například funkce date má stránku <a href="http://cz.php.net/manual/cs/function.date.php">http://cz.php.net/manual/cs/function.date.php</a>,
funkce print stránku <a href="http://cz.php.net/manual/cs/function.print.php">http://cz.php.net/manual/cs/function.print.php</a>
a tak dále.<br>
</p>
<p>Manuál není k dispozici pouze on-line, ačkoli je to asi to nejlepší.
Pokud chcete nebo musíte vyvíjet PHP bez možnosti připojení k
internetu (brr), můžete si manuál stáhnout ve formě souborů html (pokud
byste
chtěli mermomocí něco pod Windows, tak se dá pořídit manuál i jako
soubor chm, tedy Windows help).</p>
<a name="000098"></a><h2>Praxe</h2>
<p>Až na malé výjimky se vyplatí používat nejnovější verzi PHP, protože
někreré funkce bývají do nových verzí přidány nebo tam jsou rozšířeny.
Anebo taky opraveny, pokud se dříve chovaly špatně. Když ale vyvíjíte
komerční aplikaci, pamatujte, že byste se měli
spoléhat jen na funkce podporované ve verzi PHP běžící na serveru, na
němž bude aplikace umístěna. Často bývá nemožné nebo náročné přimět
správce vzdáleného systému k tomu, aby upgradoval PHP, zejména když
jediným
důvodem upgrade je kód spoléhající na nejnovější verzi jazyka.</p>
<p>I když si myslíte, že pro činnost, kterou chcete dělat znáte
odpovídající funkci nebo funkce, vyplatí se podívat se do dokumentace,
zda se to nedá provést nějakým kratším způsobem. Například jsem kdysi
dávno potřeboval funkci, která by odstranila diakritiku z textu, abych
jej mohl odeslat jako zprávu na mobilní telefon. Nejprve mě napadlo
použití konstrukce case, ale bylo by to moc dlouhé. Potom jsemu
zvažoval použití funkce str_replace, která v řetězci nahrazuje některou
jeho část jiným řetězcem. To už by mohlo být trochu kratší. A pak jsem
se dozvěděl o funkci StrTr.
Výsledek byl zhruba následující:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">function </font><font color="#0000bb">BezDK</font><font color="#007700">(</font><font color="#0000bb">$text</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">StrTr</font><font color="#007700">(</font><font color="#0000bb">$text</font><font color="#007700">,</font><font color="#dd0000">"áčďěéëíľĺňóöřšťůúüýž"</font><font color="#007700">,</font><font color="#dd0000">"acdeeeillnoorstuuuyz"</font><font color="#007700">);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;echo </font><font color="#0000bb">BezDK </font><font color="#007700">(</font><font color="#dd0000">"žluťoučký kůň pěl
ďábelské ódy"</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Pěkné, že? (Pokud máte někdo kratší řešení, můžete přispět do
diskuse).<br>
</p>
<a name="000099"></a><h2>Co bude teď v seriálu</h2>
<p>Náš seriál se nyní přehoupne z naprostého úvodu k pokročilejším
tématům. Budeme několik dílů věnovat postupně třem okruhům: Zpracování <span style="font-weight: bold;">formulářů</span>, práci se <span style="font-weight: bold;">soubory </span>a práci s <span style="font-weight: bold;">databázemi</span>. Každé z témat zakončíme
nějakým použitelným příkladem, takže se máte na co těšit. Zčásti tato
témata kopírují ty věci, o kterých jsem prohlásil, že stojí za to se je
naučit; takže v závěru seriálu byste měli mít znalosti na sestavení
středně rozsáhlého webu. <br>
</p>
<p>Mimochodem, vymýšlení dostatečně jednoduchých a přitom popisných
příkladů není žádná hračka - takže pokud máte nějaký nápad co bychom
mohli ukázat jako příklad, můžete se realizovat v diskusi pod tímto
článkem.</p>
<a name="000100"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (24) - Pracujeme s formuláři</h2>
			<p class="perex">PHP umí zpracovat data z formulářů. Je to často používané a jednoduché, takže se to pojďme naučit.
				<br>
			</p>
			<p>Internet je interaktivní záležitost. To znamená, že uživatel může
nějaká data nejen od serveru požadovat, ale také je na server může
poslat. K tomu slouží v HTML formuláře - a PHP je potom na straně
serveru umí zpracovat.<br>
</p>
<a name="000101"></a><h2>Trocha teorie</h2>
<p>Formulářům bude zanedlouho věnován díl sesterského seriálu
věnujícímu se HTML obecně, takže k teorii jen stručně. Klasický
formulář obsahuje nějaké prvky pro uživatelský vstup (třebas textová
pole) a nějaké prvky pro jeho odeslání. Hodně jednoduchý formulář by
tedy mohl
vypadat nějak takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;form&gt;
<br>
&nbsp;&nbsp;Příjmení: &lt;input&gt; &lt;input type="Submit"&gt;
<br>
&lt;/form&gt;
<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>A jedním dechem dodejme, že pro účely zpracování v PHP je to
nepostačující. Abychom mohli formulář zpracovat pomocí PHP, měl by
splňovat dvě zásady:<br>
</p>
<ul>
  <li>měl by mít specifikován v tagu &lt;form&gt; atributy method a
action</li>
  <li>ovládací prvky (jako jsou například textová pole) by měly mít
specifikovány svůj název.</li>
</ul>
<p>Takže o něco "správnější" formulář pro účely zpracování PHP by mohl
vypadat například takhle:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;form method="get"
action="zpracuj.php"&gt;
<br>
&nbsp;&nbsp;Příjmení: &lt;input name="prijmeni"&gt; &lt;input
type="Submit" name="odesli"&gt;
<br>
&lt;/form&gt;
<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Tolik tedy lehce k definiční části formuláře. V PHP nás ale bude
zajímat především jeho zpracování.<br>
</p>
<a name="000102"></a><h2>Zpracování formuláře</h2>
<p>Jelikož je PHP jazyk spouštěný na serveru, zpracovává se formulář
pochopitelně také na serveru. V našem případě by tedy na serveru musel
existovat soubor zpracuj.php, který by zadané údaje nějak vyhodnotil.
Tím vyhodnocením může být prakticky jakákoli myslitelná akce. Skript
může zadané údaje zapsat do souboru nebo do databáze, může je použít
pro vrácení nějakých údajů z databáze nebo jiného serveru, může pomocí
nich ověřit
uživatele a tak dále. Prakticky jakýkoli seriál o formulářích ale
začíná
ukázkou, jak zaslaná data prostě jen vypsat do prohlížeče. <br>
</p>
<p>Tomu zůstaneme věrni i my. V našem skriptu zpracuj.php si ukážeme,
jak vypsat do prohlížeče příjmení, zadané v textovém poli při zobrazení
formuláře. Ještě jedna poznámka: teď budeme předpokládat, že existují
dva soubory - jeden bude <span style="font-weight: bold;">obsahovat </span>formulář
(viz výše) a druhý bude <span style="font-weight: bold;">zpracovávat </span>formulář.
Tedy, skript pro zpracování formuláře zpracuj.php může vypadat nějak
takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#007700">echo </font><font color="#dd0000">"Právě mi přišel formulář. Uživatel tam jistě zadal
nějaké příjmení!&lt;BR&gt;\n"</font><font color="#007700">;
<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Á, je to &lt;B&gt;"</font><font color="#007700">.</font><font color="#0000bb">$_REQUEST</font><font color="#007700">[</font><font color="#dd0000">"prijmeni"</font><font color="#007700">].</font><font color="#dd0000">"&lt;/B&gt;"</font><font color="#007700">;
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Z příkladu vidíme, že PHP obsahuje <a href="#000029">asociativní
pole</a> $_REQUEST[],
které obsahuje zaslaná data a zachází s nimi, jako by to byly klasické
proměnné. Kdyby bylo proměnných více, bylo by více i prvků pole
$_REQUEST. Abychom byli úplně přesní, dodejme, že už teď&nbsp; má pole
$_REQUEST dva prvky. O čemž se nevěřící Tomášové mohou přesvědčit
skriptem ve stylu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#007700">foreach (</font><font color="#0000bb">$_REQUEST </font><font color="#007700">as </font><font color="#0000bb">$pole</font><font color="#007700">)
<br>
&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#0000bb">$pole</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;
<br>
&nbsp;&nbsp;}
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Zkrátka: Ovládací prvek pro odeslání má také svoji hodnotu (je to
jeho popisek) a název (odesli), takže se pole $_REQUEST bude i v našem
jednoduchém případě skládat ze dvou prvků. Polužití pole $_REQUEST ná
přivádí ještě k jedné důležité odbočce do teorie zpracování formulářů,
a tou je<br>
</p>
<a name="000103"></a><h2>GET a POST<br>
</h2>
<p>Obecně vzato lze formuláře odesílat jak pomocí metody GET (tak jsme
to dělali v našem příkladu), tak i pomocí metody POST. K tomu je dobré
uvědomit si následující věci:<br>
</p>
<ul>
  <li>metodu odesílání stanovujeme v úvodním tagu &lt;FORM&gt; pomocí
atributu method. Když atribut vynecháme, použije se GET<br>
  </li>
  <li>pokud skript zpracovává formulář, je v asociativním poli
$_REQUEST obsah proměnných při použití kterékoli z obou metod</li>
  <li>metody GET a POST jsou rozdílné a každá se hodí na něco jiného</li>
</ul>
<p>Metoda GET posílá data z formuláře jako součást URL. Neboli, data se
objeví v poli Adresa Vašeho prohlížeče. Z toho vyplývá, že se tento
postup hodí dobře pro data, která jsou krátká a u kterých nevadí, když
si je někdo přečte. Mějte rovněž na paměti, že když si data může někdo
přečíst, může je taky změnit. Takový člověk pak může udělat "formulář
sám ze sebe" a poslat ke zpracování data, která vůbec nebyla vytvořena
odesláním zdrojového formuláře, ale byla zadána třebas jako součást
adresy do prohlížeče.<br>
</p>
<p>Naproti tomu POST nepřidává data do URL, ale odesílá je jako
samostatný HTTP objekt. Z toho vyplývá jednak to, že odesílaná data
mohou být podstatně delší než u GET, a jednak to, že je odesílatel
nemůže tak snadno změnit například vhodným zásahem do adresy.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Ale může je změnit zásahem
do komunikace mezi serverem a klientem. Takže, metoda POST je jen o
něco bezpečnější než GET.</span><br>
</p>
<p></p>
<p>Kterou metodu vybrat je otázka pro programátora. Pro jemnější
rozlišení jsou v
PHP kromě pole $_REQUEST rovněž pole $_GET a $_POST, která se naplní
proměnnými v případě, že formulář byl odeslán metodou GET nebo POST.
Což se hodí v případě, kdy budete chtít mezi těmito metodami rozlišovat.<br>
</p>
<a name="000104"></a><h2>A já sám, vždycky sám...</h2>
<p>V úvodu jsem prohlásil, že jeden soubor obsahuje samotný formulář a
druhý soubor jej zpracovává. To nemusí být vždycky pravda. Lze napsat
skript, který bude formulář jak obsahovat, tak taky zpracovávat. Což
může mít výhody a nevýhody. Výhodou může být jednoduchost - místo dvou
souborů je jen jeden. Nevýhoda je ta, že si tím trochu svazujeme ruce -
je obtížnější zpracovávat dva formuláře jedním skriptem a definice
formuláře musí být v souboru php, ne htm.<br>
</p>
<p>Situace, kdy je v jednom souboru formulář i jeho zpracování, se ale
používá docela často. Docela zajímavý problém je pak ten, jak má nebohý
skript poznat, jestli po něm chceme: a) zobrazit formulář a zadat
hodnoty, nebo b) už se zadávalo a on by měl zpracovat výsledky.&nbsp;
Ukážu Vám dva způsoby, jak to udělat a použiji přitom náš formulář
výše. Takže, první způsob:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#007700">if (!</font><font color="#0000bb">$_REQUEST</font><font color="#007700">[</font><font color="#dd0000">"UzJsemToOdeslal"</font><font color="#007700">])
<br>
&nbsp;&nbsp;{
<br>
</font><font color="#0000bb">?&gt;
<br>
</font>&lt;form method="get" action="25_jeden.php"&gt;
<br>
&nbsp;&nbsp;Příjmení: &lt;input name="prijmeni"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="hidden" name="UzJsemToOdeslal"
value="1"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="Submit" name="odesli"&gt;
<br>
&lt;/form&gt; <br>
<font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#007700">}
<br>
&nbsp;&nbsp;else
<br>
&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Mám tě, odeslaný
formuláři! Tys vyplnil "</font><font color="#007700">.</font><font color="#0000bb">$_REQUEST</font><font color="#007700">[</font><font color="#dd0000">"prijmeni"</font><font color="#007700">];
<br>
&nbsp;&nbsp;}
<br>
</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Spočívá to v tom, že vytvoříme skryté pole (hidden) formuláře, které
sice uživatel neuvidí, ale skript sám jej obdrží jakožto jeden z prvků
pole $_REQUEST. A pokud ho neobdrží, znamená to, že formulář ještě
nebyl odeslán a měl by se tedy zobrazit, ne zpracovat. Je zajímavé, že
to používá většina lidí.<br>
</p>
<p>Druhá metoda spočívá v tom, že vůbec nebudeme zavádět žádná další
skrytá pole formuláře, ale prozkoumáme PHP pole $_REQUEST. Je jasné, že
když bude toto pole prázdné, formulář jsme ještě neodeslali. Může to
vypadat nějak takhle:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#007700">if (empty (</font><font color="#0000bb">$_REQUEST</font><font color="#007700">))
<br>
&nbsp;&nbsp;{
<br>
</font><font color="#0000bb">?&gt;
<br>
</font>&lt;form method="get" action="source.php"&gt;
<br>
&nbsp;&nbsp;Příjmení: &lt;input name="prijmeni"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="Submit" name="odesli"&gt;
<br>
&lt;/form&gt; <br>
<font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#007700">}
<br>
&nbsp;&nbsp;else
<br>
&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Mám tě, odeslaný
formuláři! Tys vyplnil "</font><font color="#007700">.</font><font color="#0000bb">$_REQUEST</font><font color="#007700">[</font><font color="#dd0000">"prijmeni"</font><font color="#007700">];
<br>
&nbsp;&nbsp;}
<br>
</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Co z toho použijete je pochopitelně jen na Vás. Přijde mi ale dobré
využívat možnosti jazyka, když už jsou tak bohaté. Příště si ukážeme,
jak data z formulářů ověřovat.</p>
<a name="000105"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (25) - Formuláře - nikomu nevěřte</h2>
			<p class="perex">Při
zpracování dat z formulářů musíme být opatrní - a data ověřovat.
Uživatelé se totiž dříve nebo později pokusí podstrčit nám neplatná
data. <br>
			</p>
			<p>Je hezké, že umíme zpracovávat data pomocí formulářů - ale je tu ten
lidský prvek. Data z formulářů nepocházejí od počítačů, ale od lidí.
Protože v reálné aplikaci na tom většinou záleží, bude potřeba data
ověřovat. E-mailové adresy, telefonní čísla, webové adresy a spousta
dalších věcí se dají alespoň primitivně ověřit. Navíc, někdy může
formulář být terčem útoku - a nedostatečné ověření může způsobit "díru"
do naší aplikace.<br>
</p>
<a name="000106"></a><h2>Jednoduché ověřování<br>
</h2>
<p>Protože data z formuláře jsou k dispozici jakožto proměnné ve
skriptu, může nejjednodušší ověřování spočívat v kontrole těchto
proměnných. Takže, primitivní skript který ověří e-mailovou adresu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#007700">function </font><font color="#0000bb">JeEmail </font><font color="#007700">(</font><font color="#0000bb">$cislo</font><font color="#007700">)
<br>
&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">ereg</font><font color="#007700">(</font><font color="#dd0000">"^.+@.+\..+</font><font color="#007700">$</font><font color="#dd0000">"</font><font color="#007700">,</font><font color="#0000bb">$cislo</font><font color="#007700">);
<br>
&nbsp;&nbsp;}
<br>
<br>
&nbsp;&nbsp;if (empty (</font><font color="#0000bb">$_POST</font><font color="#007700">))
<br>
&nbsp;&nbsp;{
<br>
</font><font color="#0000bb">?&gt;
<br>
</font>&lt;form method="post" action="26_simple.php"&gt;
<br>
&nbsp;&nbsp;E-mail: &lt;input name="email"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="Submit" name="odesli"&gt;
<br>
&lt;/form&gt;
<br>
<font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#007700">}
<br>
&nbsp;&nbsp;else
<br>
&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (!</font><font color="#0000bb">JeEmail</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"email"</font><font color="#007700">])) echo </font><font color="#dd0000">"Tohle nevypadá
jako e-mail"</font><font color="#007700">;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;else echo </font><font color="#dd0000">"Zpracovávám
"</font><font color="#007700">. </font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"email"</font><font color="#007700">];
<br>
&nbsp;&nbsp;}
<br>
</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->

<p>Toto ověřování však má zásadní problém. Uživatele jsme sice
prokouknuli, ale místo všeho jiného jsme mu jen poslali varovnou
hlášku. Chtělo by to něco jiného - při chybě zobrazit opět původní
formulář. Což nám celý skript trošku zamotá, protože budeme muset
testovat jednak to, zda již byl formulář odeslán, a jednak to, zda byl
odeslán se správnými daty. Nová verze by mohla vypadat nějak takto: <br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#007700">function </font><font color="#0000bb">JeEmail </font><font color="#007700">(</font><font color="#0000bb">$cislo</font><font color="#007700">)
<br>
&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">ereg</font><font color="#007700">(</font><font color="#dd0000">"^.+@.+\..+</font><font color="#007700">$</font><font color="#dd0000">"</font><font color="#007700">,</font><font color="#0000bb">$cislo</font><font color="#007700">);
<br>
&nbsp;&nbsp;}
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">true</font><font color="#007700">;
<br>
&nbsp;&nbsp;if (!empty(</font><font color="#0000bb">$_POST</font><font color="#007700">)) </font><font color="#ff8000">// tak už se
odesílalo a musíme kontolovat
<br>
&nbsp;&nbsp;</font><font color="#007700">{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (!</font><font color="#0000bb">JeEmail</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"email"</font><font color="#007700">]))
<br>
&nbsp;&nbsp;&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//
kontrolou jsme neprošli
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">echo </font><font color="#dd0000">"Tohle nevypadá jako e-mail!"</font><font color="#007700">;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;else
<br>
&nbsp;&nbsp;&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//
kontolou jsme prošli
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">false</font><font color="#007700">;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Zpracovávám
"</font><font color="#007700">. </font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"email"</font><font color="#007700">];
<br>
&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
&nbsp;&nbsp;}
<br>
if (</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">):</font><font color="#0000bb">?&gt;
<br>
</font>&nbsp;&nbsp;&lt;form method="post" action="source.php"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;E-mail: &lt;input name="email"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="Submit"
name="odesli"&gt;
<br>
&nbsp;&nbsp;&lt;/form&gt;
<br>
<font color="#0000bb">&lt;?</font><font color="#007700">endif;</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Skript je poměrně dost překopaný a zalouží si rozsáhlý komentář. K
celému problému přistupujeme pesimisticky: předpokládáme, že ve většině
případů budeme muset formulář zobrazit. Takže si na to vytvoříme
logickou proměnnou $BudemeZobrazovat. Tato proměnná je ze začátku
nastavena na TRUE, tedy že formulář zobrazovat budeme. <br>
</p>
<p>Následuje podmínka testující, zda jsme již formulář odeslali. To je
postup, který jsme detailně rozebrali v minulém díle seriálu. Pokud
jsme ho neodesílali, tělo podmínky se neprovede a formulář se nám
zobrazí. Jestliže jsme formulář ale již odeslali, dostáváme se dovnitř,
do těla podmínky, kde máme vnořenou podmínku. ("dobře, něco jsme
odeslali, ale je to správně"). Pokud, a pouze pokud projdeme kontrolou,
nastavíme proměnnou $ZobrazitFormular na FALSE a můžeme formulář
zpracovat.<br>
</p>
<p>Jestliže ale testem správnosti formulář neprojde, zobrazíme varovnou
hlášku ("tohle nevypadá jako e-mail") a opustíme obě podmínky. Proměnná
$BudemeZobrazovat zůstala nasatavena na TRUE, takže se nám po varovné
hlášce formulář zobrazí, což je přesně to, co jsme chtěli.<br>
</p>
<p>Na celém přístupu je príma hlavně to, že samotná definice formuláře
je až na konci skriptu a neplete se nám do jeho zpracování. Ono to na
první pohled nevypadá, ale některé formuláře mají více vstupních prvků
a musí se provést více kontrol, takže se kód protáhne. <br>
</p>
<a name="000107"></a><h2>Profi přístup</h2>
<p>Nakolik se Vám možná chce jásat, má náš skript jednu dosti
podstatnou vadu. Když se mají údaje opravovat, chybí tam předvyplněné
ty původní. Za to Vás budou chtít uživatelé lynčovat, protože kdyby
formulář obsahoval deset polí a chyba by byla jen v jednom, je jasné,
že by museli vyplnit všech dest polí znova (brr). Jednoduchou úpravou
skriptu ale dosáhneme toho, že když jej vyplňujeme již poněkolikáté,
tak tam předchozí hodnoty zůstanou:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700"><br>
</font></font></code><code><font color="#000000"><font color="#ff8000">//
začátek je stejný...</font></font></code><br>
<code><font color="#000000"><font color="#007700">if (</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">):</font><font color="#0000bb">?&gt;
<br>
</font>&nbsp;&nbsp;&lt;form method="post" action="26_complex.php"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;E-mail: &lt;input name="email" value="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"email"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="Submit"
name="odesli"&gt;
<br>
&nbsp;&nbsp;&lt;/form&gt;
<br>
<font color="#0000bb">&lt;?</font><font color="#007700">endif;</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/26_complex.html" tarpost="_blank">Ukázat
skript</a></p>
<p>Skutečně to je takto jednoduché - když se má formulář zpracovávat po
několikáté, tak jsou již prvky pole $_POST k dispozici a můžete tedy
použít jejich hodnoty jako výchozí hodnoty prvků formuláře.<br>
</p>
<a name="000108"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (26) - Formuláře na sto způsobů</h2>
			<p class="perex">Ukažme si, jak v PHP zpracovávat takové prvky formulářů, jako jsou přepínače, zaškrtávací políčka nebo pole se seznamem.
				<br>
			</p>
			<p>Zatím jsme tak nějak předpokládali, že naše formuláře budou
obsahovat textová pole. Většina z nich je skutečně má. Ale pojďme se
podívat, jak v PHP zacházet s formuláři, které mají zaškrtávací
políčka, přepínače nebo pole se seznamem. Také si poněkud vylepšíme
zadávání atributu action v tagu &lt;FORM&gt; při definici formuláře.<br>
</p>
<a name="000109"></a><h2>Specifikace názvu skriptu</h2>
<p>Ukázky, které jsme zatím předvedli měly v atributu action tagu
&lt;form&gt; v definici formuláře cestu ke
zpracovávajícímu skriptu zadanou "natvrdo". To bude dobře fungovat v
učebnicích, ale ne v reálném světě. Ve skutečnosti totiž poměrně často
nastává situace, kdy při práci potřebujeme skript přejmenovat nebo
přesunout, a tím pádem bychom museli vždy atribut action přepsat tak,
aby odrážel nové umístění skriptu. Při čemž lehce může dojít k chybě. <span style="font-style: italic;">(Úplný horor nastane při větší změně webu,
například při přesouvání adresářů).</span><br>
</p>
<p>Aby se to nestalo, povězme si rovnou, že PHP umožňuje přístup k celé
řadě tzv. předdefinovaných proměnných. O polích $_REQUEST, $_GET a
$_POST
jsme již mluvili, ale existují i jiná. Třeba pole $_SERVER, které
webový server vytváří, aby Vám poskytl nějaké informace o sobě a
prostředí. A právě jedním z užitečných prvků tohoto pole je prvek
$_SERVER["PHP_SELF"], který vrací cestu a aktuálnímu PHP skriptu
relativně ke kořenové složce webu (ne systému (!!!)). Takže, namísto
toho, abychom napříště psali</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;form method="POST"
action="cesta/nazev_skriptu.php"&gt;
<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>budeme raději psát do definice formuláře něco ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;form method="POST"
action="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>což se pochopitelně bude týkat jen a pouze situace, kdy máme
definici formuláře a kód jej zpracovávající v jednom souboru.<br>
</p>
<a name="000110"></a><h2>Formulář se zaškrtávacími políčky</h2>
<p>U zaškrtávacích políček ve formulářích je situace trochu náročnější
než u textových polí. Náročnější o to, že při definici formuláře může
být políčko ve výchozím stavu buďto zaškrtnuté nebo nezaškrtnuté. To
ještě není tak zlé, horší je, že HTML definuje pro "zaškrtnutost"
políčka atribut CHECKED, zatímco pro nezaškrtnuté políčko nic. Mějme
například formulář, ve kterém budeme požadovat po uživateli, aby
zaškrtnul, o které rubriky serveru LINUXSOFTu bude mít zájem. Kontrola
bude spočívat v tom, že (čistě z výukových důvodů) bude muset uživatel
zaškrtnout všechna políčka.
Může to vypadat přibližně takto (ukázka je zkrácena, celý skript viz
odkaz):</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">true</font><font color="#007700">;
<br>
&nbsp;&nbsp;if (!empty(</font><font color="#0000bb">$_POST</font><font color="#007700">))
<br>
&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (empty(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"chkPHP"</font><font color="#007700">]) || empty(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"chkDistribuce"</font><font color="#007700">]) || empty(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"chkClanky"</font><font color="#007700">]))
<br>
&nbsp;&nbsp;&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Špatně!
Musí se Vám líbit všechno !!!"</font><font color="#007700">;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;else
<br>
&nbsp;&nbsp;&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">// atd...
<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">}
<br>
&nbsp;&nbsp;}
<br>
if (</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">):</font><font color="#0000bb">?&gt;
<br>
</font>&lt;form method="POST" action="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;
<br>
&nbsp;&nbsp;&lt;p&gt;&lt;input type="checkbox" name="chkPHP"
value="PHP" <br>
&nbsp;&nbsp;<font color="#0000bb">&lt;?</font><font color="#007700">echo
empty(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"chkPHP"</font><font color="#007700">])? </font><font color="#dd0000">""</font><font color="#007700">:</font><font color="#dd0000">"CHECKED"</font><font color="#0000bb">?&gt;</font>
&gt;
<br>
&nbsp;&nbsp;Líbí se mi seriál o PHP.&lt;/p&gt;
<br>
&nbsp;&nbsp;&lt;!-- atd... --&gt;
<br>
&nbsp;&nbsp;&lt;p&gt;&lt;input type="submit" value="Odeslat"
name="odeslano"&gt;&lt;/p&gt;
<br>
&lt;/form&gt;
<br>
<font color="#0000bb">&lt;?</font><font color="#007700">endif;</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/27_1.html" target="_blank">Ukázat
celý skript</a></p>
<p>Když si uvědomíme všechny souvislosti, není to zas až tak složité.
Jelikož PHP odesílá data ze zaškrtávacího políčka pouze v případě, že
je zaškrtnuto, můžeme tvrdošíjně požadovat všechna políčka pomocí
trojice testů empty(). A v definici formuláře si můžete všimnout, že
pomocí ternálního operátoru při zobrazení formuláře posíláme buď to
atribut CHECKED, nebo nic.<br>
</p>
<a name="000111"></a><h2>Pole zaškrtávacích políček</h2>
<p>(Tedy, to je nadpis, musím uznat). Raději hned vysvětlím, o co jde.
Někdy, když máme ve formuláři více zaškrtávacích políček, je lepší je
zpracovávat jako pole hodnot než jako samostatné proměnné. Což lze v
PHP snadno udělat tehdy, když na to budeme při definici formuláře
myslet a zaškrtávací políčka si správně nazveme. Tedy, místo
NAME="Nazev" použijeme NAME="Nazev[]" a nazveme tak všechny přepínače
ve skupině. Připravil jsem na toto téma skript. Budeme předpokládat, že
se jedná o kus formuláře, který se Vám objeví před stažením nějakého
freewarového produktu. A jako kontrola bude sloužit to, že musíte
souhlasit minimálně s licenčními podmínkami.</p>
<p><a href="./examples/27_2.html" target="_blank">Ukázat
skript</a><br>
</p>
<p>Skript si zaslouží něco komentářů. Tak především ověřování. Protože
je proměnná $_POST["souhlasim"] pole, nemůžeme testovat hodnotu na
rovnost, ale musíme použít funkci in_array. (Jinak by nám nezbylo než
celé pole procházet ve smyčce, což je ještě delší.) Obdobné to bude v
definici
formuláře. Pamatujte na to, že proměnná $_POST je nyní pole obsahující
pole! V <a href="#000032">díle o polích</a>
jsem Vás varoval, že to je možné, tady vidíte, že je to skutečně tak. <br>
</p>
<a name="000112"></a><h2>Formulář s přepínači</h2>
<p>To, co bylo řečeno o zaškrtávacích políčcích, platí obecně i na
přepínače
(Option buttons). S tím rozdílem, že u sady přepínačů by měla být jako
výchozí volba (CHECKED) označena <span style="font-weight: bold;">VŽDY
PRÁVĚ JEDNA</span> možnost. Nemusíte se vůbec rozpakovat a můžete dát
několika prvkům &lt;INPUT TYPE=RADIO&gt; stejný atribut NAME (bez
použití pole), protože
ve skriptu bude tak jako tak platit jen jedna volba. Čili,
následujcí definice formuláře je zcela v pořádku:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;form method="POST"
action="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;
<br>
&nbsp;&nbsp;&lt;p&gt;&lt;input type="radio" name="plat"
value="18000"&gt;Chci plat 18000&lt;/p&gt;
<br>
&nbsp;&nbsp;&lt;p&gt;&lt;input type="radio" name="plat" value="19000"
CHECKED&gt;Chci plat 19000&lt;/p&gt;
<br>
&nbsp;&nbsp;&lt;p&gt;&lt;input type="radio" name="plat"
value="20000"&gt;Chci plat 20000&lt;/p&gt;
<br>
&nbsp;&nbsp;&lt;p&gt;&lt;input type="submit" value="Odeslat"
name="odeslano"&gt;&lt;/p&gt;
<br>
&lt;/form&gt;
<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Neboli, vždy bude existovat jen jen jedna hodnota $_POST["plat"].
Není důvod si přepínače pojmenovávat navzájem odlišnými jmény.<br>
</p>
<a name="000113"></a><h2>Formulář s rozevíracím seznamem</h2>
<p>Rozevírací seznam Vám umožňuje vybrat jednu nebo více hodnot z
předem daného výběru. Jednoduše řečeno - pokud Vám umožňuje vybrat
jednu hodnotu, platí na něj víceméně postřehy týkající se přepínačů. A
pokud Vám umožňuje zadat více hodnot, platí na něj věci, které jsme
prozradili u zaškrtávacích políček, včetně toho machrování s poli.
<br>
</p>
<p>Časem zjistíte, že se Vám některé rozevírací seznamy neustále
opakují.
Není žádný problém vytvořit si funkci pro definici například
rozevíracího seznamu pro zobrazení měsíce v roce. Mohlo by se to
odvíjet v tomto duchu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
</font><font color="#007700">function </font><font color="#0000bb">Mesice</font><font color="#007700">()
<br>
{
<br>
&nbsp; </font><font color="#0000bb">$mesice</font><font color="#007700">=array(</font><font color="#0000bb">1</font><font color="#007700">=&gt;</font><font color="#dd0000">"leden"</font><font color="#007700">,</font><font color="#dd0000">"únor"</font><font color="#007700">, </font><font color="#dd0000">"březen"</font><font color="#007700">, </font><font color="#dd0000">"duben"</font><font color="#007700">, </font><font color="#dd0000">"květen"</font><font color="#007700">, </font><font color="#dd0000">"červen"</font><font color="#007700">, </font><font color="#dd0000">"červenec"</font><font color="#007700">, </font><font color="#dd0000">"srpen"</font><font color="#007700">, </font><font color="#dd0000">"září"</font><font color="#007700">, </font><font color="#dd0000">"říjen"</font><font color="#007700">, </font><font color="#dd0000">"listopad"</font><font color="#007700">, </font><font color="#dd0000">"prosinec"</font><font color="#007700">);
<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;SELECT&gt;"</font><font color="#007700">;
<br>
&nbsp; for (</font><font color="#0000bb">$i</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">;</font><font color="#0000bb">$i</font><font color="#007700">&lt;=</font><font color="#0000bb">12</font><font color="#007700">;</font><font color="#0000bb">$i</font><font color="#007700">++) echo </font><font color="#dd0000">"</font><font color="#007700">\t</font><font color="#dd0000">&lt;OPTION VALUE=$i&gt;"</font><font color="#007700">.</font><font color="#0000bb">$mesice</font><font color="#007700">[</font><font color="#0000bb">$i</font><font color="#007700">].</font><font color="#dd0000">"&lt;/OPTION&gt;\n"</font><font color="#007700">;
<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/SELECT&gt;"</font><font color="#007700">;
<br>
}
<br>
</font><font color="#0000bb">?&gt;
<br>
</font>&lt;FORM&gt;
<br>
&nbsp;&nbsp;<font color="#0000bb">&lt;?Mesice</font><font color="#007700">()</font><font color="#0000bb">?&gt;
<br>
</font>&lt;/FORM&gt;</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Příště se v našem seriálu podíváme na nějaké postřehy pro práci s
formuláři, které se Vám budou hodit (nejen) v PHP.</p>

<a name="000114"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (27) - Příklady na formuláře</h2>
			<p class="perex">Pojďme se podívat na několik praktických příkladů, jak využít formuláře a PHP.
				<br>
			</p>
			<p>Dnes
si ukážeme několik praktických příkladů, jak využít formuláře v PHP.
Podíváme se na to, jak si můžeme pomoci cizí prací a jak si ulehčit
život při vyhledávání nápovědy k jazyku PHP.
</p>
<a name="000115"></a><h2>Příživníci</h2>
<p>Následující věc se až tak netýká samotného PHP jako formulářů obecně
- pokud víte jak formuláře fungují, můžete si sestavit formulář, který
bude zpracovávat někdo jiný. Tak například, pokud se dobře zadíváte na
titulní stránku Linuxsoftu, zjistíte, že obsahuje několik formulářů -
formulář pro přihlášení uživatele, formulář pro vyhledávání ve
článcích, vyhledávání software a podobně. Když si necháte zobrazit
zdrojový kód titulní stránky Linuxsoftu v prohlížeči,&nbsp; najdete tam
například následující formulář:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;div
class="sub_title_orange"&gt;
<br>
&nbsp;&nbsp;&lt;img alt="&amp;gt;" height="15" width="15"
src="img/sipka2.png"&gt;
<br>
&nbsp;&nbsp;Vyhledávání článků
<br>
&lt;/div&gt;
<br>
&lt;div align="center" class="menu" style="padding-top: 7px;
padding-bottom: 7px;"&gt;
<br>
&nbsp;&nbsp;&lt;form action="http://www.linuxsoft.cz/article_list.php"
method="get"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input name="search_article" value=""
size="20" type="text"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input name="odesli" value="Hledat"
type="submit"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;br&gt;
<br>
&nbsp;&nbsp;&lt;/form&gt;
<br>
&lt;/div&gt;
<br>
</font></code></div>
<!-- Zaza PHP kód END -->


<p>Když budete
dávat příživnické formuláře na svoje vlastní stránky, měli byste si
nicméně uvědomit několik věcí:<br>
</p>
<ul>
  <li>Atribut action v tagu FORM je lepší zadat absolutně, tedy včetně
http://www.nejakyserver.domena.</li>
  <li>Pakliže je formulář odeslán skriptu php, musí být s php schopen
pracovat cílový server (ne tedy nutně ten, z něhož je formulář odesílán)</li>
  <li>Když se spoléháte na cizí služby, počítejte s tím, že to nemusí
fungovat na 100%. Kdoví, zda stránka
http://www.linuxsoft.cz/article_list.php
bude existovat ještě zítra - majitel webu se například může rozhodnout
ji přejmenovat.</li>
  <li>Někdy mohou s využíváním cizích formulářů souviset licenční nebo
právní otázky, takže je dobré na to myslet.</li>
</ul>
<p>Příkladů na příživnické formuláře by se dala vymyslet celá řada -
můžete mít na stránce formuláře, které bude zpracovávat vyhledávač,
formuláře pro nalezení telefonního čísla, na ověření IČO, formuláře na
přihlášení k nějaké službě a podobně.<br>
</p>
<a name="000116"></a><h2>Náš příklad</h2>
<p>Snažil jsem se přijít na nějaký neotřepaný příklad s formuláři -
tady jeden je. Chtějme mít formulář, který bude obsahovat rozevírací
seznam s příkazy v PHP, které jsme se již naučili. S tím, že po jeho
odeslání se nám zobrazí příslušná stránka nápovědy v PHP. Na stránkách
PHP je podobný formulář, ale tam se musejí příkazy napsat. My je budeme
mít přichystané.<br>
</p>
<p>Seznam příkazů si pro jednoduchost ukázky zadáme do nějakého pole.
To může být celkem rozsáhlé, nám bude pro pochopení stačit následující:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
$prikazy</font><font color="#007700">=Array(</font><font color="#dd0000">"echo"</font><font color="#007700">, </font><font color="#dd0000">"print"</font><font color="#007700">, </font><font color="#dd0000">"date"</font><font color="#007700">, </font><font color="#dd0000">"print_r"</font><font color="#007700">, </font><font color="#dd0000">"sort"</font><font color="#007700">);
<br>
</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V PHP manuálu jsou jednotlivé funkce a příklady uvedeny na
stránkách, které mají logické názvy. Takže například funkce sort má
českou stránku nápovědy na <a href="http://cz.php.net/manual/cs/function.sort.php">http://cz.php.net/manual/cs/function.sort.php</a>
a tak dále. Skript pro vyhledávání by tedy mohl vypadat třeba nějak
takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
</font><font color="#007700">function </font><font color="#0000bb">Prikazy</font><font color="#007700">()
<br>
{
<br>
&nbsp;&nbsp;</font><font color="#ff8000">//zkráceno
<br>
</font><font color="#007700">} <br>
if (empty (</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"odeslat"</font><font color="#007700">]))
<br>
{
<br>
&nbsp;&nbsp;</font><font color="#0000bb">?&gt;
<br>
</font>&nbsp;&nbsp;&lt;form method="POST" action="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;
<br>
&nbsp;&nbsp;Vyber příkaz:&amp;nbsp; <font color="#0000bb">&lt;? Prikazy</font><font color="#007700">(); </font><font color="#0000bb">?&gt;
<br>
</font>&nbsp;&nbsp;&lt;input name="odeslat" value="Odeslat"
type="submit"&gt;
<br>
&nbsp;&nbsp;&lt;/form&gt;
<br>
&nbsp;&nbsp;<font color="#0000bb">&lt;?
<br>
</font><font color="#007700">}
<br>
else <br>
{
<br>
&nbsp;&nbsp;</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"Location:
http://cz.php.net/manual/cs/function."</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"prikaz"</font><font color="#007700">].</font><font color="#dd0000">".php"</font><font color="#007700">);
<br>
}
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/28_funkce.html" target="_blank">Ukázat
celý skript</a></p>
<p>A můžeme si v něm všimnout následujících věcí: Formulář se skládá z
rozevíracího seznamu a odesílacího tlačítka. Seznam plníme pomocí
funkce Prikazy, která (je to vidět při zobrazení celého skriptu) pole
příkazů nejprve definuje a pak řadí. Protože při zobrazování
manuálových stránek php jsou případná podtržítka nahrazena pomlčkami,
je tam použito nahrazování pomocí funkce str_replace.<br>
</p>
<p>Jelikož při odesílání tohoto formuláře prakticky uživatel nemůže
udělat chybu, úplně jsme vynechali kontroly odeslaných dat. Je jisté,
že něco zkrátka odejít musí, a pokud neuděláme chybu v názvu funkce,
mělo by to fungovat.<br>
</p>
<p>Jakmile se stránka odešle, máme k dispozici proměnnou $_POST
["prikaz"], která obsahuje vybraný příkaz. A byl-li formulář odeslán,
pokusíme se ji zobrazit. Pro nás dosuh neznámá funkce Header() funguje
tak, že se pokusí propašovat do záhlaví požadavku nějaké svoje věci a
ještě ji budeme rozebírat. Momentálně stačí, když si řekneme, že volání
funkce header v tomto tvaru způsobí, že se nenatáhne stránka, na níž
tento příkaz je (tedy např.
http://www.linuxsoft.cz/php/examples/28_funkce.php), ale natáhne se
stránka uvedená v řetězci Location.<br>
</p>
<p>Skript lze pochopitelně rozšiřovat, například seznam funkcí které má
rozevírací seznam zobrazit nemusí být uložen v poli, ale někde jinde.
Zrovna mě napadá, že by klidně mohl být v textovém souboru. Což nás
přivádí k dalšímu dílu PHP seriálu, který se bude právě souborům
věnovat.</p>

<a name="000117"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (28) - Chybovati je lidské</h2>
			<p class="perex">Chybovat je lidské. A taky to dobře jde
počítačům. Podívejme se, jak to zvládá PHP a jak ho to odnaučit.
				<br>
			</p>
			<p><span style="font-style: italic;">Pozn.: Chybovat je opravdu lidské.
Minule jsem slíbil v závěru článku, že se budeme příště zabývat prací
se soubory. Takže, moc se omlouvám, bude to až v dalším díle. Úplně mi
vypadl tento díl seriálu z hlavy ;-)</span></p>
<p>Můrou každého programátora jsou chyby v jeho programech. Nemyslím
si, že by se daly napsat programy bez chyb. Ale správným přístupem k
problému se nám může podařit chyby minimalizovat. Podívejme se, jak na
to můžeme jít v PHP.</p>
<p>V programech se běžně vyskytuje pět druhů chyb. To se týká i PHP.
Zkusme si je rozebrat jeden typ za druhým, ukázat si příklady a dát si
nějaké návody, jak se takovým chybám buďto vyhnout, nebo je alespoň
utajit před uživateli.<br>
</p>
<a name="000118"></a><h2>Syntaktické chyby</h2>
<p>Syntaktické chyby jsou nejjednodušší na vytvoření, ale taky na
odhalení. Syntaktická chyba je všechno, co způsobí neplatný kód PHP.
Tak například můžete zapomenout středník nebo uvozovky. Následující kód
je špatně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$uzivatel</font><font color="#007700">=</font><font color="#dd0000">"Petr"</font><font color="#007700">;<br>
</font><font color="#0000bb">$server</font><font color="#007700">=</font><font color="#dd0000">"Linuxsoft"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Uživatel $uzivatel je vítán na
serveru $server!&lt;BR&gt;"<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Máte
novou poštu"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a při pokusu jej spustit dostaneme hlášení od PHP ve smyslu:</p>
<p><b>Parse error</b>: parse error, unexpected T_ECHO, expecting ',' or
';' in <b>D:\Pokus\source.php</b> on line <b>5</b></p>
<p>PHP je na toto poměrně hodný jazyk - řekne nám, na jakém řádku chyba
je a co se mu nezdá. Mimochodem o toho čísla řádku si může trochu
vymýšlet - sami přece vidíte, že ten zapomenutý středník je na řádku 4.
Ale PHP to zjistí až v momentě, kdy narazí na příkaz echo, který je o
řádek níž. Syntaktické chyby se odnaučíte častým používáním PHP. Časem
to pro Vás nebude problém.<br>
</p>
<a name="000119"></a><h2>Sémantické chyby</h2>
<p>To už jsou horší chyby. Sémantická chyba vznikne u kódu, který
projde parsováním, ale nepůjde spustit. Tak mějme například následující
kód:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$retezec</font><font color="#007700">=</font><font color="#dd0000">"Dneska
je ale zima..."</font><font color="#007700">;<br>
</font><font color="#0000bb">explode </font><font color="#007700">(</font><font color="#0000bb">$retezec</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jelikož funkce explode vyžaduje ne jeden ale dva parametry,
zaprotestuje pochopitelně PHP způsobem:</p>
<p>
<b>Warning</b>: Wrong parameter count for explode() in <b>D:\Pokus\source.php</b>
on line <b>3<br>
</b></p>
<p>Rovněž tyto chyby se dají poměrně solidně najít a opravit. Bylo by
ideální, kdybyste si před uvedením aplikace do provozu mohli být jisti,
že jste testovali každý kus kódu (třeba každou větev v podmínce),
protože pak byste se sémantických chyb víceméně nemuseli bát. K tomu v
reálných aplikacích slouží testovací plány, které se snaží navrhnout
sadu testovacích rutin tak, aby se prošel celý kód. To je docela věda a
určitě to je mimo náplň našeho seriálu.<br>
</p>
<a name="000120"></a><h2>Logické chyby</h2>
<p>Takže kód běží, aplikace nepadá - může nás ještě vůbec něco
překvapit? Ano, jsou to logické chyby. PHP je poměrně benevolentní
jazyk - což taky znamená, že Vám umožní kdejakou věc, kterou by Vám
přísnější jazyky zakázaly. Tak například byste mohli podlehnout
pokušení použít pro sloučení řetězců plusítko (+) namísto tečky (.).
Následující kód je správný syntakticky i sémanticky - a přesto je
výsledek logicky špatný:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$jmeno</font><font color="#007700">=</font><font color="#dd0000">"Johny"</font><font color="#007700">;<br>
</font><font color="#0000bb">$prijmeni</font><font color="#007700">=</font><font color="#dd0000">"Wolker"</font><font color="#007700">;<br>
</font><font color="#0000bb">$cele </font><font color="#007700">= </font><font color="#0000bb">$jmeno</font><font color="#007700">+</font><font color="#dd0000">" "</font><font color="#007700">+</font><font color="#0000bb">$prijmeni</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$cele</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Tady jsme se pokusili pracovat s řetězci jako s čísly. Na což PHP
zareagovalo přetypováním a převedlo vše na čísla. Výsledkem je nula.
Logické chyby bývá obtížné vystopovat. Projevují se totiž pouze někdy a
v systému jsou pak schopny nadělat pěknou paseku. Kdybyste například v
uvedeném příkladu doufali, že proměnnou $cele časem použijete jako
logickou proměnnou, je neštěstí na světě. Obecná rada je:
Testujte jednotlivé kusy kódu předtím, než je sestavíte dohromady. Čím
větší celek, tím hůř se na chyby přichází.</p>
<a name="000121"></a><h2>Chyby v samotném PHP</h2>
<p>Tím, že PHP používají milióny lidí, se už mnoho chyb vychytalo.
Přesto Vás PHP může nepříjemně překvapit samo o sobě. Následující kód
ilustruje, že PHP neumí v určitých případech počítat kalendářní dny,
neboť následující pondělí zcela určitě není v neděli:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$jmeno</font><font color="#007700">=</font><font color="#dd0000">"Johny"</font><font color="#007700">;<br>
</font><font color="#0000bb">$prijmeni</font><font color="#007700">=</font><font color="#dd0000">"Wolker"</font><font color="#007700">;<br>
</font><font color="#0000bb">$cele </font><font color="#007700">= </font><font color="#0000bb">$jmeno</font><font color="#007700">+</font><font color="#dd0000">" "</font><font color="#007700">+</font><font color="#0000bb">$prijmeni</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$cele</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;&lt;?php<br>
&nbsp;&nbsp;$tStamp </font><font color="#007700">= </font><font color="#0000bb">mktime </font><font color="#007700">(</font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">10</font><font color="#007700">, </font><font color="#0000bb">27</font><font color="#007700">, </font><font color="#0000bb">2004</font><font color="#007700">);<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"tStamp="</font><font color="#007700">. </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"l d.m.Y"</font><font color="#007700">, </font><font color="#0000bb">$tStamp</font><font color="#007700">). </font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$strtotime_timestamp </font><font color="#007700">= </font><font color="#0000bb">strtotime </font><font color="#007700">(</font><font color="#dd0000">"next Monday"</font><font color="#007700">, </font><font color="#0000bb">$tStamp</font><font color="#007700">);<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"result="</font><font color="#007700">. </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"l d.m.Y"</font><font color="#007700">, </font><font color="#0000bb">$strtotime_timestamp</font><font color="#007700">).</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Pokud narazíte na chybu v PHP, je rozumné ji popsat autorům, kteří
se ji pokusí odstranit. K tomu slouží <a target="_blank" href="http://bugs.php.net/">webové rozhraní</a>. Dokud ale chyba
nebude opravena, nemůžete toho dělat moc; já se vždy pokusím kód
přepsat, většinou to funguje.<br>
</p>
<a name="000122"></a><h2>Chyby mimo PHP</h2>
<p>Chyba může být i mimo prostředí PHP (ale vysvětlete to
uživatelům...). Vymyslet konkrétní příklad mě zrovna nenapadá, ale může
se jednat o chyby způsobené neexistujícími soubory, nepřístupnými
databázemi, chybějícími skripty začlenění, nedostatečným místem na
disku, špatnými odpověďmi http serveru a podobně. Obecná zásada je:
"nikomu nevěřit". Psát programy tak, abychom přinejmenším věděli, <span style="font-weight: bold;">kde </span>a <span style="font-weight: bold;">jaká </span>chyba nastala. S tím souvisí
následující otázka:</p>
<a name="000123"></a><h2>Jaké chyby PHP hlásí?</h2>
<p>PHP hlásí 4 typy chyb, které ale přesně nezapadají do skupin chyb
popsaných výše. Je to takhle: <br>
</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Úroveň chyby<br>
      </td>
      <td style="vertical-align: top;">Význam<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Chyby čtení (Parse)<br>
      </td>
      <td style="vertical-align: top;">To jsou de facto syntaktické
chyby<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Závažné chyby (Fatal)<br>
      </td>
      <td style="vertical-align: top;">To jsou buď sémantické chyby,
nebo chyby prostředí, z nichž se PHP nedokáže zotavit (například
nedefinovaná funkce).<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Varování (Warnings)<br>
      </td>
      <td style="vertical-align: top;">To jsou chyby podobné závažným,
ale zároveň si PHP myslí, že může pokračovat dál. Většinou to ale
stejně není pravda.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Upozornění (Notices)<br>
      </td>
      <td style="vertical-align: top;">Bývá většinou v reále vypnuto.
Méně podstatné chyby, například neinicializované proměnné.<br>
      </td>
    </tr>
  </tbody>
</table>
<a name="000124"></a><h2>Co s chybami?</h2>
<p>Programátor by se měl nad chybami zamýšlet trochu jako uživatel.
Uživatelé chyby nevidí rádi. Nicméně - někdy se dá použít metoda "co
oko nevidí, srdce nebolí". Mějme například nějakou funkci pro zvýšení
hodnoty počitadla, která selže. Musí se to uživatel dozvědět? Vlastně
vůbec ne. Pokud požijeme před voláním funkce operátor @ (zavináč) ,
chybové hlášení v PHP bude potlačeno. Takže, můžete napsat něco ve
smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">@</font><font color="#0000bb">ZvysHodnotuPocitadla</font><font color="#007700">();<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Pozor, nefunguje to u příkazů, jen u funkcí. To, jaké chyby bude PHP
hlásit se dá omezit pomocí funkce error_reporting. To, že se budou
chyby zapisovat pro případné další zkoumání, zajišťuje funkce
error_log. Systém ovšem musí být nastaven pro její použití.<br>
</p>
<p>Samozřejmě, že metodu "strkání hlavy do písku" nelze použít vždy.
Pakliže nastane chyba při připojování se k databázi, a bude se jednat o
elektronický obchod, budeme asi muset s tím něco dělat, neb bez
databáze zákazník nenakoupí. Takové chyby poznáme. Většina funkcí pro
práci s databázemi totiž vrací nějakou hodnotu, když selžou. Tuto
hodnotu můžeme testovat. Pro ilustraci může sloužit následující kus
kódu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">if (</font><font color="#0000bb">ZkusSePripojitKDatabazi</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//jedeme dál<br>
&nbsp;&nbsp;</font><font color="#007700">}<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//chyba.
Informujeme nebohého uživatele<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">echo </font><font color="#dd0000">"Váš požadavek nyní nelze vyřídit."</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Kód je jasný. Naše skvělá funkce ZkusSePripojitKDatabazi může vrátit
TRUE nebo FALSE. Pokud to nedopadlo správně, dostaneme se do druhé
větve podmínky. Je dobré se uživateli nějak diplomaticky omluvit. Tady
Vám může pomoci několik programátorsko - psychologických
pravidel: <br>
</p>
<ul>
  <li>Nepoužívejte slovo chyba, když dojde k chybě. Přiznali byste, že
program je špatně napsaný. Existují výjimky, nestandardní situace, ale
nikdy chyby.</li>
  <li>Ze stejného důvodu se tam nesmí objevit ani slovo error.</li>
  <li>Snažte se být slušní. Uživatel za chybu nikdy nemůže. I když ji
způsobil (třeba špatným vstupem).</li>
  <li>Snažte se být nenápadní. Vytvořte si funkci, která chybu vysvětlí
pomocí stejných prvků designu, jako kdyby se operace povedla. Mám tím
třeba na mysli, že nutně nemusíte psát chyby červeně na prázdnou
stránku, když byste dost dobře mohli použít pozadí, které tam máte
normálně.</li>
  <li>Snažte se vysvětlit, co může uživatel udělat (přihlásit se za 5
minut, zavolat na technickou podporu, vyskočit z okna a podobně)</li>
  <li>Nepište tam takové věci jako čísla řádku, chybovou hlášku PHP a
podobně. Uživatele to nezajímá, on má chybu.<br>
  </li>
</ul>
<p><span style="font-style: italic;">Příště se budeme věnovat už
opravdu práci se soubory.</span></p>
<a name="000125"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (29) - Soubory a adresáře</h2>
			<p class="perex">PHP umí pracovat se soubory operačního systému. Zjistěme, k čemu to může být dobré a jak toho využít.
				<br>
			</p>
			<p>Potřeba pracovat přímo s jednotlivými soubory operačního systému
není v dnešní době až tak palčivá. Mnoho informací lze totiž ukládat v
databázích, což může být jak rychlejší, tak i bezpečnější než používání
souborů. Přesto se ale příkazy PHP pro práci se soubory zabývat budeme
- jednak to je jednoduché a jednak Vám to může v některých případech
posloužit lépe než co jiného.<br>
</p>
<a name="000126"></a><h2>Readfile</h2>
<p>Především si osvětleme funkci, která umí vkládat soubory do stránky.
Není to funkce include, o které jsme již v našem seriálu mluvili.
Funkce include (a require, rovněž i require_once) vkládají soubory php
a bývá v nich téměř vždy zdrojový kód php. Mám na mysli funkci,
která "tupě" otevře soubor a "vypustí" jej do výstupního proudu. V PHP
taková funkce existuje a jmenute se readfile(). Takže, máme-li na
serveru textový soubor 29_text.txt, můžeme napsat:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;head&gt;
<br>
&lt;meta http-equiv="Content-Type" content="text/html;
charset=utf-8"&gt;
<br>
&lt;/head&gt;
<br>
<font color="#0000bb">&lt;?readfile</font><font color="#007700">(</font><font color="#dd0000">"29_text.txt"</font><font color="#007700">);</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->

<p>Skutečně je to tak jednoduché (a to ještě hlavička je tam jen kvůli
tomu, aby
se stránka zobrazila správně česky). Někdy programátoři přesně nevědí,
zda může takto vložený soubor obsahovat tagy nebo instrukce PHP. Takže,
je to takhle:<br>
</p>
<ul>
  <li>Jestliže soubor načtený pomocí readfile obsahuje formátovácí tagy
jazyka HTML, není to problém. Jestliže napříkad v souboru je tag
&lt;B&gt;, bude skutečně následující text tučně, protože prohlížeči je
srdečně jedno, jak byla informace kterou má zobrazit získána.</li>
  <li>Jestliže soubor načtený pomocí readfile obsahuje kód PHP, tento
kód se NEPROVEDE. Soubor je totiž tupě načten, ale NENÍ zpracován
parserem PHP. Neboli, všecho včetně informací mezi znaky &lt;? a ?&gt;
je skutečně vypsáno do prohlížeče. Váš prohlížeč možná informace mezi
značkami &lt;? a ?&gt; nezobrazí, ale
při zobrazení zdrojového kódu stránky se na ně můžete podívat.<br>
  </li>
</ul>
<a name="000127"></a><h2>Máte právo nevypovídat</h2>
<p>Pro uživatele GNU/Linuxu bude asi následující informace známá, pokud
jste zvyklí na WINDOWS, zapište si ji za uši: Funkce readfile
pochopitelně respektuje nastavení přístupových práv systému. Takže,
pokud uživatel, pod nímž běží PHP nemá k souboru minimálně práva na
čtení, readfile selže. Když soubor přemísťujete na server, nastavení
jeho práv může být ovlivněno několika faktory. Jestliže máte na serveru
systémový účet, bude se to řídit tím, co Vám dovolil administrátor.
Používáte-li FTP, může být přístup k nahranému souboru ovlivněn
nastavením FTP serveru a/nebo FTP klienta a tak dále. Poučení je v tom,
že budete-li potřebovat číst soubory pomocí readfile, měli byste si
ověřit nejen to, zda existují, ale rovněž to, zda je <span style="font-style: italic;">můžete </span>číst.<br>
</p>
<a name="000128"></a><h2>Adresáře</h2>
<p>PHP umí pracovat rovněž s celými adresáři. Poměrně častá úloha je
například zobrazit názvy souborů z určitého adresáře s tím, že
názvy souborů jsou zároveň odkazy. Takle lze naprogramovat něco jako
on-line správce souborů. K úlohám podobného typu slouží několik příkazů
pro
práci s adresářem. Především je to třída dir, která obsahuje metody
read, rewind a close. Takže, obsah složky bychom mohli vypsat
následujícím skriptem:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
$slozka </font><font color="#007700">= </font><font color="#0000bb">dir</font><font color="#007700">(</font><font color="#dd0000">"29"</font><font color="#007700">);
<br>
while(</font><font color="#0000bb">$soubor</font><font color="#007700">=</font><font color="#0000bb">$slozka</font><font color="#007700">-&gt;</font><font color="#0000bb">read</font><font color="#007700">()) {
<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$soubor</font><font color="#007700">==</font><font color="#dd0000">"." </font><font color="#007700">|| </font><font color="#0000bb">$soubor</font><font color="#007700">==</font><font color="#dd0000">".."</font><font color="#007700">) continue;
<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;a href=</font><font color="#007700">\"</font><font color="#dd0000">29/$soubor</font><font color="#007700">\"</font><font color="#dd0000">&gt;"</font><font color="#007700">.</font><font color="#0000bb">$soubor</font><font color="#007700">.</font><font color="#dd0000">"&lt;/a&gt;&lt;br&gt;\n"</font><font color="#007700">;
<br>
}
<br>
</font><font color="#0000bb">$slozka</font><font color="#007700">-&gt;</font><font color="#0000bb">close</font><font color="#007700">(); <br>
</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->

<p>Je to celkem přímočaré. Zobrazujeme složku, která je umístěna ve
stejné složce jako náš skript a jmenuje se 29. Metoda read třídy dir
vrátí název jednoho souboru ze složky nebo FALSE v případě, kdy je
načtena již celá složka. Jelikož by výpis obsahoval i adresáře "."
(aktuální adresář) a ".." (nadřízený adresář), nebudeme tyto
položky&nbsp; zobrazovat. A řádek s echo je jen vypsání názvu souboru s
tím,
že je to zároveň i odkaz.<br>
</p>
<p>Jestliže se obsah složky změní, nemusí se skript upravovat. Načte
vždy to, co složka obsahuje v době provádění skriptu.<br>
</p>
<a name="000129"></a><h2>Další šikovné příkazy</h2>
<p>V PHP můžete zobrazit absolutní cestu pomocí příkazu getcwd.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
</font><font color="#007700">echo </font><font color="#0000bb">getcwd</font><font color="#007700">();
<br>
</font><font color="#0000bb">?&gt;
<br>
</font><br>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Můžete rovněž rozložit celý název souboru na cestu, název a příponu.
Pokud budete chtít, je možné vypsat zvlášť cestu, název a přípanu
souboru, který je právě spuštěn. K
tomu slouží funkce dirname a basename. </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Cesta
k souboru skriptu: "</font><font color="#007700">.</font><font color="#0000bb">dirname</font><font color="#007700">(</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SCRIPT_FILENAME"</font><font color="#007700">]).</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;
<br>
</font><font color="#0000bb">$soubor</font><font color="#007700">=</font><font color="#0000bb">explode</font><font color="#007700">(</font><font color="#dd0000">"."</font><font color="#007700">, </font><font color="#0000bb">basename</font><font color="#007700">(</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SCRIPT_FILENAME"</font><font color="#007700">]));
<br>
echo </font><font color="#dd0000">"Název skriptu: "</font><font color="#007700">.</font><font color="#0000bb">$soubor</font><font color="#007700">[</font><font color="#0000bb">0</font><font color="#007700">].</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;
<br>
echo </font><font color="#dd0000">"Přípona skriptu: "</font><font color="#007700">.</font><font color="#0000bb">$soubor</font><font color="#007700">[</font><font color="#0000bb">1</font><font color="#007700">].</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;
<br>
</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->

<p><span style="font-style: italic;">Poznámka: Nemůžete použít
proměnnou $_SERVER["PHP_SELF"], protože ta vrací cestu relativně ke
kořenové složce webu, nikoli systému.<br>
</span></p>
<p>Existuje celá řada dalších funkcí pro práci se soubory. Příště se
podíváme na "nízkoúrovňové" práce se soubory - na vytvoření, zápis a
čtení ze souboru. Vytvoříme si taky nějaký příklad - bude to počítadlo
přístupů.</p>
<a name="000130"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (30) - Počitadlo pomocí souborů</h2>
			<p class="perex">Dnes se podívame na to, jak umí PHP soubory na serveru přímo vytvářet. S praktickou ukázkou počitadla přístupů.
				<br>
			</p>
			<p>PHP umí soubory nejen číst a vkládat do skriptů, ale rovněž
vytvářet. To může být výhodné, pokud potřebujeme uložit nějaké
informace na straně serveru nebo pokud vytváříme aplikaci, která ke své
činnosti potřebuje zapisovat do souborového systému.<br>
</p>
<p>Pro vytváření a pohyb v souborech slouží v PHP sada příkazů. Příkaz
<a href="http://cz.php.net/manual/en/function.fopen.php">fopen</a>
soubor otevře, <a href="http://cz.php.net/manual/en/function.fread.php">fread</a>
z něj přečte data, <a href="http://cz.php.net/manual/en/function.fwrite.php">fwrite</a> do
něj data zapíše
a <a href="http://cz.php.net/manual/en/function.fclose.php">fclose</a>
jej zavře. Funkce <a href="http://cz.php.net/manual/en/function.file-exists.php">file_exists</a>
zjistí, zda daný soubor
existuje. Tady by byla všechna další teorie nudná, takže si pojďme
vytvořit něco praktického.<br>
</p>
<p>Součástí našeho webu může být malý textový soubor, který bude
obsahovat údaj o počtu shlédnutí naší stránky - takové primitivní
počítadlo. Tady je kód, který jej zrealizuje:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
define </font><font color="#007700">(</font><font color="#dd0000">"NAZEV_SOUBORU"</font><font color="#007700">, </font><font color="#dd0000">"pocitadlo.txt"</font><font color="#007700">);
<br>
if (</font><font color="#0000bb">file_exists</font><font color="#007700">(</font><font color="#0000bb">NAZEV_SOUBORU</font><font color="#007700">))
<br>
{
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$soubor</font><font color="#007700">=</font><font color="#0000bb">fopen</font><font color="#007700">(</font><font color="#0000bb">NAZEV_SOUBORU</font><font color="#007700">, </font><font color="#dd0000">"r+"</font><font color="#007700">);
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$stav</font><font color="#007700">=</font><font color="#0000bb">fread</font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">, </font><font color="#0000bb">10</font><font color="#007700">);
<br>
}
<br>
else
<br>
{
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$soubor</font><font color="#007700">=</font><font color="#0000bb">fopen</font><font color="#007700">(</font><font color="#0000bb">NAZEV_SOUBORU</font><font color="#007700">, </font><font color="#dd0000">"w"</font><font color="#007700">);
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$stav</font><font color="#007700">=</font><font color="#0000bb">0</font><font color="#007700">;
<br>
}
<br>
</font><font color="#0000bb">rewind</font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">);
<br>
</font><font color="#0000bb">fwrite</font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">,++</font><font color="#0000bb">$stav</font><font color="#007700">,</font><font color="#0000bb">10</font><font color="#007700">);
<br>
</font><font color="#0000bb">fclose</font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">);
<br>
<br>
echo </font><font color="#dd0000">"Již máme zaznamenáno $stav
přístupů!!!"</font><font color="#007700">;
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Skript sám je dobře čtivý, musíte si ovšem dát pozor na některé
drobnosti. Především jsme jako název souboru pro uložení počitadla
použili konstantu - to je velmi rozumné, protože časem třeba můžeme
chtít umístění souboru změnit a nikomu by se nechtělo přepisovat jeho
název na mnoha místech. Z programátorských fintiček jsme ještě použili <span style="font-style: italic;">preinkrementaci </span>(++$stav) a <span style="font-style: italic;">automatickou expanzi proměnné</span>
(zaznamenáno $stav přístupů). A teď k práci se souborem:<br>
</p>
<p>V zásadě mohou existovat dvě situace: Celý skript se buď spouští
poprvé, nebo již poněkolikáté. Pakliže se spouští prvně, nezbývá než
soubor s počitadlem vytvořit a výchozí stav nastavit na nulu, pokud již
počítací soubor existuje, načteme z něj aktuální stav počitadla pomocí
funkce fread. Funkce fopen přijímá povinný parametr mode, který může
nabývat následujících hodnot (zvýraznil jsem ty, které si pletu, raději
bych uvítal dvoupísmenné hodnoty):<br>
</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; width: 10%;">r<br>
      </td>
      <td style="vertical-align: top;">Soubor je otevřen pro čtení,
ukazatel je nastaven na začátek.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10%;">r+<br>
      </td>
      <td style="vertical-align: top;">Soubor je otevřen pro čtení <span style="font-weight: bold;">i pro zápis</span>, ukazatel je nastaven na
začátek.</td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10%;">w<br>
      </td>
      <td style="vertical-align: top;">Soubor je vytvořen a otevřen pro
zápis. Pokud existoval, je zkráce na nulovou délku.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10%;">w+<br>
      </td>
      <td style="vertical-align: top;">Soubor je vytvořen a otevřen pro
      <span style="font-weight: bold;">čtení i zápis</span>. Pokud
existoval, je zkráce na nulovou délku.</td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10%;">a<br>
      </td>
      <td style="vertical-align: top;">Soubor je otevřen pro
připisování. Ukazatel je nastaven na konec. Pokud neexistuje, pokusí se
PHP soubor vytvořit.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10%;">a+<br>
      </td>
      <td style="vertical-align: top;">Soubor je otevřen pro <span style="font-weight: bold;">čtení nebo připisování</span>. Ukazatel je
nastaven na konec. Pokud neexistuje, pokusí se PHP soubor vytvořit.</td>
    </tr>
  </tbody>
</table>
<p>Ještě jednou se zmíním o právech k souborům: Na úspěšné vykonání
funkce fopen musíte mít k vytvářenému nebo otevíranému souboru
dostatečná práva. Většinou je mít nebudete na komerčních webhostinzích,
protože správci nedávají uživateli, pod nímž běží PHP příliš rozsáhlá
práva. Takže, na Linuxsoftu by se Vám například vytvoření souboru
nepovedlo. Pokud byste ale měli na serveru účet, mohli byste si soubor
počitadla vytvořit ručně. Ani to Vám však nemusí fungovat, pokud nejste
uživatelem, který spouští PHP. Já jsem například musel aby příklad
fungoval soubor nejprve vytvořit, a pak změnit jeho práva tak, aby do
něj mohl zapisovat a číst z něj kdokoli.<br>
</p>
<p>A ještě něco: Pokud požadujete otevřít soubor například v režimu r+
a nemáte k tomu práva, PHP nahlásí neúspěch a nepokusí se otevřít
soubor v žádném jiném režimu (třeba, jen čtení). Myslete na to.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Stav počitadla nebude
souhlasit s číslem určujícím počet shlédnutí tohoto článku. Tam je
použita odlišná filozofie.<br>
</span></p>
<p>Možná vás napdane, co by se stalo, kdyby se do souboru pokusili
přistupovat dva uživatelé najednou. V takovém případě by naše
jednoduché počitadlo mohlo selhat. V praxi se v takovém případě
nasazuje systém zamykání souborů, který se v PHP realizuje příkazem <a href="http://cz.php.net/manual/en/function.flock.php">flock</a>.<span style="font-style: italic;"></span></p>
<p><span style="font-style: italic;"></span></p>
<p></p>
<a name="000131"></a><h2>Soubory obsahující data</h2>
<p>Častou úlohou související se zpracováním souborů je vytáhnout z nich
data (třeba data, která se budou vkládat do databáze). PHP přímo
podporuje zpracování souborů s hodnotami oddělenými středníky. Máte-li
třeba následující soubor:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">Petr;Zajíc;1. máje
6;Liberec
<br>
Franta;Jetel;Novodvorská 12;Praha
<br>
Pepa;Jouda;Pakoměřice 23;Pakoměřice</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>můžete jej rozsekat na jednotlivé hodnoty pomocí volání funkce
<a href="http://cz.php.net/manual/en/function.fgetcsv.php">fgetcsv</a>.&nbsp;
Následující ukázka to ozřejmí: </p>
<p><span style="font-style: italic;">Pozn.: Pakoměřice skutečně </span><a style="font-style: italic;" href="http://www.mapy.cz/handler.py?action=detail&amp;mapwidth=552&amp;mapheight=420&amp;tablename=cobce_web&amp;objecttype=0&amp;key=402991">existují</a><span style="font-style: italic;">.<br>
</span></p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
$radek </font><font color="#007700">= </font><font color="#0000bb">1</font><font color="#007700">;
<br>
</font><font color="#0000bb">$soubor </font><font color="#007700">= </font><font color="#0000bb">fopen </font><font color="#007700">(</font><font color="#dd0000">"30_data.csv"</font><font color="#007700">,</font><font color="#dd0000">"r"</font><font color="#007700">);
<br>
while (</font><font color="#0000bb">$data </font><font color="#007700">=
</font><font color="#0000bb">fgetcsv </font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">, </font><font color="#0000bb">1000</font><font color="#007700">)) <br>
{
<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;p&gt;Zpracovávam
řádek č.$radek: &lt;br&gt;"</font><font color="#007700">;
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$radek</font><font color="#007700">++;
<br>
&nbsp;&nbsp;foreach (</font><font color="#0000bb">$data </font><font color="#007700">as </font><font color="#0000bb">$polozka</font><font color="#007700">) <br>
&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;print </font><font color="#0000bb">$polozka</font><font color="#007700">. </font><font color="#dd0000">"&lt;br&gt;"</font><font color="#007700">;
<br>
&nbsp;&nbsp;}
<br>
}
<br>
</font><font color="#0000bb">fclose </font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">);
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Příkaz fgetcsv načte řádek a vrátí jej jako pole položek $data. Ta
následně zobrazíme pomocí funkce foreach. Fgetcsv může obsahovat
nepovinný třetí parametr, který specifikuje jiný oddělovač (třeba
tabelátor, středník a podobně).<br>
</p>
<p><span style="font-style: italic;">Pozn.: Většina databází má vlastní
rychlý způsob načítání textových souborů do tabulek, takže to tvrzení v
úvodu berte s rezervou.<br>
</span></p>
<a name="000132"></a><h2>Další možnosti</h2>
<p>Zpracování souborů v PHP zahrnuje daleko více. Za určitých okolností
je možné například:<br>
</p>
<ul>
  <li>Otevírat vzdálené soubory pomocí prtokolů HTTP nebo FTP</li>
  <li>Otevírat porty (třeba COM)</li>
  <li>Číst ze standardního vstupu nebo zapisovat na standardní výstup</li>
  <li>Soubory kopírovat, přesouvat, mazat, měnit jim práva a tak dále</li>
  <li>Soubory šifrovat</li>
</ul>
<p>My se v dalším díle našeho seriálu zaměříme na to, jak nám může PHP
pomoci při kopírování souborů na server nebo při stahování souborů ze
serveru.</p>
<a name="000133"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (31) - Upload a download souborů</h2>
			<p class="perex">Dnes si ukážeme, jak s pomocí PHP dostat soubor na server a naopak jak soubory ze serveru stahovat.
				<br>
			</p>
			<p>Úvod je trochu nadnesený. Rychle zjistíte, že nahrávání souboru na
server ani jeho stahování není záležitostí samotného PHP, jako spíše
využití některých možností, které nám nabízí HTML. Líbilo se mi ale
zařadit tuto látku do seriálu o PHP, protože často to v takových
seriálech chybí a museli bychom to hledat někde jinde. Začneme
stahováním souborů, je to jednodušší.<br>
</p>
<a name="000134"></a><h2>Stahování souborů ze serveru</h2>
<p>Prohlížeče mohou rozumět různým typům souborů. Tak například
jestliže klepnete na odkaz vedoucí na stránku html, pokusí se ji
prohlížeč najít a zobrazit. Zatímco třeba klepnutí na odkaz vedoucí
k souboru zip nejspíš povede k jeho stažení. Problém může nastat v
případě, kdy chceme prohlížeč přemluvit, aby stáhnul jako soubor něco,
co by normálně zobrazil. Například, máme na serveru soubor <a target="_blank" href="./examples/31_test.html">31_test.html</a>.
Jestliže jste kliknuli na odkaz, prohlížeč Vám ho téměř jistě zobrazil.
<br>
</p>
<p>Stáhnout jej můžete tak, že prohlížeči vysvětlíte, že má soubor
považovat za přílohu. Odkaz nepovede na samotný soubor html, ale na
soubor PHP, který nejprve přemluví prohlížeč, aby soubor stáhl, a pak
to udělá. Soubor php může vypadat následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
$soubor </font><font color="#007700">= </font><font color="#dd0000">"31_test.html"</font><font color="#007700">;
<br>
<br>
</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Description: File Transfer"</font><font color="#007700">);
<br>
</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Type: application/force-download"</font><font color="#007700">);
<br>
</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Disposition: attachment; filename=</font><font color="#007700">\"</font><font color="#dd0000">$soubor</font><font color="#007700">\"</font><font color="#dd0000">"</font><font color="#007700">);
<br>
<br>
</font><font color="#0000bb">readfile </font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">);
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Trik spočívá v přidání hlaviček, které se pokusí vysvětlit
prohlížečům, že mají se souborem zacházet jako s něčím ke stažení a ne
to zobrazovat. Pozor, zase platí, že k souboru musíme mít minimálně
právo pro čtení, abychom jej mohli stáhlout. Různé prohlížeče se k
tomuto postupu postaví různě,
ale je to lepší než nic.<br>
</p>
<p><span style="font-style: italic;">Pozn.: V reálné aplikaci bychom
zřejmě místo proměnné $soubor, která je zde nastavena "natvrdo" použili
funkci a umožnili bychom tak stahovat například soubor předaný jako
parametr. V příkladu to není úmyslně, je to potenciální bezpečnostní
díra do souborového systému webu.</span><br>
</p>
<p>Uvědomte si rovněž, že to, co chceme stahovat vůbec nemusí předtím
existovat jako soubor na serveru. Následující skript například vytvoří
a nabídne ke stažení údaj s aktuálním datem a časem serveru:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
header</font><font color="#007700">(</font><font color="#dd0000">"Content-Description:
File Transfer"</font><font color="#007700">);
<br>
</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Type: application/force-download"</font><font color="#007700">);
<br>
</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Disposition: attachment;
filename=\"datum.txt\""</font><font color="#007700">);
<br>
echo </font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"r"</font><font color="#007700">);
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Je jasné, že takový trik se může hodit když potřebujeme nějaké
informace nabídnout uživateli ke stažení, přičemž třebas nemáme možnost
na serveru vytvářet soubory.<br>
</p>
<a name="000135"></a><h2>Nahrávání souborů na server</h2>
<p>To je vlastně opačný problém. PHP samo o sobě umožňuje zapisovat
soubory na server pomocí protokolu ftp nebo http, pokud je to povoleno.
Takže, následující kód by vytvořil soubor a zapsal do něj požadované
informace:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
$fp </font><font color="#007700">= </font><font color="#0000bb">fopen
</font><font color="#007700">(</font><font color="#dd0000">"ftp://[uzivatel]:[server]/test.txt"</font><font color="#007700">, </font><font color="#dd0000">"w"</font><font color="#007700">);
<br>
</font><font color="#0000bb">fwrite </font><font color="#007700">(</font><font color="#0000bb">$fp</font><font color="#007700">, </font><font color="#dd0000">"Nějaký text"</font><font color="#007700">);
<br>
</font><font color="#0000bb">fclose </font><font color="#007700">(</font><font color="#0000bb">$fp</font><font color="#007700">);
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Moc se ale neradujte. Aby to fungovalo, měly by být splněny
následující požadavky:<br>
</p>
<ul>
  <li>Nastavení PHP na Vašem serveru musí otevírání souborů pomocí FTP
podporovat</li>
  <li>Server FTP musí podporovat běh v pasivním režimu</li>
  <li>Můžete otevírat soubory buď pro čtení, nebo pro zápis, ale ne
obojí</li>
</ul>
<p>Na druhou stranu tak můžete otevřít soubor na druhé straně
zeměkoule, takže zajímavá metoda je to rozhodně.<br>
</p>
<p>Pokud budete chtít uploadovat soubor z počítače, u něhož právě
sedíte, můžete využít toho, že nahrávat soubory lze pomocí formulářů.
Asi takhle:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
</font><font color="#007700">if (</font><font color="#0000bb">$_REQUEST</font><font color="#007700">[</font><font color="#dd0000">"odeslano"</font><font color="#007700">]==</font><font color="#0000bb">1</font><font color="#007700">):
<br>
&nbsp;&nbsp;</font><font color="#0000bb">unlink </font><font color="#007700">(</font><font color="#dd0000">"./31/hloupost.txt"</font><font color="#007700">);
<br>
&nbsp;&nbsp;</font><font color="#ff8000">// kontroly...
<br>
&nbsp;&nbsp;</font><font color="#007700">if (</font><font color="#0000bb">move_uploaded_file</font><font color="#007700">(</font><font color="#0000bb">$_FILES</font><font color="#007700">[</font><font color="#dd0000">'hloupost'</font><font color="#007700">][</font><font color="#dd0000">'tmp_name'</font><font color="#007700">], </font><font color="#dd0000">"./31/hloupost.txt"</font><font color="#007700">))
<br>
&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//zpracování
<br>
&nbsp;&nbsp;</font><font color="#007700">};
<br>
else:
<br>
</font><font color="#0000bb">?&gt;
<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;Nahrání souboru na server
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;form method="POST"
ENCTYPE="multipart/form-data" action="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;table border="1" &gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;Textový
soubor&lt;/td&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="HIDDEN"
name="MAX_FILE_SIZE" VALUE=300&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="file"
name="hloupost" ACCEPT="text/*"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;(max. 300
bajtů)&lt;/td&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td colspan="3"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input
type="hidden" name="odeslano" value="1"&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p
align="center"&gt;&lt;input type="submit"
value="Odeslat"&gt;&lt;/td&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/table&gt;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;
<br>
<font color="#0000bb">&lt;?
<br>
</font><font color="#007700">endif;
<br>
</font><font color="#0000bb">?&gt;
<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/31_upload.html">Ukázat celý skript</a></p>
<p>Formuláře totiž mohou obsahovat prvky typu FILE, které způsobí
odeslání souboru na server. Zobrazte si celý skript, trochu si jej
rozebereme. Probíhá to v následujících krocích:<br>
</p>
<ol>
  <li>Při vyplnění formuláře uživatel vybere soubor. Skryté pole
MAX_FILE_SIZE přitom může omezit jeho velikost (nefunguje to ale vždy)</li>
  <li>Atribut ACCEPT&nbsp; může omezit typ souboru (nefunguje to ale
vždy)</li>
  <li>Nastává slavná chvíle odeslání dat na server. Tam se soubor(y)
uloží do nějaké dočasné složky (nemusíte se o to starat, je to dáno
nastavením systému a/nebo PHP)</li>
  <li>Seznam souborů máte k dispozici ve dvojrozměrném asociativním
poli. První rozměr pole se musí jmenovat stejně jako se jmenuje
odpovídající prvek INPUT ve formuláři. V našem případě tedy <span style="font-style: italic;">hloupost</span>.&nbsp; Druhý rozměr pole
může nabývat hodnot "name", "type", "size" a "tmp_name". Jejich význam
je celkem zřejmý; tmp_name je název na cílovém systému, name na
zdrojovém.</li>
  <li>Skript musí soubor nějak zpracovat. Nejčastěji se přesouvá z
dočasné složky někam jinam. Funkce move_uploaded_file je bezpečnější
než copy, takže byste ji měli použít.</li>
  <li>Ať už skript udělá se souborem cokoli, po ukončení běhu skriptu
je dočasný soubor smazán. (Pakliže byl zkopírován, v cílovém umístění
pochopitelně zůstane).</li>
</ol>
<p><span style="font-style: italic;">Pozn.: V našem případě prostě
soubor vypisujeme, abyste se ujistili, že skutečně dorazil na server.
Jelikož je to ale příklad, každý další soubor nahradí ten předchozí,
abychom zbytečně neplýtvali místem na serveru.<br>
</span></p>
<p>Příště si ukážeme, jak soubory pomocí PHP komprimovat a
dekomprimovat a celý kus seriálu zakončíme návodem, jak si udělat blog.<br>
</p>
<a name="000136"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (32) - Příklad na BLOG</h2>
			<p class="perex">Dnes ukončíme část seriálu, která se věnuje zacházení se soubory, a
dokončíme ji příkladem toho, jak by se v PHP dal napsat BLOG.

				<br>
			</p>
<a name="000137"></a><h2>Píšeme BLOG</h2>
<p><a target="_blank" href="http://www.bloguje.cz/navod/cotojsoublogy.php">Weblog neboli blog</a>
je, zdá se, fenoménem poslední doby. Zatímco před pár lety chtěl každý
mít svoje osobní stránky, dneska chce každý člověk šmrnclý internetem
mít svůj internetový deníček.
Nejsem tomu osobně nijak nakloněn, ale dá se to použít jako dobrý
příklad na PHP a soubory, takže s chutí do toho.<br>
</p>
<p>Pro účely našeho příkladu budeme předpokládat, že každý den
nahrajeme do určité složky na webovém serveru textový soubor s názvem
ve formátu yyyymmdd.txt. Úkolem naší aplikace bude tyto soubory seřadit
a vypsat nějak pěkně do prohlížeče. Aby toho nebylo málo, bude možné
stáhnout si celý obsah blogu jako jeden soubor.<br>
</p>
<p>Přenos souborů na server nebudeme řešit. Probírali jsme to v minulém
díle. Nicméně, pro testovací účely jsem připravil několik souborů v mojí složce na serveru,
takže se můžete pokochat (zčásti) pravdivými útržky z mého života v
posledních několika málo dnech. <span style="font-style: italic;">(Připravit
alespoň trochu smysluplné texty byla pro mě nejnáročnější část celého
článku, takže to tak berte. Samozřejmě by soubory mohly obsahovat
cokoli;-))<br>
</span></p>
<p>Vlastní skript bude řešit několik věcí. Zaprvé, projdeme si složku a
vypíšeme z ní soubory. Pod každým souborem dole bude ještě zobrazeno
datum vypočítané z názvu souboru. Celé to nějak hezky oddělíme. Skript
by mohl vypadat zhruba takhle:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
$slozka </font><font color="#007700">= </font><font color="#0000bb">dir</font><font color="#007700">(</font><font color="#dd0000">"./blog"</font><font color="#007700">); <br>
</font><font color="#0000bb">$licha</font><font color="#007700">=</font><font color="#0000bb">true</font><font color="#007700">;
<br>
while(</font><font color="#0000bb">$soubor</font><font color="#007700">=</font><font color="#0000bb">$slozka</font><font color="#007700">-&gt;</font><font color="#0000bb">read</font><font color="#007700">()) { <br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$soubor</font><font color="#007700">==</font><font color="#dd0000">"." </font><font color="#007700">|| </font><font color="#0000bb">$soubor</font><font color="#007700">==</font><font color="#dd0000">".."</font><font color="#007700">) continue; <br>
&nbsp;&nbsp;</font><font color="#0000bb">$barva </font><font color="#007700">= </font><font color="#0000bb">$licha </font><font color="#007700">? </font><font color="#dd0000">"#FDF5E6" </font><font color="#007700">: </font><font color="#dd0000">"#FFFFFF"</font><font color="#007700">; </font><font color="#ff8000">// nebo <br>
&nbsp;&nbsp;</font><font color="#007700">echo </font><font color="#dd0000">"&lt;div style=</font><font color="#007700">\"</font><font color="#dd0000">background-color:$barva</font><font color="#007700">\"</font><font color="#dd0000">&gt;"</font><font color="#007700">;
<br>
&nbsp;&nbsp;</font><font color="#0000bb">readfile </font><font color="#007700">(</font><font color="#dd0000">"./blog/"</font><font color="#007700">.</font><font color="#0000bb">$soubor</font><font color="#007700">);
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$datum</font><font color="#007700">=</font><font color="#0000bb">explode</font><font color="#007700">(</font><font color="#dd0000">"."</font><font color="#007700">, </font><font color="#0000bb">basename</font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">)); <br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;p
align=\"right\"&gt;"</font><font color="#007700">.</font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"d.m.Y"</font><font color="#007700">, </font><font color="#0000bb">strtotime</font><font color="#007700">(</font><font color="#0000bb">$datum</font><font color="#007700">[</font><font color="#0000bb">0</font><font color="#007700">])).</font><font color="#dd0000">"&lt;/p&gt;"</font><font color="#007700">;
<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;hr&gt;&lt;/div&gt;"</font><font color="#007700">;
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$licha</font><font color="#007700">=!</font><font color="#0000bb">$licha</font><font color="#007700">;
<br>
} <br>
</font><font color="#0000bb">$slozka</font><font color="#007700">-&gt;</font><font color="#0000bb">close</font><font color="#007700">();
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Je to na vysvětlení poměrně jednoduché. Skript vezme obsah složky a
načte jej postupně pomocí $slozka-&gt;read. Pro lepší čtení budeme u
souborů měnit vždy po jednom dni pozadí, k čemuž nám poslouží proměnná
$licha. Ta se neustále přepíná mezi TRUE a FALSE a podle její hodnoty
nastavujeme pozadí textu souvisejícího s daným dnem. <br>
</p>
<p>Vlastní podstatnou část zajišťuje funkce readfile. Hrátky s
basename, explode, strtotime a date slouží jen k tomu, abychom z názvu
souboru dostali česky formátované datum, které pak pod každý den
vypíšeme.<br>
</p>
<p><span style="font-style: italic;">Pozn.: V praxi bychom asi přidali
ještě funkci stránkování, protože by to mohlo být časem dlouhé a
nepřehledné. Taky by bylo potřeba ošetřit řazení souborů. Obojí jsme
vynechali kvůli jednoduchosti. Ke stránkování se ale ještě dostaneme v
některém díle o databázích.</span><br>
</p>
<p></p>
<a name="000138"></a><h2>Komprese souborů</h2>
<p>Jako další věc jsme si slíbili, že budeme chtít celý blog stáhnout
jako soubor. Blog se bude zvětšovat. To může vést časem k tomu, že by
se stahoval extrémně
dlouhý soubor, takže přichází na řadu komprese. PHP podporuje kompresi
zlib (soubory gz) a prakticky vždy ponechávají administrátoři tuto
volbu zapnutou, takže to lze použít. Skript pro kompresi blogu by mohl
vypadat následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
ob_start</font><font color="#007700">();
<br>
</font><font color="#ff8000">// tohle je stejné jako v předchozím
případě...
<br>
</font><font color="#0000bb">$contents </font><font color="#007700">= </font><font color="#0000bb">ob_get_contents</font><font color="#007700">();

<br>
</font><font color="#0000bb">ob_end_clean</font><font color="#007700">();
<br>
</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Description: File Transfer"</font><font color="#007700">); <br>
</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Type: application/force-download"</font><font color="#007700">); <br>
</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Disposition: attachment; filename=\"blog.gz\""</font><font color="#007700">); <br>
echo </font><font color="#0000bb">gzencode</font><font color="#007700">(</font><font color="#0000bb">$contents</font><font color="#007700">);
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/32_komprese.html" target="_blank">Ukázat
celý skript</a></p>
<p>Tady bych měl asi vysvětlit několi věcí. Především, správný
programátor by měl být líný. A když už jsme si předtím náš deníček tak
hezky zformátovali, proč to teď nevyužít? Problém ale spočívá v tom, že
předtím jsme psali pomocí příkazu echo přímo do prohlížeče - jak z toho
tedy teď dostat soubor? Jednoduše - PHP má sadu funkcí umožňujících
bufferování stránky a ukládání do proměnné namísto přímého posílání na
výstup. <br>
</p>
<p>Ačkoli to normálně nemusí být vždy ten nejlepší nápad, nám se to
zrovna hodí. Takže, funkce ob_start celý mechanismus začne a zajistí,
že následující příkazy (například echo) se nebudou posílat prohlížeči,
ale ukládat do bufferu. Proběhne totéž jako v prvním příkladu jen s tím
rozdílem, že to, co bylo původně odesláno do prohlížeče je nyní v
proměnné $contents <span style="font-weight: bold;">a do prohlížeče se
zatím neposlalo nic</span>! Takže si klidně můžeme dovolit odeslat
hlavičky a následně cokoli. Proč odesíláme právě tyto hlavičky jste se
měli možnost dozvědět v předchozím dílu našeho seriálu.<br>
</p>
<p>Celou kompresi pak zajistí funkce gzencode. Ta nejenom provede
kompresi, ale rovněž přidá hlavičky souboru podle specifikace, takže
vznikne skutečný gz soubor. Můžete si jej uložit na disk, rozbalit a
zobrazit. Komprese v našem případě ušetřila asi 50% velikosti souboru,
při větších souborech to ale může být ještě lepší.<br>
</p>
<p><span style="font-style: italic;">Pozn.: PHP může podporovat další
typy kompresí - například bzip nebo zip. V praxi to ale zdaleka nebývá
na serverech povoleno tak často jako gzip.</span><br>
</p>
<a name="000139"></a><h2>Soubory v PHP - shrnutí</h2>
<p>V několika předchozích dílech jsme hovořili o PHP a souborech.
Krátce shrňme, co podstatného jsme se dozvěděli:<br>
</p>
<ul>
  <li>PHP umí pracovat se soubory a je-li to nastaveno, rovněž se
vzdálenými soubory pomocí http a ftp protokolů.</li>
  <li>PHP pracuje se složkami a s komprimovanými soubory</li>
  <li>PHP umí elegantně zpracovat soubory obsahující data</li>
  <li>Všude v souvislosti s PHP, soubory a GNU/Linuxem budeme narážet
na práva. Nezapomeňte na to.<br>
  </li>
</ul>
<a name="000140"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (33) - HTTP hlavičky</h2>
			<p class="perex">PHP
a HTTP protokol - jelikož PHP slouží převážně k výrobě internetových
stránek, není vůbec špatné vědět, jak funguje jejich přenos a jaké
triky nám jazyk nabízí v této oblasti. <br>
			</p>
<a name="000141"></a><h2>Hlavičky požadavku<span style="text-decoration: underline;"></span></h2>
<p>Aby se ve světě internetu udržel nějaký pořádek, musí existovat
určitá pravidla hry. Tak například webové servery musejí "rozumět"
tomu, na co se jich ptáme. Aby to dovedly, existuje protokol, který se
jmenuje HTTP. Každý prohlížeč musí umět sestavit takzvaný http <span style="font-weight: bold;">požadavek </span>a musí být schopen
porozuměnt http <span style="font-weight: bold;">odpovědi</span>.
(Každý server zase musí rozumět požadavku a musí být schopen sestavit
podle něj odpověď.) V
praxi to velice zhruba řečeno funguje tak, že jak požadavky, tak
odpovědi mají svůj formát a ten by se měl ctít a dodržovat.<br>
</p>
<p>Požadavek se skládá mimo jiné z hlaviček. Ty mohou obsahovat některé
důležité věci o tazateli (tedy prohlížeči) nebo o jeho prostředí. PHP
umí zjistit, jaké hlavičky byly v požadavku, a umí je zobrazit. Slouží
k tomu příkaz getallheaders a funguje to následujícím způsobem: </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
$hlavicky </font><font color="#007700">= </font><font color="#0000bb">getallheaders</font><font color="#007700">();
<br>
while (list (</font><font color="#0000bb">$nazev</font><font color="#007700">, </font><font color="#0000bb">$hodnota</font><font color="#007700">) = </font><font color="#0000bb">each </font><font color="#007700">(</font><font color="#0000bb">$hlavicky</font><font color="#007700">)) {
<br>
&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"$nazev:
$hodnota&lt;br&gt;</font><font color="#007700">\n</font><font color="#dd0000">"</font><font color="#007700">;
<br>
}
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Jelikož má generování hlaviček na starosti prohlížeč, bude
pravděpodobně výstup skriptu pro každý prohlížeč jiný. Hlavičky
požadavku nemají až tak velký význam, ale mohou být užitečné pro
statistiky a podobně. (Často z nich jde vyvěštit, jaký prohlížeč jsme
pro zobrazení stránky použili).<br>
</p>
<a name="000142"></a><h2>Hlavičky odpovědi</h2>
<p>U odpovědí je situace veselejší. Tu sestavujeme sami a můžeme na to
využít PHP. Odpověď webového serveru má dvě části:<br>
</p>
<ul>
  <li>hlavičku, která obsahuje informace o dokumentu,</li>
  <li>tělo, které obsahuje vlastní dokument.</li>
</ul>
<p>Hlavička se do odpovědi propašuje pomocí PHP funkce header. My už
jsme se s touto funkcí v seriálu setkali na dvou místech. V díle o <a href="#000114">příkladech
na formuláře</a> jsme využili hlavičku Location a v <a href="#000133">díle o
uploadu a downloadu souborů</a> jsme využili dokonce tři hlavičky,
content-description, content-type a content-disposition. Teď si v tom
uděláme trochu jasno.<br>
</p>
<p style="font-weight: bold;"><span style="font-weight: normal;"><span style="font-weight: bold;">Z čistě praktického hlediska není přidání
hlavičky k odpovědi nic jiného, než způsob, jak něco vzkázat
prohlížeči.</span> Hlavičky jsou </span><a style="font-weight: normal;" href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">normalizované</a><span style="font-weight: normal;">,
hotové peklo však může nastat při zjišťování, zda nám cílový prohlížeč
opravdu porozuměl a zda udělal to, co chceme.</span> <br>
</p>
<p>Co se týče PHP, musí být všechna volání funkce header provedena
dříve, než se odešle jakýkoli výstup do prohlížeče. Poměrně častá chyba
vznikne tehdy, když máme projekt uložený ve více souborech a ty
spojujeme pomocí require nebo include. I jedna nevinná mezera na konci
includovaného souboru totiž způsobí, že se volání funkce header
nepovede - a chybu možná budeme dlouho hledat.<br>
</p>
<p><span style="font-style: italic;">Pozn.: To, co jsem řekl o
hlavičkách berte jako nástin problematiky. Opravdoví znalci HTTP možná
poukáží na to, že existují různé verze protokolu, že v každé verzi
přibyly nebo ubyly určité hlavičky, že některé hlavičky začaly být od
jisté verze HTTP povinné a podobně. Můžete se realizovat v
diskusi.</span><br>
</p>
<a name="000143"></a><h2>Hlavičky v praxi</h2>
<p>V praxi existuje jen několik
hlaviček, které stojí za to si zapamatovat v souvislosti s PHP. Ukažme
si je:<br>
</p>
<p><span style="font-weight: bold;">Location</span><br>
Location se pokusí přemluvit prohlížeč, že by se měl poohlédnout jinde.
Máte-li například stránku s následujícím obsahem:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
Header</font><font color="#007700">(</font><font color="#dd0000">"Location:
http://www.linuxsoft.cz"</font><font color="#007700">); <br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p> </p>
<p>budete místo jejího načtení přesměrováni na startovní stránku
Linuxsoftu přesto (nebo možná právě proto ;-) ) že je skript naprosto v
pořádku. Zbytek skriptu se zkrátka neprovede.<br>
</p>
<p><span style="font-weight: bold;">Content-disposition</span><br>
je hlavička, která se pokusí přemluvit prohlížeč, aby to, co bude ve
výstupu následovat, považoval za přílohu. Už jsme o ní mluvili.
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
Header</font><font color="#007700">(</font><font color="#dd0000">"Content-Description:
File Transfer"</font><font color="#007700">); <br>
</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"Content-Type: application/force-download"</font><font color="#007700">); <br>
</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"Content-Disposition: attachment;
filename=\"nazev.pripona\""</font><font color="#007700">); <br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-weight: bold;">Cache-control</span><br>
Existuje sada hlaviček, které se pokusí přemluvit prohlížeč, aby se
nebavil s proxy serverem, ale aby načetl vždy čerstvou kopii stránky ze
serveru.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
Header</font><font color="#007700">(</font><font color="#dd0000">"Pragma:
no-cache"</font><font color="#007700">);
<br>
</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"Cache-control: no-cache"</font><font color="#007700">);
<br>
</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"Expires: "</font><font color="#007700">.</font><font color="#0000bb">GMDate</font><font color="#007700">(</font><font color="#dd0000">"D, d m Y H:i:s"</font><font color="#007700">).</font><font color="#dd0000">" GMT"</font><font color="#007700">);
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-style: italic;">Pozn.: Kéžby to fungovalo vždy.
Některé proxy servery bývají napsány tak, že je skoro nemožné je
obejít, jiné je potřeba správně nastavit, další mají v rukou lidé,
které nemůžete ovlivnit. Většinou to ale dopadne dobře a použití těchto
hlaviček způsobí načtení stránky ze serveru, ne z cache proxy.</span> <span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;">WWW-Authenticate</span><br>
je hlavička, která se pokusí vysvětlit prohlížeči, že by měl požadovat
ověření uživatele pomocí jména a hesla. Ještě o ní budeme mluvit
podrobněji, teď jen příklad:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
Header</font><font color="#007700">(</font><font color="#dd0000">"HTTP/1.0
401 Unauthorized"</font><font color="#007700">);
<br>
</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"WWW-Authenticate: Basic realm=\"oblast\""</font><font color="#007700">);
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Hlavičky nejsou samospásné. Prohlížeče některým nerozumí, jiné se
používají nenormalizovaně, další pozmění nebo nepochopí na cestě
číhající proxy server, prostě bývá s nimi zábava. Ty, které jsem uvedl
výše by v naprosté většině případů měly fungovat správně.<br>
</p>
<p>Příště se v našem seriálu přehoupneme do oblasti, na kterou se již
všichni těší - bude řeč o databázích.</p>
<a name="000144"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (34) - Úvod do databází</h2>
			<p class="perex">V seriálu o PHP se dostáváme k databázím. Dnes to bude lehký úvod do teorie.
				<br>
			</p>
			<p>PHP by určitě nebylo tak rozšířené, kdyby neumělo pracovat s
databázemi, zvláště pak s MySQL. Databáze jsou téma velmi rozsáhlé a už
to vydalo na mnoho seriálů. My se soustředíme na to, co nám pomůže
vybudovat kvalitní PHP-databázový web. Pokud s databázemi aktivně
pracujete, budete pravděpodobně schopni tento článek vynechat, pokud
ne, čtěte pozorně dál.</p>
<p>Potřeba databází je velmi stará a již v době počítačového pravěku se
na sálových počítačích s databázemi pracovalo. Kdybych se pokusil o
chabou definici, je databáze cokoli, co obsahuje data. Data neboli
údaje jsou v databázích nejen shromážděna, ale obvykle pod pojmem
"databáze" chápeme rovněž sadu nástrojů, které nám pomohou s daty
pracovat - přidávat je, mazat, upravovat, seskupovat, hledat a podobně.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Mezi "daty" a "informacemi"
ve skutečnosti je drobný významový odstín. Data jsou údaje samy o sobě
(plat=10000,- Kč), informace zahrnují i postoje k datům ("beru málo").
Existují specializované aplikace zabávající se významem zjišťovaných
dat. Těmi se ale v našem seriálu zabývat nebudeme.</span><br>
</p>
<p> </p>
<p></p>
<a name="000145"></a><h2>Dělení databází<span style="text-decoration: underline;"></span></h2>
<p>Abychom se v širém světě databází alespoň trochu vyznali, rozdělme
si je. Databáze se dají rozdělit (nejméně) podle dvou významných
kritérií.<br>
</p>
<p><span style="font-weight: bold;">Souborové a systémové </span><br>
Databáze může být obsažena v jednom nebo několika málo souborech
operačního
systému. Pak jim říkáme souborové. Databázi dostanete na jiný stroj
pouhým překopírováním souboru nebo několika souborů. Typickým zástupcem
souborových databází jsou databáze dbf (foxpro), <a href="http://www.sqlite.org/">SQLite</a> nebo třebas Microsoft Access.
Souborové databáze mívají několik významných omezení, hlavně je to
jejich dostupnost v rámci sítě nebo různá úroveň podpory souběžné práce
více uživatelů. Abyste mohli pracovat se souborovou databází, převážně
platí, že k souboru musíte mít nějaká práva.<br>
</p>
<p>Naproti tomu systémové databáze slouží jako databázové servery.
Většinou mají velmi dobrou podporu souběžné práce více uživatelů a
bývají přístupné pomocí nějakého směrovatelného protokolu (asi TCP).
Systémové databáze mívají obecně složitější instalaci, bývají
vypiplanější a robustnější. Mezi typické zástupce patří například
MySQL, PostgreSQL, Oracle nebo Microsoft SQL server. Obecně se můžete
připojit k systémové databázi i v případě, že na systém na němž běží
nemáte jinak přístup.<br>
</p>
<p><span style="font-style: italic;">Pozn.: V poslední době se
významový rozdíl mezi souborovými a systémovými databázemi dost stírá.
Existuje totiž řada způsobů, jak pomocí nějakého software přistupovat k
souborovým databázím, jako by to byly databáze systémové. Například
pomocí UnixODBC nebo ODBC můžete přistupovat k databázi dbf z
počítačové sítě a podobně.<br>
</span></p>
<p><span style="font-weight: bold;">Objektové a relační</span><br>
Dosti podstatné je rozdělení podle filozofie uložení dat. Méně obvyklý
způsob je organizovat data v databázi jako objekty. Zhruba to odpovídá
způsobu, jakým jsme o objektech mluvili <a href="#000078">v
souvislosti s PHP</a>. <span style="font-weight: bold;">Objektové </span>databáze
nejsou příliš rozšířené. Bývá jim vytýkáno, že jsou pomalé. Nemohu to
potvrdit ani vyvrátit, protože žádnou objektovou databázi nepoužívám.
Zástupcem by mohla být třeba <a href="http://www.intersystems.com/cache/">Caché</a>.<br>
</p>
<p>Prakticky všechny dnešní databáze jsou <span style="font-weight: bold;">relační</span>. Data v relačních databázích
jsou (nebo alespoň mohou být) uložena tak, že související záznamy
můžete jednoduše vyhledat. Například v databázi podniku můžete k
pracovníkům rychle najít šéfy, platové skupiny nebo záznamy o
příchodech na pracoviště. Pokud si nedokážete představit, jak to
funguje, nedělejte si s tím hlavu. Budeme o tom mluvit příště.<br>
</p>
<a name="000146"></a><h2>Domluva s databází</h2>
<p>Bylo by fajn mít nějaký univerzální jazyk, kterým byste se s
databází domluvili. Prostě byste jí řekli, co potřebujete (třeba vybrat
nějaká data) a ona by to pochopila bez ohledu na to, jestli je
objektová, relační, červená nebo open source (nebo jaká ještě jiná).
Takový jazyk skutečně existuje a říká se mu SQL (Structured Query
Language, strukturovaný dotazovací jazyk). <br>
</p>
<p>SQL je standardizován, ale jak už to ve světě databází bývá, každá
konkrétní databáze rozumí určitému "dialektu" SQL. V praxi to není tak
hrozné, jak by to mohlo vypadat; většinu základních příkazů můžete pro
většinu používanějších databází zadat úplně nebo téměř shodně. Některé
databáze mají další rozšíření jazyka SQL, takže toho umí víc nebo
stejnou věc umí pomocí kratšího zápisu kódu.<br>
</p>
<p style="font-style: italic;">Pozn.: Chci Vám jemně naznačit, že kromě
syntaxe PHP se vlastně budeme učit další programovací jazyk. Jazyk,
kterému rozumí databáze. </p>
<p></p>
<a name="000147"></a><h2>Kterou databázi?</h2>
<p>To je téměř neřešitelná otázka. Pro každý typ projektu existuje jiná
odpověď. Řekněme si alespoň, jaké podmínky by měla splňovat "databáze
snů" pro webové aplikace psané v PHP:<br>
</p>
<ul>
  <li>Měla by (pokud možno) být GNU/GPL, nebo šířena pod jinou
svobodnou licencí.</li>
  <li>Měla by být schopna pracovat pod různými operačními systémy,
hlavně pod Linuxem a jinými Unixy. Když poběží i pod Windows, tím lépe.</li>
  <li>Měla by být relační</li>
  <li>Měla by být systémová</li>
  <li>Měla by být stabilní<br>
  </li>
  <li>Měla by podporovat standard SQL<br>
  </li>
  <li>Měla by obsahovat solidní správu uživatelů</li>
  <li>Měla by mít solidní zabezpečení a možnost používat zabezpečené
přenosy dat (třeba SSL)<br>
  </li>
  <li>PHP by mělo tuto databázi nějak rozumně podporovat</li>
  <li>Měla by umět ukládat data v různých jazycích, resp. znakových
sadách</li>
  <li>Měla by umět česky řadit</li>
  <li>Měla by podporovat všechny vymoženosti databází (pohledy,
spouště, uložené procedury, transsakce atd.)</li>
  <li>Měla by být rychlá<br>
  </li>
  <li>Měla by k ní existovat solidní dokumentace</li>
  <li>Měl by jí používat dostatečný počet uživatelů, aby to bylo
vyzkoušené.</li>
  <li>Měly by ji podporovat komerční i free webhostingy.<br>
  </li>
</ul>
<p>
Jak asi tušíte, taková databáze neexistuje. Můžete se rozvášnit v
diskusi pod článkem, ale neexistuje, hlavně proto, že některé nadhozené
požadavky jsou jasně protichůdné. Existují ale databáze, které se tomu
co bylo řečeno hodně přibližují.<br>
</p>
<p>My se budeme zaměřovat na <a href="http://www.mysql.com/products/mysql/">MySQL</a>. MySQL není
žádný středobod světa, ale poctivě řečeno má k tomu, co bylo
předneseno, poměrně blízko. Takže, pokud se budeme zabývat onkrétní
prací s PHP a databází, budu se zmiňovat o MySQL.</p>
<p></p>
<p><span style="font-style: italic;">Pozn.: Existuje celá řada dalších
velice dobrých databází, jako je PostgreSQL nebo Firebird. V jednom
nebo
několika bodech vytýčených výše však většinou za MySQL zaostávají.
Protože je vývoj software v oblasti databází velmi bouřlivý, mohou
některé myšlenky z čláku přestat velice rychle platit.<br>
</span></p>
<a name="000148"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (35) - Uložení dat v databázi</h2>
			<p class="perex">Objasněme si, jak jsou data v databázi uložena, jaké máme typy sloupců a jak se označují nezadané hodnoty.
				<br>
			</p>
			<p> Abychom mohli nějak účinně pracovat s databázemi, představme si
nyní, jak jsou data v těchto databázích uložena.
</p>
<a name="000149"></a><h2> Relační model
</h2>
<p> Data jsou v databázích uložena v celcích, kterým se říká tabulky.
Mějme například tabulku autorů, kteří přispívají na portál Linuxsoftu.
Tato tabulka by mohla vypadat následujícím způsobem:
</p>
<table style="width: 90%; text-align: left; margin-left: auto; margin-right: auto; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Jmeno</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Prijmeni</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Email</span> <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> Petr <br>
      </td>
      <td style="vertical-align: top;"> Zajíc <br>
      </td>
      <td style="vertical-align: top;"> petr@xzajic.cz <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> Pavel <br>
      </td>
      <td style="vertical-align: top;"> Adam <br>
      </td>
      <td style="vertical-align: top;"> pa@pajus.com <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> Někdo <br>
      </td>
      <td style="vertical-align: top;"> Jiný <br>
      </td>
      <td style="vertical-align: top;"> kdosi@kdesi.cz <br>
      </td>
    </tr>
  </tbody>
</table>
<p> Pakliže jste někdy pracovali například s OpenOffice, můžete si to
představit jako list aplikace OOCalc. Naše tabulka má tři sloupce a
nějaký počet řádků (taky tři, v našem případě). Každý řádek v tabulce
obsahuje určitou skupinu dat, tedy například údaje o jedné osobě. Když
budeme přidávat řádky, znamená to, že měníme data v tabulce, budeme-li
přidávat sloupce, znamená to, že měníme strukturu tabulky.
</p>
<p style="font-style: italic;"> Pozn.: Databázovému řádku se také někdy
říká věta nebo záznam (record).
</p>
<p> To bylo poměrně jednoduché. Teď si představte, že budete chtít mít
jinou tabulku, která bude obsahovat údaje o tom, kdo napsal na
Linuxsoft jaké články. To už je zajímavější problém. Jde totiž o to (a
většinou to tak bývá), že jeden autor napíše více článků. Jak by mohla
taková tabulka vypadat? Mohla by vypadat třeba takhle:
</p>
<table style="width: 90%; text-align: left; margin-left: auto; margin-right: auto; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Jmeno</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Prijmeni</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Email</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Nazev</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">URL</span> <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> Petr <br>
      </td>
      <td style="vertical-align: top;"> Zajíc <br>
      </td>
      <td style="vertical-align: top;"> petr@xzajic.cz <br>
      </td>
      <td style="vertical-align: top;"> PHP (1) historie a budoucnost <br>
      </td>
      <td style="vertical-align: top;">http://www.linuxsoft.cz/article.php?id_article=171
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> Petr <br>
      </td>
      <td style="vertical-align: top;"> Zajíc <br>
      </td>
      <td style="vertical-align: top;"> petr@xzajic.cz <br>
      </td>
      <td style="vertical-align: top;"> PHP (2) jak to funguje <br>
      </td>
      <td style="vertical-align: top;">http://www.linuxsoft.cz/article.php?id_article=172
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> Pavel <br>
      </td>
      <td style="vertical-align: top;"> Adam <br>
      </td>
      <td style="vertical-align: top;"> pa@pajus.com <br>
      </td>
      <td style="vertical-align: top;"> Úvod do C++ <br>
      </td>
      <td style="vertical-align: top;">http://www.linuxsoft.cz/article.php?id_article=196
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> Někdo <br>
      </td>
      <td style="vertical-align: top;"> Jiný <br>
      </td>
      <td style="vertical-align: top;"> kdosi@kdesi.cz <br>
      </td>
      <td style="vertical-align: top;"> Dohoní někdy Bill Linuse ? <br>
      </td>
      <td style="vertical-align: top;">http://www.utopie.cz/nikdy/se_to_nestane.php
      <br>
      </td>
    </tr>
  </tbody>
</table>
<p> To nás přivádí k zajímavému problému - jméno, příjmení a e-mail
autora tam máme zbytečně v obou tabulkách. Mít v tabulce článků
kompletní informace o autorech nemusí být z několika důvodů výhodné.
Tak například:
</p>
<ul>
  <li> Tabulka článků bude zbytečně velká a pomalá, protože se v ní
údaje budou opakovat </li>
  <li> Když budeme chtít změnit, dejme tomu, e-mailovou adresu autora,
budeme to muset udělat na více místech </li>
  <li> Kdybychom chtěli kromě jména, příjmení a e-mailu evidovat ještě
něco jiného, budeme muset měnit strukturu několika (časem spíše mnoha)
tabulek. </li>
</ul>
<p> Asi tušíte, že se to tak v praxi opravdu nedělá - a máte pravdu. V
praxi se řádky v tabulce autorů očíslují a namísto toho, aby se údaje
opisovaly do tabulky článků se v této tabulce uvede jen odkaz na
související záznam. Asi bude nejlepší to ukázat:
</p>
<table style="width: 90%; text-align: left; margin-left: auto; margin-right: auto; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">ID</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Jmeno</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Prijmeni</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Email</span> <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> 1 <br>
      </td>
      <td style="vertical-align: top;"> Petr <br>
      </td>
      <td style="vertical-align: top;"> Zajic <br>
      </td>
      <td style="vertical-align: top;"> petr@xzajic.cz <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> 2 <br>
      </td>
      <td style="vertical-align: top;"> Pavel <br>
      </td>
      <td style="vertical-align: top;"> Adam <br>
      </td>
      <td style="vertical-align: top;"> pa@pajus.com <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> 3 <br>
      </td>
      <td style="vertical-align: top;"> Někdo <br>
      </td>
      <td style="vertical-align: top;"> Jiný <br>
      </td>
      <td style="vertical-align: top;"> kdosi@kdesi.cz <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<table style="width: 90%; text-align: left; margin-left: auto; margin-right: auto; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Autor</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Nazev</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">URL</span> <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> 1 <br>
      </td>
      <td style="vertical-align: top;"> PHP (1) historie a budoucnost </td>
      <td style="vertical-align: top;">http://www.linuxsoft.cz/article.php?id_article=171
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> 1 <br>
      </td>
      <td style="vertical-align: top;"> PHP (2) jak to funguje </td>
      <td style="vertical-align: top;">http://www.linuxsoft.cz/article.php?id_article=172
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> 2 <br>
      </td>
      <td style="vertical-align: top;"> Úvod do C++ </td>
      <td style="vertical-align: top;">http://www.linuxsoft.cz/article.php?id_article=196
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> 3 <br>
      </td>
      <td style="vertical-align: top;"> Dohoní někdy Bill Linuse ? </td>
      <td style="vertical-align: top;">http://www.utopie.cz/nikdy/se_to_nestane.php
      </td>
    </tr>
  </tbody>
</table>
<p> Z toho můžeme vidět, že se nám tabulka článků smrskla z pěti polí
na tři a že namísto toho, abychom uváděli podrobnosti o každém
autorovi, uvádíme jen číslo záznamu v související tabulce. Vztahu mezi
tabulkou autorů a článků se říká odborně relace a právě proto, že lze
data v tabulkách takto organizovat, nazývají se tyto databáze relační.
</p>
<a name="000150"></a><h2> Sloupce tabulky
</h2>
<p> Zhruba řečeno se do tabulky dá ukládat to, co se v PHP dá ukládat
do proměnných. Takže řetězce (jedno či vícepísmenné), logické hodnoty,
datumy a různě přesná čísla. Každý sloupec tabulky má při jejím
založení určen typ dat, které se do něj budou ukládat. Když se pokusíte
do sloupce uložit hodnotu jiného datového typu, mohou databáze reagovat
různě - někdy provedou cosi jako přetypování, někdy to skončí chybou. V
MySQL se nejčastěji používají následující typy sloupců (<a href="http://dev.mysql.com/doc/mysql/en/Column_types.html">tady</a>
byste našli kompletní seznam):
</p>
<table style="width: 90%; text-align: left; margin-left: auto; margin-right: auto; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Typ sloupce</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Co do něj</span> <br>
      </td>
      <td style="vertical-align: top;"> <span style="font-weight: bold;">Rozsah</span> <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> int <br>
      </td>
      <td style="vertical-align: top;"> Celá čísla <br>
      </td>
      <td style="vertical-align: top;"> -2147483648 až -2147483647 </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> char (n) <br>
      </td>
      <td style="vertical-align: top;"> Řetězce <br>
      </td>
      <td style="vertical-align: top;"> Právě n znaků dlouhý řetězc <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> varchar (n) <br>
      </td>
      <td style="vertical-align: top;"> Řetězce <br>
      </td>
      <td style="vertical-align: top;"> Nejvýše n znaků dlouhý řetězec <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> date <br>
      </td>
      <td style="vertical-align: top;"> Datumy <br>
      </td>
      <td style="vertical-align: top;"> 1.1.1000 až 31.12.9999 <br>
      </td>
    </tr>
  </tbody>
</table>
<a name="000151"></a><h2> Kde nic není ...
</h2>
<p> tam smrt sice nebere, ale databáze ano. Zvykněte si na to, že v
tabulkách nebývají všechna pole povinná. Dejme tomu, že bychom v
databázi autorů u někoho nevyplnili e-mail, protože ho nevíme. V tom
případě mohou nastat při uložení řádku zhruba dvě situace:
</p>
<ul>
  <li> Databáze má nařízeno, že když dané políčko nebude vyplněno, má
tam dodat nějakou výchozí (default) hodnotu. Třebas prázdný řetězec. </li>
  <li> Databáze nemá nařízeno nic, a proto si poznamená, že obsah
tohoto pole je neznámý, neboli NULL. </li>
</ul>
<p> NULL není rovno ničemu, co jsme až dosud poznali. Nerovná se nule,
prázdnému řetězci ani logické hodnotě false. S NULL se dají dělat
databázové operace, o nichž si povíme někdy příště. Ale už teď byste
měli mít na paměti, že to je zvláštní věc.
</p>
<p> Příště zanecháme suché teorie a ukážeme si, jak se z PHP k databázi
vůbec napojit.
</p>
<a name="000152"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (36) - Připojujeme se k MySQL</h2>
			<p class="perex">Dnes nastane slavný den, kdy se v našem seriálu poprvé připojíme k MySQL databázi pomocí PHP.
				<br>
			</p>
<a name="000153"></a><h2>Připojení k MySQL</h2>
<p>Pakliže jste četli minulé díly našeho seriálu, víte, že MySQL je
systémová databáze a že tudíž běží jako serverový proces. Proto musí
každý, kdo se chce k MySQL připojit, znát tyto přihlašovací informace:<br>
</p>
<p><span style="font-weight: bold;">Název hostitele</span><br>
MySQL pochopitelně běží na nějakém stroji. Název hostitele se může
zadávat jménem (třeba mysql.nekde.cz) nebo IP adresou. Pokud budete
provozovat MySQL server doma, můžete většinou použít localhost či
www.linuxsoft.cz. Pokud se budete připojovat k MySQL u providera, název
hostitele Vám sdělí. <br>
</p>
<p style="font-style: italic;">Pozn.: Server, na němž běží databáze
nemusí být nutně týž, na němž běží webový (http) server.</p>
<p><span style="font-weight: bold;">Port</span><br>
MySQL naslouchá standardně na portu 3306, pokud není při konfiguraci
určeno jinak. Pravděpodobně můžete port vynechat, 3306 je doplněno
automaticky.</p>
<p><span style="font-weight: bold;">Název databáze </span><br>
Zde by mohlo dojít k určitému matení pojmů: Na <span style="font-style: italic;">databázovém serveru</span> MySQL existuje
většinou několik vzájemně <span style="font-style: italic;">nesouvisejících
databází</span>. Každá databáze obsahuje žádnou nebo více tabulek a
každá může mít vlastní nastavení práv. V praxi to většinou bývá tak, že
součástí hostingových služeb je možnost používat jednu databázi. V ní
můžete mít teoreticky nomezený počet tabulek a ostatní uživatelé
serveru nemají k vaší databázi přístup. Vy zase nemáte přístup k jejich
databázím.<br>
</p>
<p><span style="font-weight: bold;">Uživatelské jméno </span><br>
Znalci prominou, ale je potřeba zdůraznit, že uživatelské jméno k
databázovému serveru nijak nesouvisí s přihlašovacím jménem k serveru.
Ve skutečnosti většinou nebudete mít na serveru, na němž databáze
poběží, zřízen systémový účet. Uživatelské jméno nejspíš dostanete od
správce databáze.<br>
</p>
<p><span style="font-weight: bold;">Heslo </span><br>
Asi i heslo dostanete od správce databáze. Většinou bude splňovat
základní bezpečnostní pravidla, tzn. bude dostatečně dlouhé a bude se
skládat z písmen, číslic, případně dalších znaků. <br>
</p>
<p>V PHP se k MySQL databázi můžete připojit pomocí funkce
myslq_connect. Jejími parametry jsou název hostitele, uživatelské jméno
a heslo. Po připojení k MySQL si ještě musíte vybrat svoji databázi,
což se děje příkazem mysql_select_db. Celé to může vypadat v
nejjednodušším případě takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
mysql_connect</font><font color="#007700">(</font><font color="#dd0000">"localhost"</font><font color="#007700">, </font><font color="#dd0000">"uzivatel"</font><font color="#007700">, </font><font color="#dd0000">"heslo"</font><font color="#007700">);<br>
</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#dd0000">"mojedb"</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Aniž bychom zabíhali do podrobností dodejme, že pokud to dopadne
úspěšně, budou se od tohoto místa ve skriptu všechny příkazy určené pro
MySQL provádět na tomto spojení. Pokud v témže skriptu zavoláte
mysql_connect znovu se stejnými parametry, pokusí se PHP použít první
spojení
nemísto vytvoření nového (vytvoření nového spojení jde ale vynutit
pomocí nepovinného čtvrtého parametru funkce mysql_connect). Spojení
vytvořené pomocí mysql_connect je otevřené až do doby, než je zavolána
funkce mysql_close, nebo do ukončení běhu skriptu.<br>
</p>
<a name="000154"></a><h2>Trvalá spojení</h2>
<p>K příkazu mysql_connect existuje alternativní příkaz mysql_pconnect.
Jediný rozdíl mezi nimi je ten, že mysql_pconnect se neuzavírá po
ukončení běhu skriptu, ale zůstává otevřené. Mysql_pconnect lze použít
pouze tehdy, když běží PHP jako modul Apache a jeho výzam spočívá
vlastně jen v tom, že šetří čas, který mysql_connect spotřebovává při
každém otevření spojení.<br>
</p>
<p style="font-style: italic;">Pozn.: V typickém prostředí
vícevláknových serverů je ale čas potřebný pro vykonání funkce
mysql_connect zanedbatelný.<br>
</p>
<a name="000155"></a><h2>Profi přístup</h2>
<p>Jelikož je připojení k databázi něco, co se bude v našich skriptech
mnohokrát opakovat, měli bychom si ukázat nějaký pokročilejší příklad
na připojování. Naše ukázka má totiž několik zásadních nevýhod:<br>
</p>
<ul>
  <li>nikomu se asi nebude chtít psát do každého skriptu údaje pro
spojení</li>
  <li>neošetřujeme chyby</li>
  <li>typicky budeme mít vývojové prostředí doma a reálnou aplikaci
"venku", takže se údaje pro spojení budou lišit</li>
</ul>
<p>Všechno lze poměrně jednoduše řešit. Jak říkal můj učitel
programování: "Udělej to jednou, udělej to pořádně a zapomeň na to".
Především si údaje do spojení uložíme do konstant (můžete rovněž použít
například
asociativního pole), abychom při změně konfigurace nemuseli údaje
přepisovat na mnoha místech. Za druhé, konstanty uložíme do
samostatného souboru, který pak vložíme do našich skriptů pomocí
direktivy include. A za třetí - pomocí proměnné prostředí zjistíme, kde
náš kód běží a nastavíme hodnoty podle toho. Celý includovaný soubor
pak může vypadat asi následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">if (</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SERVER_ADDR"</font><font color="#007700">]==</font><font color="#dd0000">"localhost"</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">define</font><font color="#007700">(</font><font color="#dd0000">"SQL_HOST"</font><font color="#007700">,</font><font color="#dd0000">"localhost"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">define</font><font color="#007700">(</font><font color="#dd0000">"SQL_DBNAME"</font><font color="#007700">,</font><font color="#dd0000">"database"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">define</font><font color="#007700">(</font><font color="#dd0000">"SQL_USERNAME"</font><font color="#007700">,</font><font color="#dd0000">"user"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">define</font><font color="#007700">(</font><font color="#dd0000">"SQL_PASSWORD"</font><font color="#007700">,</font><font color="#dd0000">"password"</font><font color="#007700">);<br>
}<br>
else<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">define</font><font color="#007700">(</font><font color="#dd0000">"SQL_HOST"</font><font color="#007700">,</font><font color="#dd0000">"mysql.nekde.cz"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">define</font><font color="#007700">(</font><font color="#dd0000">"SQL_DBNAME"</font><font color="#007700">,</font><font color="#dd0000">"databaze_u_providera"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">define</font><font color="#007700">(</font><font color="#dd0000">"SQL_USERNAME"</font><font color="#007700">,</font><font color="#dd0000">"user2"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">define</font><font color="#007700">(</font><font color="#dd0000">"SQL_PASSWORD"</font><font color="#007700">,</font><font color="#dd0000">"password2"</font><font color="#007700">);<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-style: italic;">Pozn.: Je samozřejmě možné mít
místo toho dva soubory začlenění, lokální a serverový. Většinou je ale
dříve či později pomícháte nebo přepíšete, což se ve výše uvedeném
případě nemůže stát.<br>
</span></p>
<p>A je tu čas vypořádat se s chybami - jak mysql_connect, tak i
mysql_select_db mohou skončit chybou. Testovat to je naštěstí poměrně
jednoduché, protože v případě úspěchu vracejí obě procedury
FALSE.&nbsp; Takže můžeme použít něco ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">include (</font><font color="#dd0000">"config.php"</font><font color="#007700">);<br>
</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">) or die(</font><font color="#dd0000">"Nelze se připojit k MySQL: " </font><font color="#007700">. </font><font color="#0000bb">mysql_error</font><font color="#007700">());<br>
</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">) or die(</font><font color="#dd0000">"Nelze vybrat databázi: "</font><font color="#007700">.
</font><font color="#0000bb">mysql_error</font><font color="#007700">());&nbsp;&nbsp;&nbsp;&nbsp;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>kde config.php je soubor s definicí konstant (viz výše). Jak jste
nejspíš pochopili, vrací mysql_error chybovou hlášku z MySQL. Co se
týče použití die, můžete zavzpomínat na jeden z <a href="#000087">předchozích
dílů</a> našeho seriálu, který rozebírá jeho úskalí. Pokud by to, že se
nemůžete připojit k databázi nebylo pro skript fatální, nejspíš
použijete return.<br>
</p>
<a name="000156"></a><h2>Příklady</h2>
<p>My budeme v seriálu používat přesně tuto metodu připojování. Pro
demonstrativní účely máme na serveru Linuxsoftu k dispozici databázi;
platné hodnoty připojovacích údajů však nezveřejním. Na začátku každého
databázového skriptu budu vkládat soubor začlenění (něco jako výše
include("config.php")), který bude tyto údaje obsahovat. Ve výpisu
zdrojového kódu souboru bude tento řádek nahrazen komentářem; fungovat
to bude normálně.</p>

<a name="000157"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (37) - Tvorba tabulek v MySQL</h2>
			<p class="perex">Databáze se skládají z tabulek a ty se musejí vytvořit - třeba v PHP.
				<br>
			</p>
			<p>Jak jsme si již ukázali, skládají se databáze z tabulek a tabulky ze
řádků a sloupců. Předtím, než můžete nějakou tabulku použít, musíte ji
definovat. K tomu slouží určitá podmnožina příkazů jazyka pro práci s
databází.<br>
</p>
<a name="000158"></a><h2>Velmi lehký úvod do SQL<br>
</h2>
<p>SQL, neboli strukturovaný dotazovací jazyk je jazyk, kterému rozumí
databábáze. Takže, typický skript PHP pracující s databází má
následující strukturu:</p>
<ol>
  <li>Nějaký kód PHP, který se (mimo jiné) postará o připojení k
databázi</li>
  <li>Kód SQL, který "řekne" databázi, co od ní potřebujeme</li>
  <li>Kód PHP, který zpracuje to, co nám databáze odpověděla</li>
  <li>Kód PHP, který spojení k databázi uzavře.</li>
</ol>
<p>Samotné příkazy jazyka SQL se dělí podle účelu, k němuž při
komunikaci s databází slouží na:</p>
<table style="width: 90%; text-align: left; margin-left: auto; margin-right: auto; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Oblast</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Popis</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Příkaz(y)</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Definiční<br>
      </td>
      <td style="vertical-align: top;">Umožňují spravovat strukturu
databáze<br>
      </td>
      <td style="vertical-align: top;">CREATE TABLE, DROP TABLE<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Výběrové<br>
      </td>
      <td style="vertical-align: top;">Umožňují získat z databáze data<br>
      </td>
      <td style="vertical-align: top;">SELECT<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Přidávací<br>
      </td>
      <td style="vertical-align: top;">Umožňují přidávat nová data do
tabulky nebo tabulek<br>
      </td>
      <td style="vertical-align: top;">INSERT<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Aktualizační<br>
      </td>
      <td style="vertical-align: top;">Umožňují měnit existující data v
tabulkách<br>
      </td>
      <td style="vertical-align: top;">UPDATE, REPLACE<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Odstraňovací<br>
      </td>
      <td style="vertical-align: top;">Umožňují smazat řádky z tabulky
nebo tabulek<br>
      </td>
      <td style="vertical-align: top;">DELETE<br>
      </td>
    </tr>
  </tbody>
</table>
<p style="font-style: italic;">Pozn.: Nejsou všechny, jen ty hlavní.</p>
<p>My se dnes podíváme na definiční příkazy jazyka SQL a vytvoříme si v
databázi tabulku. K definování tabulky slouží příkaz CREATE TABLE. Než
budete moci definovat tabulku, měli byste přesně vědět kolik bude mít
sloupců, co bude v jednotlivých sloupcích uloženo a jak se mají
jmenovat. Pokud byste například chtěli mít v tabulce nějaký seznam
zaměstnanců, mohl by definiční příkaz vypadat takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">CREATE TABLE zamestnanci(<br>
jmeno varchar( 10 ) ,<br>
prijmeni varchar( 15 ) ,<br>
cislo int,<br>
datum_narozeni date<br>
) </font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Což přeloženo do češtiny znamená: "Milá databáze, měla bys začít
něco
dělat. Potřebuji vytvořit novou tabulku, bude se jmenovat zamestnanci,
a bude
mít 4 sloupce následujících typů a velikostí: ... ". Dovolil bych si k
tomu několik poznámek:<br>
</p>
<ul>
  <li>MySQL rozlišuje v názvech tabulek a názvech sloupců velikost
písmen. Takže, pozor na to. Někteří se rozhodli psát všechno malými
písmeny, rozhodně je třeba mít v tom nějaký systém.</li>
  <li>Názvy sloupců by měly být dostatečně výstižné. <br>
  </li>
  <li>Názvy sloupců i tabulek by měly být dostatečně krátké, jinak se
upíšete a budete dělat více chyb.</li>
</ul>
<p>Uvádět zde všechny podrobnosti syntaxe příkazu CREATE TABLE
nebudeme, k tomu slouží <a href="http://dev.mysql.com/doc/mysql/en/CREATE_TABLE.html">oficiální
dokumentace</a>. Z důvodů, které budeme vysvětlovat později však může
být výhodné mít v tabulce pole, které se bude postupně při vložení
záznamu číslovat. To bychom provedli takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">CREATE TABLE zamestnanci
(<br>
id INT NOT NULL AUTO_INCREMENT ,<br>
prijmeni VARCHAR( 20 ) NOT NULL ,<br>
jmeno VARCHAR( 10 ) NOT NULL ,<br>
PRIMARY KEY ( id ) <br>
)</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>jak vidíte, většinou se prostým pohledem na příkaz SQL dá odvodit,
co asi dělá.<br>
</p>
<p>Opakem příkazu CREATE TABLE je potom příkaz DROP TABLE. Ten celou
tabulku
odstraní. Takže byste mohli napsat:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">DROP TABLE zamestnanci</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Ale pozor! Tento příkaz bez milosti odstraní tabulku i v případě, že
už v ní jsou nějaká data. Měl by se tudíž používat s rozvahou. Příkaz
DROP TABLE již pochopitelně nepotřebuje znát strukturu tabulky, protože
ji stejně bude mazat.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Většinou může být
výhodnější použít k definování tabulek nějaký hotový program. V praxi
to bývá často tak, že se struktura tabulek se navrhuje mimo PHP a
skripty neobsahují mnoho definičních příkazů.<br>
</span></p>
<a name="000159"></a><h2>Jak na to v PHP</h2>
<p>V PHP slouží obecně k zasílání příkazů jazyka SQL databází příkaz
mysql_query. Mysql_query vyžaduje, aby již existovalo spojení na
databázi vytvořené pomocí mysql_connect nebo mysql_pconnect. Pokud
spojení existovat nebude, pokusí se jej PHP vytvořit s výchozími
hodnotami (což pravděpodobně selže). Takže bychom mohli napsat něco
jako:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">// zde je include souboru s konstantami<br>
</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"CREATE TABLE zamestnanci(jmeno varchar(10),prijmeni
varchar(15),cislo int,datum_narozeni date)"</font><font color="#007700">)<br>
or die(</font><font color="#dd0000">"Nelze vykonat definiční dotaz: " </font><font color="#007700">. </font><font color="#0000bb">mysql_error</font><font color="#007700">());<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Všimněte si, že řetězec pro mysql_query můžeme napsat na jeden
řádek, nemusí být nutně členěna tak, jsem to ukazoval prve. I funkce
mysql_query má samozřejmě právo skončit chybou. O
vychytávání chyb z této
funkce platí to, co bylo řečeno v minulém díle. Jen dodejme, že příčin
selhání mysql_query může být celá řada. Mezi nejznámější patří:</p>
<ul>
  <li>Jako argument je předáno něco, co databáze nepochopí jakožto
platný kód jazyka SQL</li>
  <li>Příkaz SQL je sice syntakticky správný, ale nelze jej provést
(třeba vytvoření tabulky, která již existuje).</li>
  <li>Pro provedení příkazu nemáte potřebná práva.</li>
  <li>Neexistuje spojení, které by mysql_query obsloužilo.<br>
  </li>
</ul>
<p>Použití funkce mysql_error můžu v tomto případě jen doporučit. MySQL
se totiž pokusí vysvětlit Vám, co jí nevoní.<br>
</p>
<p>V dalším díle našeho seriálu se setkáme s hotovou aplikací na
vyhledávání PSČ a názvů obcí. Na ní Vám ukážu, jak fungují výběrové
dotazy.</p>
<a name="000160"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (38) - Dolujeme data z MySQL</h2>
			<p class="perex">Jak vybrat data z MySQL a hotová aplikace na vyhledávání obcí dle PSČ
				<br>
			</p>
			<p>Jádrem každé databázové aplikace je čtení dat z databáze. My si dnes
ukážeme, jak číst data z MySQL pomocí PHP. A protože suché teorie je v
tomto seriálu až dost, bude to rovnou hotová aplikace na vyhledávání
obce pomocí PSČ.<br>
</p>
<a name="000161"></a><h2>SQL a výběrové dotazy<br>
</h2>
<p>V MySQL, ostatně jako v každé jiné databázi obsahující jazyk SQL se
data z databáze vybírají pomocí příkazu SELECT. Je to příkaz nesmírně
mocný. Jeho nejjednodušší forma je:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">SELECT * FROM [název
tabulky]</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a dlužno dodat, že může být daleko složitější. Pokud chcete důkladně
postrašit, můžete se podívat na kompletní
formu tohoto příkazu <a href="http://dev.mysql.com/doc/mysql/en/SELECT.html">do dokumentace</a>.
Většinou se budeme snažit používat příkaz SELECT v co nejjednodušší
syntaxi, protože cílem našeho seriálu není naučit se SQL, nýbrž PHP.
Příkaz SELECT umí data nejen vybrat, ale umí je pro naše
pohodlí
rovněž například vyfiltrovat, seřadit nebo seskupit. V naprosté většině
skriptů
tedy budeme psát SELECT nějak takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">SELECT [seznam polí]
FROM [název tabulky nebo tabulek] <br>
WHERE [podmínka] GROUP BY [seskupení] ORDER BY [seřazení]</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Příkaz SELECT patří přesně mezi ty věci, které se naučíte neustálým
používáním. Takže se pojďme rovnou podívat, jak se takový SELECT
zpracuje
prostředky jazyka PHP.<br>
</p>
<a name="000162"></a><h2>MySQL, SELECT a PHP</h2>
<p>Možná budete mít pocit, že už jste to někde slyšeli, a bude to
pravda. Bylo to totiž řečeno v předchozím díle - PHP používá na
zadávání příkazu SELECT databázi svoji funkci mysql_query. Což je úplně
stejné, jako v případě příkazu CREATE TABLE. A jak uvidíme, podobné to
bude i s ostatními příkazy pro MySQL. S jedním podstatným rozdílem, a
to tím, že: V PŘÍPADĚ, ŽE mysql_query OBSAHUJE PŘÍKAZ SELECT, vrátí
databáze tzv. SADU ZÁZNAMŮ, kterou asi budeme chtít ZPRACOVAT. <br>
</p>
<p>Možná si z minula vzpomenete, že mysql_query vrací false v případě
neúspěchu. Teď to doplním - v případě, že mysql_query obsahuje příkaz
SELECT a nedojde k chybě, vrací mysql_query tzv. identifikátor
výsledku. A ten nám umožní výslednou sadu záznamů zpracovat pomocí PHP.
Příklad uvedu za chvíli.<br>
</p>
<p style="font-style: italic;">Pozn.: Pokud mysql_query která má vrátit
nějaké záznamy z libovolného důvodu selže, vrátí samozřejmě také
hodnotu false.<br>
</p>
<p><span style="font-style: italic;">Pozn. 2: Pokud je dotaz select
napsaný správně, ale vrátí nula záznamů, nepovažuje se to za chybu.</span><br>
</p>
<p>Asi bude nejlepší podívat se na nějaký příklad, a proto tady máme<br>
</p>
<a name="000163"></a><h2>Vyhledávání obcí pomocí PSČ</h2>
<p>To může být zajímavé zpestření nějaké aplikace a navíc to je krásný
příklad na SELECT. Na <a href="http://www.cpost.cz/sluzbyonl/detail.asp?objID=374">stránkách
české pošty</a> je k dispozici ke stažení datový soubor
obsahující názvy všech obcí v ČR a jejich PSČ. Tento soubor jsem si
stáhl, upravil
a nahrál do MySQL. To znamená, že v MySQL máme nyní tabulku, která se
jmenuje psc a obsahuje pole psc a obec. Čistě pro osvěžení paměti -
tabulka vznikla pomocí následujícího příkazu SQL:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">create table psc (obec
varchar (60), psc int)</font>
</code></div>
<!-- Zaza PHP kód END -->
<p style="font-style: italic;">Pozn.: Tohle sem striktně vzato nepatří,
ale asi se budete ptát, jak
jsem tam ta data dostal. Bylo to takhle:<br>
</p>
<ol style="font-style: italic;">
  <li>Stáhl jsem si soubor ze stránek české pošty a zjistil jsem, že je
ve formátu dbf.</li>
  <li>Otevřel jsem si jej v OpenOffice a uložil jako prostý text
oddělený středníky.</li>
  <li>Vzniklý textový soubor jsem uploadoval na server, na němž běží
MySQL.</li>
  <li>Spustil jsem SQL příkaz <a href="http://dev.mysql.com/doc/mysql/en/LOAD_DATA.html">LOAD DATA
INFILE</a>, který textový soubor uložil do tabulky. Ještě o něm bude v
našem seriálu řeč.</li>
</ol>
<p>Celá aplikace bude obsahovat formulář pro zadání PSČ a po jeho
odeslání bude
vypisovat obec, která dané PSČ má. Pozor, jedno PSČ může mít více obcí,
takže s tím budeme počítat. Tady je kód:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">true</font><font color="#007700">;<br>
&nbsp;&nbsp;if (!empty(</font><font color="#0000bb">$_POST</font><font color="#007700">)) </font><font color="#ff8000">// tak už se
odesílalo a musíme kontolovat<br>
&nbsp;&nbsp;</font><font color="#007700">{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">strlen</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">])&lt;&gt;</font><font color="#0000bb">5 </font><font color="#007700">|| !</font><font color="#0000bb">is_numeric</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">]))<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//
kontrolou jsme neprošli<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">echo </font><font color="#dd0000">"PSČ musí být pětimístné číslo"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//
kontolou jsme prošli<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">// zde
je include souboru s konstantami<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from psc where
psc="</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$radku</font><font color="#007700">=</font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$radku</font><font color="#007700">==</font><font color="#0000bb">0</font><font color="#007700">) echo </font><font color="#dd0000">"PSČ "</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">].</font><font color="#dd0000">" nemá, bohužel, žádná
obec"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"PSČ
"</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">].</font><font color="#dd0000">" má následujících
$radku obcí:&lt;BR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"obec"</font><font color="#007700">].</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endwhile;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
if (</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">):</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&lt;form method="post" action="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;PSČ: &lt;input name="psc" value="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="Submit"
name="odesli"&gt;<br>
&nbsp;&nbsp;&lt;/form&gt;<br>
<font color="#0000bb">&lt;?</font><font color="#007700">endif;</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/38_psc.html" target="_blank">Ukázat
skript</a></p>
<p>Z věcí, které nás zajímají v souvislosti s MySQL, si všimněte
zejména řádku s mysql_query. Její výsledek je vrácen do proměnné
$vysledek, která zjednodušeně řečeno zastupuje výslednou sadu záznamů.
A máme tu dvě funkce, které jsou pro nás nové:<br>
</p>
<p><span style="font-weight: bold;">mysql_num_rows</span><br>
Vrací počet řádků ve výsledné sadě záznamů. To se nám hodí, protože tím
pádem budeme moci ošetřit situaci, kdy není vrácen žádný záznam a
zařídit se podle toho.<br>
</p>
<p><span style="font-weight: bold;">mysql_fetch_array</span><br>
Je poměrně často používaná funkce, která vrátí obsah jednoho řádku z
výsledné sady záznamů jakožto <a href="#000029">asociativní
pole</a>. Když se zavolá opakovaně, vrátí další řádek sady. Jestliže
řádky došly, vrátí false. Je tedy velmi jednoduché procházet sadou
pomocí konstrukce while.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Pokud Vám není jasné, proč
je formulář ve skriptu až na konci, podívejte se na díl seriálu o </span><a style="font-style: italic;" href="#000105">ověřování
dat z formulářů</a><span style="font-style: italic;">. Protože to je
důležité, dodám, že při podobné struktuře programu je ověřování dat z
formulářů nezbytné. Kdybychom totiž proměnnou $_POST["psc"]
neověřovali, může nám nějaký škodolibý návštěvník našich stránek do
formuláře podstrčit něco, co MySQL pochopí jako jiný příkaz jazyka.
Tento druh útoku se nazývá SQL injection.</span><br>
</p>
<p></p>
<p>Jak vidíme, je tedy poměrně snadné vybrat z databáze nějaké řádky.
Příště si ukážeme na dvě úlohy, které s příkazem SELECT a PHP úzce
souvisí - bude řeč o tom, jak prezentovat data ze sad záznamů
prostřednictvím HTML tabulek a jak dlouhé sady záznamů stránkovat.</p>

<a name="000164"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (39) - Zobrazujeme a stránkujeme data</h2>
			<p class="perex">Vybrat data z MySQL už umíme. Jak je ale hezky prezentovat?

				<br>
			</p>
			<p>V minulém dílu našeho seriálu jsme se zabývali otázkou výběru dat z
MySQL pomocí příkazu SELECT. Umět data správně vybrat není ale to
jediné - my je musíme uživateli rovněž v nějaké čtivé podobě
naservírovat. Dnes si ukážeme, jak na to.</p>
<a name="000165"></a><h2>Stránkujeme</h2>
<p>Zkuste na chvíli zavzpomínat na předchozí díl našeho seriálu. Tam
jsme
si pořídili databázi všech obcí a jejich PSČ v České republice. Dejme
tomu, že budeme chtít všechny obce a jejich PSČ nějak vypsat. Asi
první, co Vás napadne, bude:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from psc"</font><font color="#007700">);<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)) echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"obec"</font><font color="#007700">].</font><font color="#dd0000">" "</font><font color="#007700">.</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">].</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>a jistě by to fungovalo, ovšem narážíme zde na vážné problémy s
výkonem. Tabulka obcí má totiž více než 16000 řádků. Kdybyste něco
takového napsali a zkusili spustit, může dojít k následujícím problémům:<br>
</p>
<ul>
  <li>Podstatně zatížíte databázi. Vrácení 16000 záznamů přece jen
nějakou
dobu potrvá.</li>
  <li>Co je horší, výsledná stránka bude mít téměř půl megabajtu.
Člověku s modemem se bude natahovat déle než minutu.</li>
  <li>V závislosti na nastavení webového serveru a/nebo PHP může být
rovněž překročena maximální doba pro běh skriptu a ten bude přerušen.</li>
</ul>
<p>Podobným lapáliím se můžeme vyhnout, jestliže budeme výpisy výsledné
sady záznamů stránkovat. Naštěstí MySQL obsahuje šikovné rozšíření
příkazu SELECT, které nám umožní vrátit část sady záznamů danou prvním
řádkem a počtem. S úspěchem používám následující kód:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;define </font><font color="#007700">(</font><font color="#dd0000">"ROWS"</font><font color="#007700">, </font><font color="#0000bb">50</font><font color="#007700">);<br>
&nbsp;&nbsp;if (!isset(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"celkem"</font><font color="#007700">])) </font><font color="#ff8000">//pokud nevíme,
kolik bude záznamů tak to zjistíme... <br>
&nbsp;&nbsp;</font><font color="#007700">{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select count(*) as
pocet from psc"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">mysql_fetch_array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$celkem</font><font color="#007700">=</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"pocet"</font><font color="#007700">];<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else <br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$celkem</font><font color="#007700">=</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"celkem"</font><font color="#007700">];<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$celkem</font><font color="#007700">&gt;</font><font color="#0000bb">ROWS</font><font color="#007700">) <br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (!isset(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"od"</font><font color="#007700">])) </font><font color="#0000bb">$od</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; else </font><font color="#0000bb">$od</font><font color="#007700">=</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"od"</font><font color="#007700">]; <br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from psc"</font><font color="#007700">.</font><font color="#dd0000">" limit "</font><font color="#007700">.(</font><font color="#0000bb">$od</font><font color="#007700">-</font><font color="#0000bb">1</font><font color="#007700">).</font><font color="#dd0000">", "</font><font color="#007700">.</font><font color="#0000bb">ROWS</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Záznamů:
"</font><font color="#007700">.</font><font color="#0000bb">$od</font><font color="#007700">.</font><font color="#dd0000">"-"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo ((</font><font color="#0000bb">$od</font><font color="#007700">+</font><font color="#0000bb">ROWS</font><font color="#007700">-</font><font color="#0000bb">1</font><font color="#007700">)&lt;=</font><font color="#0000bb">$celkem</font><font color="#007700">)?(</font><font color="#0000bb">$od</font><font color="#007700">+</font><font color="#0000bb">ROWS</font><font color="#007700">-</font><font color="#0000bb">1</font><font color="#007700">):</font><font color="#0000bb">$celkem</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">" z celkem
$celkem&amp;nbsp;&amp;nbsp;&amp;nbsp;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//začátek
- vytvoř odkaz pouze pokud nejsme na začátku<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">if
(</font><font color="#0000bb">$od</font><font color="#007700">==</font><font color="#0000bb">1</font><font color="#007700">) echo </font><font color="#dd0000">"Začátek&amp;nbsp;|&amp;nbsp;"</font><font color="#007700">; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else echo </font><font color="#dd0000">"&lt;a href=\""</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">].</font><font color="#dd0000">"?celkem=$celkem&amp;od=1</font><font color="#007700">\"</font><font color="#dd0000">&gt;Začátek&lt;/a&gt;&amp;nbsp;|&amp;nbsp;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//zpět
- vytvoř odkaz pouze pokud nejsme v prvních ROWS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">if
(</font><font color="#0000bb">$od</font><font color="#007700">&lt;</font><font color="#0000bb">ROWS</font><font color="#007700">) echo </font><font color="#dd0000">"Předchozí&amp;nbsp;|&amp;nbsp;"</font><font color="#007700">; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else echo </font><font color="#dd0000">"&lt;a href=\""</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">].</font><font color="#dd0000">"?celkem=$celkem&amp;od="</font><font color="#007700">.(</font><font color="#0000bb">$od</font><font color="#007700">-</font><font color="#0000bb">ROWS</font><font color="#007700">).</font><font color="#dd0000">"\"&gt;Předchozí&lt;/a&gt;&amp;nbsp;|&amp;nbsp;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//další - vytvoř,
pouze pokud nejsme v posledních ROWS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">if
(</font><font color="#0000bb">$od</font><font color="#007700">+</font><font color="#0000bb">ROWS</font><font color="#007700">&gt;</font><font color="#0000bb">$celkem</font><font color="#007700">) echo </font><font color="#dd0000">"Následující&amp;nbsp;|&amp;nbsp;"</font><font color="#007700">; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else echo </font><font color="#dd0000">"&lt;a href=\""</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">].</font><font color="#dd0000">"?celkem=$celkem&amp;od="</font><font color="#007700">.(</font><font color="#0000bb">$od</font><font color="#007700">+</font><font color="#0000bb">ROWS</font><font color="#007700">).</font><font color="#dd0000">"\"&gt;Následující&lt;/a&gt;&amp;nbsp;|&amp;nbsp;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//poslední - to je
posledních (zbytek po dělení ROWS) záznamů<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">if
(</font><font color="#0000bb">$od</font><font color="#007700">&gt;</font><font color="#0000bb">$celkem</font><font color="#007700">-</font><font color="#0000bb">ROWS</font><font color="#007700">) echo </font><font color="#dd0000">"Konec&amp;nbsp;&lt;BR&gt;"</font><font color="#007700">;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else echo </font><font color="#dd0000">"&lt;a href=\""</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">].</font><font color="#dd0000">"?celkem=$celkem&amp;od="</font><font color="#007700">.(</font><font color="#0000bb">$celkem</font><font color="#007700">-</font><font color="#0000bb">$celkem</font><font color="#007700">%</font><font color="#0000bb">ROWS</font><font color="#007700">+</font><font color="#0000bb">1</font><font color="#007700">).</font><font color="#dd0000">"\"&gt;Konec&lt;/a&gt;&lt;BR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/39_strankovani.html" target="_blank">Ukázat
celý skript</a></p>
<p>Všimněte si rozšíření LIMIT příkazu SELECT. Umožňuje nám vrátit
řádky "počínaje nějakým" a jen "určitý počet". Celý skript funguje
následovně:<br>
</p>
<ul>
  <li>Jestliže je zavolán poprvé, zobrazí se prvních ROWS záznamů a
vytvoří se odkazy na stránkování<br>
  </li>
  <li>Jestliže klikneme na odkaz "začátek", "předchozí", "následující"
nebo "konec", zavolá se skript s parametry.</li>
  <li>Počet řádků si zjistíme pouze poprvé a pak jej předáme jako
parametr $_GET["celkem"]</li>
  <li>Stránkovací odkazy jsou inteligentní. To například znamená, že
jsme-li na začátku sady, výraz "Začátek" není odkaz.<br>
  </li>
  <li>A také se může stát, že celkový počet záznamů je menší než
maximální, a pak stránkovací povely vůbec nezobrazujeme</li>
</ul>
<p>Zbytek skriptu je pouhá matematika; zmíním se jen o tom, že příkaz
"Konec" nezobrazí posledních ROWS záznamů, ale jen zbytek. Například
máme-li celkem 230 záznamů a krok 100, nezobrazí se nakonec záznamy
131-230, ale 201 až 230. <br>
</p>
<p>Chování stránkování si můžete upravit, běžně se místo
textu používají grafické symboly a počet záznamů na stránce je
nastavovací. Je rovněž možné posílat parametry pomocí metody POST, nebo
je možné skript upravit a použít jako include soubor na více místech.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Samozřejmě, že úplně
nejlepší je rozsáhlé sady záznamů ve skriptech nemít. Někdy se tomu ale
nevyhnete.</span><br>
</p>
<p></p>
<a name="000166"></a><h2>Prezentace dat pomocí tabulek</h2>
<p>Zatím jsme při vypisování dat do prohlížeče používali jen echo a
&lt;BR&gt;. To asi v reálné aplikaci stačit nebude. Poměrně časté je
vypisovat sady záznamů do tabulek. Není to vůbec složité a&nbsp;
vlastně to již umíme</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;TABLE&gt;<br>
<font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from psc where
left(obec,2)='Be'"</font><font color="#007700">);<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&lt;TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"obec"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#007700">endwhile;<br>
</font><font color="#0000bb">?&gt;<br>
</font>&lt;/TABLE&gt;</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>protože kód PHP se s HTML může proplétat. Kvalitní materiál pro
studium tvorby tabulek máme na našem serveru díky <a href="http://www.linuxsoft.cz/article.php?id_article=305">seriálu
Pavla Káchy</a>, takže se tam můžete podívat.<br>
</p>
<p>Často se dělá to, že se sudé a liché řádky v databázi odliší jinou
barvou pozadí. Což není problém - můžeme si například zavést logickou
proměnnou a přepínat její hodnotu mezi TRUE a FALSE a podle toho pak
řádek obarvovat:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&lt;TR <font color="#0000bb">&lt;?</font><font color="#007700">if (</font><font color="#0000bb">$sudy</font><font color="#007700">) echo </font><font color="#dd0000">"bgcolor=silver"</font><font color="#0000bb">?&gt;</font>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"obec"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;&nbsp;&nbsp;$sudy</font><font color="#007700">=!</font><font color="#0000bb">$sudy</font><font color="#007700">;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;endwhile;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/39_tabulky.html" target="_blank">Ukázat
celý
skript</a></p>
<p>To má ale jednu zásadní nevýhodu - každý druhý tag &lt;TR&gt; má
atribut bgcolor, což neúměrně nafukuje zdrojový kód. Nezapomeňme, že
zdrojový kód se musí do prohlížeče natáhnout chtěnechtě celý. Asi
nejefektivnější řešení by bylo použít kaskádové styly. O tom se zase na
Linuxsoftu dočtete <a href="http://www.linuxsoft.cz/article_list.php?id_kategory=201">zde</a>.
Princip prolínání kódu by byl stejný.<br>
</p>
<p>V dalším díle seriálu si řekneme něco o tom, jak v databázi MySQL s
daty pomocí PHP manipulovat. To znamená nejen je číst, ale i zapisovat.</p>
<a name="000167"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (40) - PHP a vkládání záznamů do databází</h2>
			<p class="perex">Z databází pochopitelně budeme data jednak vybírat, a jednak je do
ní musíme nějak dostat. Dnes si ukážeme, jak vkládat data do MySQL. A vytvoříme si knihu hostů.
				<br>
			</p>
<a name="000168"></a><h2>Trocha SQL</h2>
<p>V MySQL slouží ke vkládání do tabulky <a href="http://dev.mysql.com/doc/mysql/en/INSERT.html">příkaz INSERT</a>.
Jeho typická
syntaxe je:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">INSERT INTO [název
tabulky] (sloupec, ...) VALUES (hodnota, ...)</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>To platí v případě, že data do tabulky vkládáme z kódu a přidá to
jeden řádek. Data ovšem můžeme vkládat rovněž z jiné tabulky. Pak je
syntaxe následující:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">INSERT INTO [název
tabulky] (sloupec, ...) SELECT ...</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a dodejme, že tato syntaxe může vložit obecně nula až mnoho řádků.
Tabulka, do které vkládáme, musí v databázi již existovat. Pokud by
neexistovala, měli bychom ji nejprve vytvořit příkazem CREATE TABLE.
Příkaz INSERT patří mezi tzv. manipulační příkazy jazyka SQL. To
znamená, že po jeho použití se data v databázi mohou změnit. Což se po
SELECT nikdy nestane, SELECT je tedy naproti tomu výběrový příkaz.<br>
</p>
<p>Při použití příkazu INSERT si musíme v praxi dát pozor na několik
obecných zásad:<br>
</p>
<ul>
  <li>Vkládaná data by se měla, pokud je to možné, nějak odkontrolovat
ještě předtím, než je pošleme databázi. Například můžeme kontrolovat
jejich velikost a podobně.</li>
  <li>Zejména pro skripty na internetu platí, že by měla existovat
nějaká možnost nechat si zobrazit data předtím, než je vložíme.
Všimněte si, že přesně takhle to funguje například v diskusích k
článkům tady na linuxsoftu.</li>
  <li>Uživatel by měl být nějak informován o tom, že se operace
podařila.</li>
</ul>
<p>Uvědomte si rovněž, že selhání příkazů měnících data může mít horší
následky než selhání výběrových dotazů. Pokud by například selhal
příkaz ukládající do databáze čas Vašeho příchodu do práce, může to být
daleko horší než selhání dotazu, který zobrazuje Vaše přesčasy. <br>
</p>
<p>Poznámka pro workoholiky: Vás se to netýká.<br>
</p>
<a name="000169"></a><h2>Insert pomocí PHP</h2>
<p>Jak jste asi čekali, v PHP se přidávací dotazy rovněž realizují
pomocí funkce mysql_query. V případě manipulačních dotazů vrací funkce
mysql_query TRUE pokud se povedla, v ostatních případech vrací FALSE.
Funkce mysql_query tedy nijak nevrací počet vložených záznamů. Ten
můžeme zjistit pomocí jiné funkce, a sice mysql_affected_rows. Ta
funguje tak, že vrátí počet vložených (změněných, odstraněných) řádků
ovlivněných posledním manipulačním dotazem. Pokud poslední manipulační
dotaz selhal, vrací -1.<br>
</p>
<p>Jako příklad si můžeme vytvořit jednoduchou knihu hostů. Bude to
založeno na třech vzájemně provázaných skriptech, přičemž<br>
</p>
<ul>
  <li>jeden skript bude zajišťovat zobrazování záznamů pomocí příkazu
SELECT.<br>
  </li>
  <li>druhý skript tu bude proto, aby zobrazil formulář pro vložení
záznamu a data nám před vložením zkontroloval.</li>
  <li>třetí skript provede vlastní "databázovou" práci.<br>
  </li>
</ul>
<p>Tabulka obsahující zapsané texty bude velmi jednoduchá. Bude
obsahovat jeden sloupec pro zápis vzkazu a druhý sloupec, v němž bude
uložen čas zápisu. Vytvoříme ji následujícím příkazem CREATE TABLE:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">CREATE TABLE
`kniha_hostu` (<br>
`cas` INT NOT NULL ,<br>
`vzkaz` VARCHAR( 255 ) NOT NULL);<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Sluší se podotknout, že datový typ int budeme používat pro uložení
data záznamu ve formátu unixového časového razítka. To je počet vteřin,
který uplynul od 1.1.1970. Tím pádem se úplně vyhneme použití
databázových datových typů pro uložení datumů a časů.<br>
</p>
<p><span style="font-weight: bold;">Skript pro výběr a zobrazení záznamů</span><br>
To je vlastně skript, který jsme již dříve použili v příkladu o
stránkování. Jedná se pouze o výběr záznamů a jejich zobrazení:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;h1&gt;Naše kniha
hostů&lt;/h1&gt;<br>
&lt;p&gt;&lt;a href="40_insert.php"&gt;Vložit nový záznam do knihy
hostů&lt;/a&gt;&lt;/p&gt;<br>
<font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;define </font><font color="#007700">(</font><font color="#dd0000">"ROWS"</font><font color="#007700">, </font><font color="#0000bb">10</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#ff8000">// stránkování ...<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from
kniha_hostu order by cas desc"</font><font color="#007700">);&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)) <br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;p&gt;"</font><font color="#007700">.</font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"j.n.Y G:i:s"</font><font color="#007700">, (</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">])).</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"vzkaz"</font><font color="#007700">].</font><font color="#dd0000">"&lt;/p&gt;\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/40_select.html" target="_blank">Ukázat
celý skript</a>
</p>
<p>Tady stojí za zmínku pouze to, že náš příkaz SELECT je tak protřelý,
že umí seřadit záznamy podle doby zadání, a to sestupně.<br>
</p>
<p><span style="font-weight: bold;">Skript pro zadání a kontrolu dat</span><br>
To je složitější záležitost a zobrazím Vám pro lepší pochopení celý
skript:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">true</font><font color="#007700">;<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"odeslano"</font><font color="#007700">]) <br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">strlen</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"vzkaz"</font><font color="#007700">])==</font><font color="#0000bb">0 </font><font color="#007700">|| </font><font color="#0000bb">strlen</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"vzkaz"</font><font color="#007700">])&gt;</font><font color="#0000bb">255</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Vzkaz
by měl mít mezi 1 - 255 znaků"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Náhled vzkazu před
uložením&lt;/h1&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div style="background :
Silver;"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">nl2br</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"vzkaz"</font><font color="#007700">])</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form method="post" action="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="hidden"
name="vzkaz" value="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"vzkaz"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="Submit"
name="zpet" value="&lt;&lt; Zpět"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form method="post"
action="40_modify.php"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="hidden"
name="vzkaz" value="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"vzkaz"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="Submit"
name="Uložit" value="Uložit &gt;&gt;"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">}<br>
&nbsp;&nbsp;}<br>
if (</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">):</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&lt;h1&gt;Vložení vzkazu&lt;/h1&gt;<br>
&nbsp;&nbsp;&lt;form method="post" action="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Váš vzkaz:&lt;br&gt;&lt;textarea rows="6"
name="vzkaz" cols="40"&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"vzkaz"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/textarea&gt;&lt;br&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="hidden" name="odeslano"
value="true"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="Submit" name="odeslat"
value="&gt;&gt; Náhled"&gt;<br>
&nbsp;&nbsp;&lt;/form&gt;<br>
</font></code>
<p><code><font color="#000000"><font color="#0000bb">&lt;?</font><font color="#007700">endif;</font><font color="#0000bb">?&gt;</font></font></code></p>
<p><code>
</code></p>
</div>
<!-- Zaza PHP kód END -->
<p>Celý skript obsahuje tři formuláře. Proč tolik? Spodní formulář je
"klasický" formulář pro zadání vzkazu. Ten je po odeslání zkontrolován
s tím, že pokud je vzkaz příliš krátký nebo příliš dlouhý, je to
vráceno uživateli k opravení. </p>
<p>Druhý formulář se opět odkazuje na stejnou stránku a je tu proto,
aby si uživatel mohl text ke vložení vizuálně odkontrolovat předtím,
než jej odešle. Může si třeba všimnout nějaké pravopisné chyby a
podobně. Protože nic uživateli nebrání zadat mimo jiné i řádkování,
obsahuje skript formátovací příkaz nl2br, který text "rozhodí" do řádků.</p>
<p>A konečně třetí formulář odesílá data skriptu 40_modify.php, jež
provede samotné vložení řádku do databáze.<br>
</p>
<p><span style="font-weight: bold;">Skript pro vložení záznamu do
databáze </span><br>
je relativně jednoduchý:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"insert into kniha_hostu
(cas, vzkaz) values ("</font><font color="#007700">.</font><font color="#0000bb">time</font><font color="#007700">().</font><font color="#dd0000">",'"</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"vzkaz"</font><font color="#007700">].</font><font color="#dd0000">"')"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$path</font><font color="#007700">=</font><font color="#0000bb">SubStr</font><font color="#007700">(</font><font color="#0000bb">$SCRIPT_NAME</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">StrRPos</font><font color="#007700">(</font><font color="#0000bb">$SCRIPT_NAME</font><font color="#007700">,</font><font color="#dd0000">"/"</font><font color="#007700">)).</font><font color="#dd0000">"/40_select.php"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"Location: http://"</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SERVER_NAME"</font><font color="#007700">].</font><font color="#dd0000">":"</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SERVER_PORT"</font><font color="#007700">].</font><font color="#0000bb">$path</font><font color="#007700">);&nbsp;&nbsp;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Všimněme si dvou věcí: Za prvé toho, že příkaz insert obsahuje
výsledek funkce time. Ta vrátí unixové časové razítko jakožto celé
číslo, což je přesně to, co potřebujeme. Za druhé - ihned po vložení
řádku se přesouváme na jiný skript! To je důležité ze dvou podstatných
důvodů:<br>
</p>
<ul>
  <li>Psychologický důvod - Uživatel by rád viděl, že je záznam
skutečně vložen. V našem případě jej tedy přesměrujeme na stránku,
která mu jeho záznam zobrazí (bude nejspíš první nahoře, protože řadíme
sestupně podle data a času vložení)</li>
  <li>Technický důvod - kdybychom zůstali na stránce pro vložení
záznamu a uživatel by obnovil stránku v prohlížeči, uložil by se záznam
dvakrát. Podobný efekt by mělo procházení historie dokumentů. Takhle se
do historie uloží pouze návštěva stránky s formulářem.</li>
</ul>
<p>A ještě poznámka: Při korektuře seriálu jsem si všiml, že spousta
uživatelů vkládá do knihy návštěv HTML kód. Soubory byly upraveny tak,
aby se takový kód ignoroval.<br>
</p>
<a name="000170"></a><h2>Závěr</h2>
<p>Jelikož byl příklad trochu rozsáhlý, je
nejdůležitější pochopit, jak spolu skripty pro <a href="./examples/40_select.html" target="_blank">výběr</a>,
<a href="./examples/40_insert.html" target="_blank">zadání</a>
a <a href="./examples/40_modify.html" target="_blank">akci</a>
vzájemně souvisejí.<br>
</p>
<p style="font-style: italic;">Pozn.: Protože už tak je to relativně
složité, v příkladech jsem se prakticky vůbec nezabýval nějakým
formátováním výstupu. V praxi by se to pochopitelně pro reálný provoz
muselo trochu učesat.</p>
<a name="000171"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (41) - Měníme data v databázích</h2>
			<p class="perex">Změna je život! Platí to i pro data v databázích a my se dnes naučíme jak je měnit.
				<br>
			</p>
			<p>Z databáze již umíme záznamy vybírat a umíme je do ní vkládat. Další
úkon, který
nás čeká je umět data upravit neboli aktualizovat.<br>
</p>
<a name="000172"></a><h2>Zase trocha SQL</h2>
<p>V SQL se k aktualizaci řádku nebo řádků v databázi používá příkaz
UPDATE. UPDATE narozdíl od INSERT nevkládá do databáze žádné řádky, ale
upravuje existující data. To znamená, že provedete-li na tabulkce
příkaz UPDATE, počet řádků v této tabulce se nezmění, ale mohou se
změnit údaje v jednotlivých řádcích. V MySQL je pochopitelně i k
příkazu UPDATE rozsáhlá <a href="http://dev.mysql.com/doc/mysql/en/UPDATE.html">dokumentace</a>.
Jeho nejprimitivnější forma pak
je:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">UPDATE tabulka SET
sloupec=hodnota [,jiný sloupec=hodnota...]</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Pokud použijete příkaz tak, jak je uveden výše, bude zaktualizována
celá tabulka, to znamená každý její řádek. Nic vám samozřejmě nebrání
použít klauzuli WHERE a vybrat jen některé řádky, které se budou
aktualizovat. MySQL umí dokonce použít rozšíření LIMIT pro stanovení
maximálního počtu řádků, které se mají měnit.<br>
</p>
<p>Aby to nebyla jen suchá teorie předpokládejme na chvíli, že jste se
práve prolomili do databáze obsahující podklady pro výpočet mezd ve
Vaší firmě. Můžete si s ní dělat co chcete, třeba změnit políčko PLAT
(to je představa...). Nejprve si tedy ukažme plošný přístup:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">UPDATE PLATY SET PLAT =
20000</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Nebo se můžeme rozhodnout zvýšit všem plat o 20% (z čehož je vidět,
že nové hodnoty v tabulce mohou záviset na hodnotách stejných sloupců
před jejich aktualizací):</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">UPDATE PLATY SET PLAT =
PLAT*1.2</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Nebo se můžeme rozhodnout podle hesla "každý dobrý skutek musí být
po zásluze potrestán" a snížit platy jen těm, kdo je mají vysoké:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">UPDATE PLATY SET PLAT =
PLAT*0.8 WHERE PLAT &gt; 20000</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a konečně se můžeme zcela nekolegiálně obohatit sami příkazem ve
smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">UPDATE PLATY SET PLAT =
PLAT*2 WHERE PRACOVNIK = 'Petr Zajíc'</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Použití WHERE je na příkladech dobře vidět - zatímco první dva
manipulují všemi záznamy v databázi, třetí manipuluje jen omezenou
skupinou šťastlivců a poslední dokonce pouze jedním záznamem. <br>
</p>
<p>Kromě příkazu UPDATE, který je v SQL standardně, má MySQL ještě
příkaz REPLACE. Nemám ho moc rád, ale funguje následovně: REPLACE se
chová jako INSERT s tím, že pokud je zároveň<br>
</p>
<ul>
  <li>v tabulce, do níž se vkládá definován primární nebo jedinečný
klíč a <br>
  </li>
  <li>v datech, která se vkládají jeden nebo více záznamů v nichž se
shoduje hodnota sloupce s primárním nebo jedinečným klíčem s hodnotou v
tabulce, do níž se vkládá<br>
  </li>
</ul>
<p>nejsou data vložena jako nový řádek, ale existující data jsou
přepsána. Tento příkaz vám <span style="font-style: italic;">může</span>
ušetřit nějaký čas. (Přesně řečeno místo INSERT a UPDATE použijete
REPLACE). Rád ho nemám proto, že není standardizován.<br>
</p>
<a name="000173"></a><h2>Aktualizujeme pomocí PHP</h2>
<p>Tady je situace veselá, protože platí většina toho, co pro INSERT.
Takže se můžete podívat do <a href="#000169">minulého dílu</a>,
a já krátce zopakuji:<br>
</p>
<ul>
  <li>rovněž na poslání příkazu UPDATE do MySQL pomocí PHP se používá
funkce mysql_query.</li>
  <li>mysql_affected_rows vrací počet aktualizovaných záznamů nebo -1,
pokud dotaz selhal. Hodnotu lze testovat a tak zjistit, zda se
aktualizace povedla.<br>
  </li>
  <li>mysql_query vrací TRUE pokud se příkaz povedl, FALSE pokud selhal.</li>
  <li>Pokud aktualizace nějakým způsobem závisí na hodnotách zadaných
uživatelem, měly by se tyto hodnoty pečlivě zkontrolovat ještě předtím,
než je dotaz proveden.</li>
</ul>
<p>Některé věci, které jsme uvedli v souvislosti s příkazem INSERT pro
UPDATE naopak neplatí, nebo neplatí tak striktně. Například bude
možná obtížné nebo dokonce nemožné nějak předem odkontrolovat, jaký
dopad
bude mít na databázi provedení příkazu UPDATE. Řeší se to tak, že se
stav tabulky zobrazí <span style="font-style: italic;">po</span>
provedení příkazu (třeba chcete-li změnit při nakupování přes
elektronický obchod množství zboží v košíku, většinou je to provedeno a
<span style="font-style: italic;">potom</span> je Vám obsah košíku
zobrazen). Rovněž někdy nebývá tak důležité zamezit opakované
aktualizaci řádku způsobené pohybem v historii dokumentů nebo
refreshováním stránky.<br>
</p>
<a name="000174"></a><h2>Příklad</h2>
<p>My jsme si ve třicátém dílu našeho seriálu vytvořili <a href="#000130">počitadlo</a>,
které ukládalo údaje o počtu návštěv na stránce do textového souboru.
Zkusme si nyní tento triviální příklad přepsat tak, aby používal jako
úložiště databázi! Definice tabulky bude opravdu primitivní:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">create table pocitadlo
(pocet int);<br>
insert into pocitadlo (pocet) values(0);<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>A celý skript bude vypadat následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"update pocitadlo set
pocet = pocet+1"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select pocet from
pocitadlo"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">mysql_fetch_array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$celkem</font><font color="#007700">=</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"pocet"</font><font color="#007700">];<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Již máme zaznamenáno
$celkem přístupů!!!"</font><font color="#007700">; <br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Skript není kromě použití příkazu update opravdu ničím zajímavý.
Všimněte si, že jsem hned při definici tabulky nastavil výchozí hodnotu
počitadla na nulu, takže jsem se tím pak již nemusel zabývat v kódu PHP.<br>
</p>
<p>Snad by se dala rozebrat jedna věc - z příkladu je vidět, že na
uložení opravdu jednoduchých informací většinou nejsou databáze
potřeba. Tento skript zcela určitě poběží déle než skript z třicátého
dílu, kde jsme ukládali stav počitadla do souboru, protože režie
spojená s připojením k databázi je téměř určitě větší než režie spojená
s otevřením souboru. Takže jsme použili přístup "s dělem na komára".
Ale čistě pro ukázku fungování příkazu UPDATE to postačilo.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Tento skript však sám o
sobě řeší problém se souběžností. Jestliže by se totiž pokusilo více
uživatelů najednou přistupovat ke stránkám, na nichž počitadlo běží,
databáze by si s tím dokázala poradit. Logika zabraňující zničení dat v
případě vícenásobných přístupů je totiž v každé databázi již obsažena.</span><br>
</p>
<p></p>
<p><span style="font-style: italic;">Pozn.: V praxi to bývá tak, že
když už se výsledky počítání ukládají do databáze, používá se pro každý
přístup samostatný řádek. Neeviduje se jen počet přístupů, ale i další
věci, jako například IP adresa z níž byl přístup proveden, použitý
prohlížeč a tak dále. Je jasné, že pak by se použil INSERT, ne UPDATE.</span><br>
</p>
<p>Použití UPDATE není ve skriptech tak časté jako SELECT nebo INSERT.
Kontrolujte data a dávejte si pozor, zda aktualizujete právě ty řádky,
které chcete skutečně měnit. A ještě jedna přátelská rada na závěr:
Jestliže ladíte kód hojně využívající UPDATE, ušetří Vám spoustu času,
když budete mít k dispozici zálohu databáze ;-)<br>
</p>
<a name="000175"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (42) - Odstraňujeme databázová data</h2>
			<p class="perex">Pakliže se Vám data v databázi nelíbí, je tento díl seriálu přesně pro vás. Dozvíte se totiž, jak je mazat.
				<br>
			</p>
			<p>Někdy bývá potřeba data z databáze nemilosrdně odstranit. Pojďme si
povědět, jak na tuto destruktivní činnost jít.<br>
</p>
<a name="000176"></a><h2>Smazat je smazat<br>
</h2>
<p>Ideální je udělat následující zkušenost metodou pokus-omyl, protože
potom
si to zapamatujete. Data k odstranění budou SKUTEČNĚ odstraněna. Takže
špatně napsaný odstraňovací dotaz Vám může celou databázi rozhodit.
Proto opravdu profesionální databázové aplikace přímé mazání záznamů
moc nepoužívají. V profi prostředí se většinou používá jeden nebo
kombinace následujících přístupů:<br>
</p>
<ul>
  <li>Někdy se místo odstraňování záznamů vkládají záznamy s opačnými
hodnotami (například faktura a stornodoklad).</li>
  <li>Jindy se řádky nemažou, ale nastavuje se jim zvláštní příznak
(existuje dejme tomu sloupec obsahující logickou hodnotu DELETED),
aplikace pochopitelně musí být tomuto trendu přizpůsobena.</li>
  <li>Ještě jindy se řádky sice z originální tabulky odstraní, ale
nezmizí úplně, nýbrž jsou přesunuty do jiné tabulky (ta může mít
stejnou strukturu jako tabulka původní).</li>
  <li>Konečně se dělá to, že se protokolují odstraňovací dotazy (kdo a
kdy to udělal), aby se případný viník mohl alespoň najít a zlynčovat.</li>
</ul>
<p>Všimněte si, že první tři přístupy mají tu výhodu, že "smazání" lze
vrátit zpět. Jsou to ale obecně poměrně pokročilá řešení, která mají
také své nevýhody. Kdybyste se do toho chtěli někdy pouštět, měli byste
vědět, že:<br>
</p>
<ul>
  <li>to bude obecně pomalejší než prosté odstranění dat</li>
  <li>to bude vyžadovat větší prostor v databázi</li>
  <li>bude to náročnější na programování</li>
  <li>se to dá hodně zjednodušit použitím "chytřejších" databází</li>
</ul>
<p>Pokud použijete PHP a MySQL a rozhodnete se pro některé z výše
uvedených pokročilých řešení, budete si je muset víceméně napsat. </p>
<p><span style="font-style: italic;">Pozn.: Tento typ úloh se nejlépe
realizuje s databázemi, které umějí používat uložené procedury a
triggery. MySQL zatím nic z toho neumí, měl by se to objevit v
"pětkových" verzích. PostgreSQL umí obojí. Uložená procedura je
programový kód, který se píše pomocí SQL a spouští se na databázovém
serveru. Trigger je uložená procedura, která se na nějaké tabulce
spustí vždy, když na ní dojde k definované operaci měnící data. Pomocí
procedur a triggerů například vůbec není problém napsat kód, který při
odstranění dat uloží kopii smazaných dat nějam jinam. Což je přesně
jedna z metod popsaných výše. PHP o tom vůbec nemusí vědět.</span><br>
</p>
<a name="000177"></a><h2>Co umí MySQL</h2>
<p>Především je potřeba si uvědomit, že někdy není nutné odstraňovat
celý záznam (řádek). Často potřebujeme odstranit pouze hodnoty v
nějakých sloupcích. K tomu slouží příkaz UPDATE, kterým můžeme nastavit
hodnotu ve sloupci na NULL, neboli neznámou. Takže následující příkaz
jazyka SQL je zcela legitimní:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">UPDATE tabulka SET
sloupec=NULL</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>O speciální hodnotě NULL jsme již v seriálu mluvili. Je to hodnota <span style="font-style: italic;">neznámá</span>, takže se chová zvláštně.
Počítejte s tím, že žádná hodnota NULL se nerovná jiné hodnotě NULL a
že výsledek většiny matematických operací, jichž se účastní NULL jako
jeden z členů je zase NULL. (Například NULL+3=NULL, protože když k
neznámému číslu přičteme trojku, výsledek je zase neznámý). Zdůrazňuji
to proto, že je snadné na to zapomenout. Tak například v tabulce
zaměstnanců bychom si mohli myslet, že:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">SELECT * FROM
zamastnanci WHERE PLAT&gt;10000<br>
SELECT * FROM zamestnanci WHERE PLAT&lt;=10000</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>vrátí dohromady všechny zaměstnance. Tak to nemusí nutně být;
jestliže jsou ve sloupci PLAT povoleny hodnoty NULL (výše platu je
neznámá!) mohou existovat řádky, které nejsou vráceny ani prvním, ani
druhým dotazem. Takže pozor na to.<br>
</p>
<p><span style="font-weight: bold;">DELETE</span><br>
Ke "klasickému" promazávání řádků z tabulky slouží <a href="http://dev.mysql.com/doc/mysql/en/DELETE.html">příkaz DELETE</a>.
Jeho nejjednodušší syntaxe je:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">DELETE FROM název_tabulky</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Kterýžto příkaz odstraní všechny řádky z tabulky. Prakticky vždy se
ale používá buďto ve spojení s klauzulemi WHERE nebo LIMIT. DELETE je
opakem INSERTu a platí o něm plnou měrou to, co bylo řečeno v úvodu.<br>
</p>
<p><span style="font-weight: bold;">TRUNCATE TABLE</span><br>
je příkaz podobný DELETE s tím rozdílem, že odstraňuje a znovuvytváří
celkou tabulku. V praxi to může být podstatně rychlejší než použití
DELETE, protože DELETE postupuje řádek po řádku. <a href="http://dev.mysql.com/doc/mysql/en/TRUNCATE.html">TRUNCATE TABLE</a>
se ovšem nedá použít s WHERE, protože maže vždy všechny záznamy.<br>
</p>
<p style="font-style: italic;">Pozn.: Fungování TRUNCATE TABLE v MySQL
se hodně měnilo v jednotlivých verzích databáze, takže pokud si nejste
jisti co dělá vámi používaná verze MySQL, podívejte se do manuálu.</p>
<p><span style="font-weight: bold;">DROP TABLE</span><br>
Jak po použití TRUNCATE TABLE, tak po použití DELETE tabulka jako
taková v databázi samozřejmě zůstane, i kdyby měla být prázdná. Pokud
budete chtít odstanit tabulku včetně její struktury, je tu příkaz <a href="http://dev.mysql.com/doc/mysql/en/DROP_TABLE.html">DROP TABLE</a>.
Ten je pravým opakem CREATE TABLE.<br>
</p>
<p><span style="font-weight: bold;">DROP DATABASE</span><br>
jak asi tušíte, tohle je nejsilnější "mazací" příkaz. Odstraní z
databáze všechny tabulky, odstraní databázi jako takovou a odstraní
fyzicky všechny soubory operačního systému, které byly pro provoz této
databáze potřeba. Tohle by se mělo provádět jen ve výjímečných
případech.<br>
</p>
<p><span style="font-style: italic;">Pozn.: A v praxi si to asi
nevyzkoušíte, protože na většině webhostingů k provedení tak
destruktivní akce nebudete mít potřebná přístupová práva.<br>
</span></p>
<a name="000178"></a><h2>Mazání v PHP+MySQL</h2>
<p>Už toho není mnoho, co bych mohl dodat. Rovněž pro zadávání
odstraňovacích dotazů se v PHP používá funkce mysql_query. Platí pro ni
de facto to, co jsme uvedli v minulém dílu o UPDATE. Stručně zopakujme:<br>
</p>
<ul>
  <li>mysql_affected_rows vrací počet aktualizovaných záznamů nebo -1,
pokud dotaz selhal. </li>
  <li>mysql_query vrací TRUE pokud se příkaz povedl, FALSE pokud
selhal. </li>
  <li>Pokud odstranění záznamu nějakým způsobem závisí na hodnotách
zadaných uživatelem, měly by se tyto hodnoty pečlivě zkontrolovat ještě
předtím, než je dotaz proveden. </li>
</ul>
<p>Osobně se použití příkazu DELETE ve skriptech PHP dost bráním.
Většinou to povoluji pouze v nějakém administrátorském rozhraní
vybraným uživatelům. Využívám toho, že v DELETE lze použít jak klauzuli
WHERE, tak i LIMIT. Ani tady dnes mazání neuvidíte, nepovedlo se mi
vymyslet dostatečně praktickou a zároveň bezpečnou aplikaci, která by
to ilustrovala.<br>
</p>
<p>V příštím díle se podíváme na některé tipy, které Vám pomohou zvýšit
rychlost databázově závislých aplikací.</p>
<a name="000179"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (43) - MySQL rychleji a rychleji</h2>
			<p class="perex">Jak zkombinovat kód PHP a MySQL tak, abychom dosáhli co nejrychlejšího zpracování?
				<br>
			</p>
			<p>Proč se zabývat rychlostí provádění PHP a MySQL kódu? Webové i
databázové servery bývají povětšinou silně "nadupané" stroje. Takže by
se mohlo zdát, že rychlost provádění PHP kódu nebo rychlost, s jakou je
databáze schopna vrátit požadované výsledky není až tak kritická otázka
(kolega říká, že "železo to utlačí"). Není to samozřejmě úplně tak
pravda; webový server možná bude muset obsloužit tisíce požadavků a
rozdíl mezi skriptem běžícím vteřinu a skriptem běžícím pět vteřin bude
vražedný.<br>
</p>
<p>Další důvod proč se zabývat již při psaní kódu rychlostí je ten, že
si tak osvojíme některé programátorské návyky, a to se vždy hodí.
Takže, níže bude seznam věcí, na které bychom měli při psaní kódu z
hlediska rychlosti pamatovat.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Databázoví virtuosové znají
celou řadu dalších triků zvyšujících rychlost. Na toto téma se píší
celé knihy, takže si tento článek nijak neklade za cíl probrat všechno.
Pokud znáte další věci, podělte se s námi v diskusi.</span><br>
</p>
<p> </p>
<a name="000180"></a><h2>Dostatečně úzké sady záznamů</h2>
<p>Z logiky věci vyplývá, že čím menší bude objem zpracovávaných
informací, tím lépe. Máme-li například vypsat jména a příjmení z
tabulky pracovníků, můžeme použít jeden ze dvou následujících SELECTů:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">SELECT * FROM pracovnici<br>
SELECT jmeno, prijmeni FROM pracovnici</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Správný je ten druhý přístup. Jelikož SELECT * vrací všechny sloupce
a tabulka pracovníků se může časem rozrůst o další sloupce, vracel by
první příkaz zbytečně mnoho záznamů. V příkazu SELECT tedy
VYJMENOVÁVEJTE SLOUPCE.<br>
</p>
<a name="000181"></a><h2>Dostatečně krátké sady záznamů</h2>
<p>To, co platí o sloupcích platí i o řádcích. Většinou nebudete
potřebovat najednou zpracovávat tisíce záznamů. Můžete použít klauzule
WHERE nebo LIMIT a počet vrácených záznamů tak omezit na rozumnou míru.
To jsme si ukázali v díle o <a href="#000164">zobrazování
a stránkování dat</a>.<br>
</p>
<a name="000182"></a><h2>Nezadávejte zbytečné příkazy</h2>
<p>To bych měl asi trochu vysvětlit. Možná si vzpomenete na díl, který
vyhledává obce podle PSČ. Klíčový příkaz celé aplikace tehdy byl:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from psc where
psc="</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">]);</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>V praxi bychom asi chtěli data vrátit seřazená podle abecedy. Takže
odpovídající příkaz by se změnil na:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from psc where
psc="</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">].</font><font color="#dd0000">" order by obec"</font><font color="#007700">);</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Možná jste si ale také všimli, že data byla v příkladu u tohoto dílu
řazena podle abecedy i bez použití klauzule ORDER BY. To není žádná
alchymie, prostě jsem jen data importoval již seřazená. Takový trik
půjde použít zejména u tabulek určených jen pro čtení a ty se ve
webových aplikacích objevují dost často. Je jasné, že když se databáze
nebude muset starat o řazení výsledné sady, provede svou práci rychleji.<br>
</p>
<a name="000183"></a><h2>Používejte agregační funkce<br>
</h2>
<p>Agregační funkce umožňují zpracovat celé skupiny dat a vrátit jenom
výsledky. Například - který ze dvou následujících kódů proběhne
rychleji? </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select count(*) as
pocet from psc"</font><font color="#007700">);<br>
</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">mysql_fetch_array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
</font><font color="#0000bb">$celkem</font><font color="#007700">=</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"pocet"</font><font color="#007700">];<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>anebo</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from psc"</font><font color="#007700">);<br>
</font><font color="#0000bb">$celkem</font><font color="#007700">=</font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Je jasné, že nechat proběhnout dlouhý dotaz jen proto, abychom
zjistili, kolik je v tabulce řádků je krajně neekonomické. První dotaz
proběhne rychleji, protože databáze bude muset vrátit pouze jedno číslo.<br>
</p>
<p style="font-style: italic;">Pozn.: Pokud bychom pro výslednou sadu
měli okamžité využití, bude
to pochopitelně naopak.</p>
<a name="000184"></a><h2>Nechte počítat databázi</h2>
<p>Někdy bývá zvykem před zobrazením dat z databáze ještě cosi
dopočítávat pomocí PHP. Tak například aplikace by mohla získat z
databáze cenu výrobku bez DPH a cenovou hladinu DPH a PHP by mohlo
dopočítat cenu s daní, nějak takhle:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select cena, dph from
zbozi"</font><font color="#007700">);<br>
while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&lt;TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"cena"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"dph"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"cena"</font><font color="#007700">]*</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"dph"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&lt;/TR&gt;<br>
<font color="#0000bb">&lt;?</font><font color="#007700">endwhile;</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>v takovém případě musí PHP pronásobit cenu a daň pro každou položku.
Většinou bývá neskonale rychlejší nechat to udělat databázi, nějak
takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select cena, dph,
cena*dph as sdani from zbozi"</font><font color="#007700">);<br>
while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&lt;TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"cena"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"dph"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"sdani"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&lt;/TR&gt;<br>
<font color="#0000bb">&lt;?</font><font color="#007700">endwhile;</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>To proto, že databáze byla na rychlé vrácení dat silně
optimalizována již při své výrobě a pronásobení "ve střevech" provede
nejspíš rychleji než PHP.<br>
</p>
<p>V dalším díle se podíváme, jak k optimalizaci práce s daty poslouží
perzistentní spojení, nebufferované dotazy, indexy a optimalizace
tabulky. Takže se máte na co těšit.</p>

<a name="000185"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (44) - MySQL ještě rychleji</h2>
			<p class="perex">Několika způsoby lze PHP + MySQL zrychlit až dramaticky. Dnes si je rozebereme.
				<br>
			</p>
			<p>V minulém díle jsme si ukázali, jak zrychlit práci s PHP a MySQL
pomocí rozumně tvořených dotazů, správného využití agregačních funkcí a
přenesení výpočtů na databáze. Dnes se podíváme na zbytek
"zrychlovacích" triků.</p>
<a name="000186"></a><h2>Perzistentní databázová spojení</h2>
<p>Jestliže použijete pro otevření databázového spojení funkci
mysql_pconnect namísto mysql_connect, bude vytvořeno (nebo použito již
dříve vytvořené) <a href="http://cz.php.net/manual/cs/features.persistent-connections.php">perzistentní
spojení</a>. Toto spojení může PHP použít napříč několika skripty,
takže můžete ušetřit čas potřebný pro otevírání druhého a dalšího
spojení. </p>
<p><span style="font-style: italic;">Pozn.: Tento čas může být poměrně
dlouhý, zejména pokud MySQL běží na jiném stroji než PHP.</span><br>
</p>
<p>Perzistentní spojení bude fungovat pouze v případě, že bude PHP
spuštěno jako modul Apache. Neušetří samozřejmě žádný další čas při
provádění skriptu kromě času při opakovaném přihlášení. Ale i to může
být někdy dost.</p>
<a name="000187"></a><h2>Mysql_unbuffered_query</h2>
<p>Tato PHP funkce je shodná s funkcí mysql_query s tím rozdílem, že
nečeká na načtení <span style="font-style: italic;">všech</span>
záznamů z dotazu SELECT předtím, než je začnete zpracovávat. To se může
v případě velkých sad záznamů docela hodit. Pamatujte ovšem na to, že
to má rovněž následující omezení:</p>
<ul>
  <li>Nebude Vám fungovat funkce mysql_num_rows</li>
  <li>Nemůžete poslat databázi další dotaz, dokud nezpracujete ten
předchozí, vytvořený pomocí mysql_unbuffered_query</li>
</ul>
<p>Uvědomte si rovněž, že to je funkce PHP, ne MySQL. V praxi to
znamená, že PHP může dělat další věci (například, vypisovat již získaná
data do prohlížeče zatímco "přitékají" další data). Pro chudáka MySQL
se použitím mysql_unbuffered_query nic nemění, ta musí udělat stejnou
práci jako kdybychom použili mysql_query.</p>
<a name="000188"></a><h2>Použití indexů</h2>
<p>Většinu databázové práce lze urychlit správným použitím indexů.
Index je pomocná datová struktura, která zachycuje vztah mezi hodnotou
záznamu ve sloupci a jeho fyzickým umístěním v tabulce. Například,
jestliže si vzpomenete na náš příklad z dílu o vyhledávání obcí podle
PSČ, byla tam použita tabulka se dvěma poli - "obec" a "psc". Jelikož
byla tabulka seřazena podle obcí, nezbylo nebohému databázovému stroji
při požadavku najít obce s určitým PSČ nic jiného, než celou tabulku
projít. To bychom mu mohli ulehčit vytvořením indexu na poli psc.
Odpovídající příkaz jazyka SQL zní:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">ALTER TABLE `psc` ADD
INDEX ( `psc` )</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V případě, že index na sloupci psc bude skutečně existovat, bude
nalezení odpovídajících záznamů mnohem rychlejší. Aby nám MySQL trochu
ulehčila práci s odhadováním, jak bude dotaz probíhat, je k dispozici
SQL <a href="http://dev.mysql.com/doc/mysql/en/EXPLAIN.html">příkaz
EXPLAIN</a>. Ten nám poskytne potřebné informace. Tak napříkad</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">EXPLAIN SELECT * FROM
`psc` WHERE psc=46001</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>na tabulce bez indexů vrátí následující údaje:</p>
<table border="0" cellpadding="5">
  <tbody>
    <tr>
      <td>table </td>
      <td>type </td>
      <td>possible_keys </td>
      <td>key </td>
      <td>key_len </td>
      <td>ref </td>
      <td>rows </td>
      <td>Extra </td>
    </tr>
    <tr>
      <td bgcolor="#dddddd" valign="top">psc</td>
      <td bgcolor="#dddddd" valign="top">ALL</td>
      <td bgcolor="#dddddd" valign="top"><i>NULL</i></td>
      <td bgcolor="#dddddd" valign="top"><i>NULL</i></td>
      <td align="right" bgcolor="#dddddd" valign="top"><i>NULL</i></td>
      <td bgcolor="#dddddd" valign="top"><i>NULL</i></td>
      <td align="right" bgcolor="#dddddd" nowrap="nowrap" valign="top">16905</td>
      <td bgcolor="#dddddd" valign="top">Using where</td>
    </tr>
  </tbody>
</table>
<br>
<p>po přidání indexu to už bude mnohem nadějnější:</p>
<table border="0" cellpadding="5">
  <tbody>
    <tr>
      <td>table </td>
      <td>type </td>
      <td>possible_keys </td>
      <td>key </td>
      <td>key_len </td>
      <td>ref </td>
      <td>rows </td>
      <td>Extra </td>
    </tr>
    <tr>
      <td bgcolor="#dddddd" valign="top">psc</td>
      <td bgcolor="#dddddd" valign="top">ref</td>
      <td bgcolor="#dddddd" valign="top">psc</td>
      <td bgcolor="#dddddd" valign="top">psc</td>
      <td align="right" bgcolor="#dddddd" nowrap="nowrap" valign="top">5</td>
      <td bgcolor="#dddddd" valign="top">const</td>
      <td align="right" bgcolor="#dddddd" nowrap="nowrap" valign="top">48</td>
      <td bgcolor="#dddddd" valign="top">Using where</td>
    </tr>
  </tbody>
</table>
<br>
<p>Aniž bychom nějak extra rozebírali informace vrácené pomocí EXPLAIN
uveďme, že sloupec rows uvádí počet řádků, které bude muset MySQL
projít, aby nám mohla naservírovat výsledek dotazu. Po vytvoření indexu
to bude jen zlomek z celkového počtu řádků a prostým rozumem dojdeme k
tomu, že to bude rychlejší.<br>
</p>
<p>Ovšem pozor - bylo by snadné si myslet, že stačí oindexovat všechna
pole a databáze se zrychlí. Tak to není; ve skutečnosti údržba indexů
vyžaduje rovněž nějaký čas. Při jakékoli změně dat musí být indexy
rovněž upraveny. Obecně se to dá formulovat tak, že indexy ZRYCHLUJÍ
výběrové dotazy (SELECT), ale zpomalují dotazy manipulační (INSERT,
UPDATE, DELETE, REPLACE). Protože v příkladu byla databáze určena jen
pro čtení, bylo by použití indexů svrchovaně na místě.<br>
</p>
<p>Jestliže změníme v MySQL strukturu indexů, je vhodné použít příkaz <a href="http://dev.mysql.com/doc/mysql/en/ANALYZE_TABLE.html">ANALYZE
TABLE</a>. Jenž si, česky řečeno, udělá pořádek v indexech tabulky a
bude napříště vědět, které indexy a v jakém pořadí pro obsluhu dotazů
použije.<br>
</p>
<a name="000189"></a><h2>Optimalizace tabulky</h2>
<p>MySQL má příkaz <a href="http://dev.mysql.com/doc/mysql/en/OPTIMIZE_TABLE.html">OPTIMIZE
TABLE</a>. Ten dělá to, že fyzicky porovná datové struktury na disku a
charakterem připomíná defragmentaci souborů souborového systému.
Dokumentace upozorňuje, že ve většině případů nebude nutné jej
spouštět; svoje uplatnění najde zejména tehdy, pokud jsme prováděli
rozsáhlé promazávání nebo úpravy polí proměnné délky.<br>
</p>
<a name="000190"></a><h2>Procedure_Analyze</h2>
<p>Rychlost databáze se dá ovlivnit tím, že používáme správné a
nejkratší možné typy sloupců na uložení odpovídajících dat. MySQL má
docela užitečné rozšíření spočívající v tom, že existuje
následující nástroj: Příkaz SQL, který projde tabulku a na základě dat
v ní navrhne případné změny v její definici. Příkaz vypadá následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">SELECT * FROM `psc`
PROCEDURE ANALYSE ( )</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a v našem případě by nám vrátil zhruba toto (některé sloupce
výsledku jsem vynechal):<br>
</p>
<table border="0" cellpadding="5">
  <tbody>
    <tr>
      <td>Field_name </td>
      <td>Min_length </td>
      <td>Max_length </td>
      <td>Empties_or_zeros </td>
      <td>Nulls </td>
      <td>Optimal_fieldtype </td>
    </tr>
    <tr>
      <td bgcolor="#dddddd" valign="top">psc.obec</td>
      <td align="right" bgcolor="#dddddd" nowrap="nowrap" valign="top">3</td>
      <td align="right" bgcolor="#dddddd" nowrap="nowrap" valign="top">47</td>
      <td align="right" bgcolor="#dddddd" nowrap="nowrap" valign="top">1</td>
      <td align="right" bgcolor="#dddddd" nowrap="nowrap" valign="top">0</td>
      <td bgcolor="#dddddd" valign="top">VARCHAR(47) NOT NULL</td>
    </tr>
    <tr>
      <td bgcolor="#ccffcc" valign="top">psc.psc</td>
      <td align="right" bgcolor="#ccffcc" nowrap="nowrap" valign="top">5</td>
      <td align="right" bgcolor="#ccffcc" nowrap="nowrap" valign="top">5</td>
      <td align="right" bgcolor="#ccffcc" nowrap="nowrap" valign="top">0</td>
      <td align="right" bgcolor="#ccffcc" nowrap="nowrap" valign="top">1</td>
      <td bgcolor="#ccffcc" valign="top">MEDIUMINT(5) UNSIGNED</td>
    </tr>
  </tbody>
</table>
<p>Užitečnost tohoto přístupu je sporná - na jedné straně nám to umožní
smrsknout definici na co "nejužší" sloupce; na straně druhé nám to
trochu svazuje ruce a dá se to provést pouze na naplněné tabulce. V
našem případě by z toho vyplývalo jediné - jelikož asi nevznikne na
území ČR obec s názvem delším než 47 znaků, mohli bychom směle zkrátit
maximální délku názvu obce z 60 znaků na 47.</p>
<a name="000191"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (45) - Jsou data v databázi v bezpečí?</h2>
			<p class="perex">Zafilozofujme trochu na téma bezpečnosti dat aneb trocha paranoi nikdy neuškodí.
				<br>
			</p>
			<p>Dejme tomu, že po přečtení dvou předchozích dílů už máme představu o
tom, jak naši aplikaci zrychlit. Je ale obecně uložení dat v databázi
bezpečné? Jak
uvidíme v dnešním víceméně teoretickém článku, něco málo pro to můžeme
udělat. Základní otázky databázové
bezpečnosti si rozdělíme na "kdo", "kde" a "co".<br>
</p>
<a name="000192"></a><h2>Kdo může do databáze<br>
</h2>
<p>MySQL má originální mechanismus přidělování práv. Lze určit kdo a
odkud se smí k databázi připojit, a pro každou kombinaci uživatele a
místa z něhož se připojuje lze nastavit určitá oprávnění, respektive
omezení. To byla ta dobrá zpráva. Špatné zprávy jsou, že:</p>
<ul>
  <li>Většinou nebudete mít oprávnění nastavovat oprávnění ;-)) protože
to bude dělat správce serveru</li>
  <li>Většinou nebudete mít oprávnění připojovat se ke své databázi z
libovolného místa na internetu. To je rozumné, protože komunikaci mezi
Vámi a databází by mohl někdo odposlouchávat.</li>
</ul>
<p>Z hlediska PHP se dělá někdy chyba - poměrně častý způsob uložení
přihlašovacích informací (název hostitele, jméno, heslo) je umístit je
do souboru, který se bude do výsledného skriptu vkládat pomocí include,
resp. require. To samo o sobě není nebezpečné. Co je ale opravdu špatný
nápad - ukládat soubory s jinou příponou než php. Jak například víte,
že server nepošle soubory s příponou inc přímo do prohlížeče a někdo si
nebude moci Vaše přihlašovací údaje přečíst?<br>
</p>
<a name="000193"></a><h2>Není heslo jako heslo</h2>
<p>Aby nedocházelo k matení pojmů, dodejme rovnou, že uživatelé Vašich
stránek samozřejmě nebudou muset znát Vaše přihlašovací údaje k
databázi. Uživatelé se možná ověří pomocí nějakého mechanizmu (ten
budete muset napsat!) a PHP pak vytvoří databázové spojení (klidně i
několik) <span style="font-style: italic;">stále se stejnými</span>
přihlašovacími údaji. Takže budete-li mít webový obchod s
registrovanými uživateli "Pepa" a "Jarda", bude typický scénář práce
následující:<br>
</p>
<ul>
  <li>Uživatel "Pepa" se nějak ověří (třeba heslem) a vytvoří se pro
něj databázové spojení</li>
  <li>Uživatel "Pepa" pracuje s databází. Databáze neví, že je to
"Pepa". Bylo jí prostě řečeno, že ten člověk má správné přihlašovací
údaje, tak s ním "mluví".</li>
  <li>Mezitím se přihlásí "Jarda". Klidně s jiným heslem.</li>
  <li>Nyní pracují oba s databází. Databáze neví, že to jsou dva různí
uživatelé, a i kdyby to věděla, je jí to srdečně jedno.</li>
  <li>V nějaké chvíli se jeden a později druhý uživatel odhlásí.</li>
</ul>
<p>Vrstva, ve které musíte uživatele rozlišit tedy není MySQL, ale PHP.
Zda a jak vyřešíte přihlašování je zcela ve Vašich rukou. Může to být
provedeno bezpečně, nebo to může být "děravé" jako ementál.<br>
</p>
<p style="font-style: italic;">Pozn.: O těchto věcech ještě bude v
seriálu řeč.</p>
<p> </p>
<p> </p>
<a name="000194"></a><h2>Kde mít databázi</h2>
<p>Ani tohle většinou nebudete moci ovlivnit. V naprosté většině
případů bude databáze ležet někde u providera a tudíž nebudete moci
účinně kontrolovat, kdo a kdy z ní četl vaše data. Jiná možnost je mít
vlastní databázový a/nebo webový server, což může být nákladné a
technicky náročné. Poskytovatel z vašich peněz žije, takže je zřejmě
ten poslední, kdo by chtěl zpronevěřit vaše data. Dojde-li k prozrazení
dat z datábáze uložené u webhostera, je to prakticky vždy způsobeno
útokem zvenčí, málokdy zevnitř. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Což je sice objektivní,
nikoli však uklidňující tvrzení. Jestliže si provider neumí zabezpečit
server
proti útoku na databázi, je potřeba ho nemilosrdně vyměnit.<br>
</span></p>
<p>Když běží databáze na jiném stroji než webový server musí spolu
pochopitelně komunikovat. V takovém případě byste
měli vědět, že:<br>
</p>
<ul>
  <li>Přihlašovací informace si MySQL server s PHP bude vyměňovat
šifrovaně,</li>
  <li>vlastní data si bude vyměňovat komprimovaně, ale nešifrovaně.</li>
</ul>
<p>V takovém případě by tedy kdokoli mezi databázovým a webovým
serverem mohl data odposlouchávat. Řešením je v tomto případě
zabezpečit <span style="font-style: italic;">přenos </span>dat. To už
je mimo náplň našeho seriálu, ale v případě vzdálené komunikace mezi
MySQL a webovým serverem je to téměř nezbytné.<br>
</p>
<p><span style="font-style: italic;"></span></p>
<p></p>
<a name="000195"></a><h2>Co mít v databázi?</h2>
<p>To je na první pohlad divná otázka. V databázi přece musíme mít ty
věci, které tam potřebujeme mít, ne? Ne tak docela. Některé věci se do
databáze mohou ukládat tak, aby to případnému zloději dat nic neříkalo.
Například chceme-li ukládat citlivé informace (hesla...) můžeme použít
funkci MD5. Příkaz:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">SELECT MD5('petr')</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>vrátí nějaký řetězec, který případnému útočníkovi nic neřekne.
Šifrovacích a souvisejících funkcí podporuje MySQL <a href="http://dev.mysql.com/doc/mysql/en/Encryption_functions.html">celou
řadu</a>. Pozor, některé jsou obousměnrné, některé jednosměrné.<br>
</p>
<p>Samozřejmě nezvítězíte, pokud se rozhodnete v databázi zašifrovat
kdejakou informaci. Pamatujte, že šifrování způsobí následující
problémy:<br>
</p>
<ul>
  <li>Budete potřebovat více místa v databázi, protože šifrovaná data
jsou většinou delší než nešifrovaná.</li>
  <li>Budete potřebovat větší výpočetní výkon - například databáze bude
muset data dešifrovat a teprve potom řadit.</li>
  <li>Jestliže se někdo nepovolaný dostane jak k vaší databázi, tak k
PHP skriptům, je obyčejně každé zabezpeční <span style="font-style: italic;">téměř </span>jistě prolomeno. Výjimkou
mohou být situace, kdy data závisí kromě údajů v samotných php
souborech ještě na něčem (třeba: informace
potřebné k dešifrování jsou umístěna v úložišti, které útočník
neprolomil).</li>
</ul>
<p>Článku chybí nějaká praktická ukázka. Pakliže uložíte databázi
následující příkaz:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">SELECT
AES_ENCRYPT("Super tajná informace","super tajný klíč")</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>uvidíte ve výsledku jen "rozsypaný čaj". Pokud zvolíte obrácený
postup, dostanete opět Vaši super tajnou informaci:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">AES_DECRYPT(<br>
AES_ENCRYPT( "Super tajná informace", "super tajný klíč"),<br>
"super tajný klíč")</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jestliže se "super tajný klíč" bude nacházet mimo php skripty a
případný útočník jej nebude mít k dispozici, máte skoro vyhráno.
Protože prolomení šifer tohoto typu je velmi obtížné.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Informace uložené pomocí
šifrovacích funkcí budete muset
ukládat v polích pro binární data a ne v polích pro řetězce. To proto,
že výsledkem jsou binární (ne tedy textová) data.</span><br>
</p>
<a name="000196"></a><h2>Šifrování v PHP</h2>
<p>Aby to PHP nebylo líto, dodejme, že i bez pomoci MySQL umí samotné
PHP informace (de)šifrovat. Pokud je to nastaveno, podporuje PHP
poměrně rozsáhlou škálu&nbsp; <a href="http://cz.php.net/manual/cs/ref.mcrypt.php">šifrovacích algoritmů</a>.
Některé funkce (například <a href="http://cz.php.net/manual/cs/function.md5.php">md5()</a>) jsou k
dispozici již v "základní výbavě" PHP. Nikdo Vám tedy nebrání ukládat
šifrovaná data do souborů nebo posílat je pomocí e-mailů a všechno to
dělat pomocí PHP.<br>
</p>
<p>Příště se zaměříme na veskrze praktické téma - budeme uvažovat nad
tím, jak do MySQL databáze nahrát data ze vzdálených zdrojů.</p>

<a name="000197"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (46) - Importujeme data do databáze</h2>
			<p class="perex">Jak dostat data do MySQL z externích zdrojů, třebas z desktopu? Pomocí PHP!
				<br>
			</p>
			<p>Jelikož byly předchozí dva díly našeho seriálu dost teoretické (pro
někoho možná až příliš), ukážeme si dnes na něco, co budete potřebovat
při práci s PHP a MySQL téměř určitě. A to bude import dat z
cizích zdrojů do MySQL.</p>
<p>Mějme například následující situaci: Firma provozuje podnikový
informační systém na několika lokálních PC. Součástí systému je i ceník
zboží. Firma má rovněž internetový obchod, běžící pod PHP a MySQL. A
vtom někoho napadne, že by se ceník na internet dal nahrávat z toho
lokálního systému. To je jasná výhoda; při změně cen (sortimentu…)
stačí provést příslušné úpravy jen v jedné sadě dat, nemusí se to dělat
vícekrát. Jsou to vlastně 3 problémy v jednom: data získat, nějak je
zkopírovat na server a nakrmit je do databáze.</p>
<a name="000198"></a><h2>Jaká data?</h2>
<p>Následující věc se vlastně naší problematiky skoro netýká. Ale
abychom byli úplní, poradíme vám, že je žádoucí připravit exportovaná
data v co NEJJEDNODUŠŠÍM, OTEVŘENÉM a (zejména pokud běží lokální
infosystém na Windows) MULTIPLATFORMNÍM formátu. V praxi to bývají
většinou textové soubory oddělené středníky či tabelátory. Téměř každý
databázový systém má možnost exportovat data do textu; pokud jej
nemá, dá se příslušný kus kódu napsat. </p>
<p style="font-style: italic;">Pozn.: V takovém případě buďte líní a
pokuste se to najít již hotové. Skoro určitě nejste první, kdo daný
problém řešil. Může nastat rovněž problém s kódováním, zejména pokud
text bude ve znakové sadě CP 1250 (Windows) a web na ISO-8859-2.<br>
</p>
<p>Pokud mohu poradit – vyhněte se pokusu použít nějakou "transportní"
databázi. Viděl jsem například řešení používající pro výměnu dat
formát dbf. To může fungovat, protože PHP lze nastavit pro práci s
dbf. Toto řešení má však rovněž poměrně významné nevýhody:</p>
<ul>
  <li>Jste závislí na dalším formátu včetně jeho případných omezení<br>
  </li>
  <li>Exportovaná data bývají obvykle větší než při použití textu</li>
  <li>Export a import trvá delší dobu (někdy až podstatně)</li>
</ul>
<p style="font-style: italic;">Pozn. Na druhou stranu textové soubory
mohou být skoro nepoužitelné, pokud jsou součástí exportovaných dat
rovněž binární data, třeba v případě, kdy jsou v databázi uloženy
obrázky.<br>
</p>
<p>Další poměrně podstatnou výhodou je fakt, že textové soubory lze
relativně snadno odkontrolovat a většinou se dají velice dobře
komprimovat. Ke komprimaci byste měli použít gzip, protože PHP umí s
tímto formátem bez problémů spolupracovat.</p>
<p style="font-style: italic;">Pozn.: Dají se najít nástroje pro
práci s gzipy i pod Windows. Některé jako freeware.Zcela úmyslně jsem
se nezmínil o fenoménu XML. Budeme mu věnovat
pozornost <a href="#000243">později</a>
v tomto seriálu.<br>
</p>
<a name="000199"></a><h2>Jak to dostat na server?</h2>
<p>Takže, v této fázi byste měli mít jeden nebo více textových souborů,
lépe ještě komprimovaných. Jejich přenos na server může a nemusí být
realizován pomocí PHP. Například se můžete rozhodnout použít FTP, SCP a
podobně. Ze zkušenosti ale vím, že je dobré mít k dispozici i náhradní
metodu (třeba, když potřebujete dostat data na server z počítače, na
němž nemáte k dispozici FTP klienta). Vzpomínáte si na díl seriálu o <a href="#000135">přenosu dat
na server</a>? To je přesně ono. Za chvíli si to ukážeme celé v praxi.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Možná budete chtít použít
nějaký jiný postup, který se dá snadněji spouštět pomocí cronu.<br>
</span></p>
<a name="000200"></a><h2>Jak dostat data do databáze</h2>
<p>A to je to nejdůležitější. Máme textový soubor nebo soubory na
serveru a chceme je dostat do MySQL. Dobrá zpráva je, že na to existuje
v MySQL příkaz; špatná zpráva je, že v závislosti na použité verzi PHP
a/nebo MySQL tento příkaz nemusí fungovat. Takže si ukážeme dvě
varianty:<br>
</p>
<p><span style="font-weight: bold;">LOAD DATA INFILE</span><br>
MySQL disponuje tímto příkazem, který vezme data z textového souboru a
importuje je do dabulky. Příkaz je to jednak dosti mocný a jednak
poměrně rychlý. Nemá smysl tady vypisovat všechny jeho volby, k tomu
slouží <a href="http://dev.mysql.com/doc/mysql/en/LOAD_DATA.html">manuál</a>.
Zmínil bych se pouze o dvou významných volbách:<br>
</p>
<ul>
  <li>LINES TERMINATED BY slouží k definici znaku, který bude oddělovat
řádky. Pokud importujete z Windows, měli byste nastavit '\r\n'.</li>
  <li>FIELDS TERMINATED BY slouží k definici znaku, jímž se oddělují
sloupce. Pro tabelátor zadejte '\t', je to ostatně výchozí volba.</li>
</ul>
<p>K tomu všemu co bylo řečeno výše se vztahuje následující ukázka:</p>
<p> </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">ungzip
</font><font color="#007700">(</font><font color="#0000bb">$name</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">$fp </font><font color="#007700">= </font><font color="#0000bb">gzopen </font><font color="#007700">(</font><font color="#0000bb">$name</font><font color="#007700">.</font><font color="#dd0000">".gz"</font><font color="#007700">, </font><font color="#dd0000">"rb"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$contents </font><font color="#007700">= </font><font color="#0000bb">gzread </font><font color="#007700">(</font><font color="#0000bb">$fp</font><font color="#007700">, </font><font color="#0000bb">4000</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$fp </font><font color="#007700">= </font><font color="#0000bb">fopen </font><font color="#007700">(</font><font color="#0000bb">$name</font><font color="#007700">,</font><font color="#dd0000">"wb"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">fwrite </font><font color="#007700">(</font><font color="#0000bb">$fp</font><font color="#007700">,</font><font color="#0000bb">$contents</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">fclose </font><font color="#007700">(</font><font color="#0000bb">$fp</font><font color="#007700">);<br>
}<br>
<br>
if (</font><font color="#0000bb">$_REQUEST</font><font color="#007700">[</font><font color="#dd0000">"odeslano"</font><font color="#007700">]==</font><font color="#0000bb">1</font><font color="#007700">):<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$_FILES</font><font color="#007700">[</font><font color="#dd0000">'data'</font><font color="#007700">][</font><font color="#dd0000">'size'</font><font color="#007700">]&gt;</font><font color="#0000bb">4000</font><font color="#007700">) die (</font><font color="#dd0000">"Soubor je příliš
velký ;-("</font><font color="#007700">);<br>
&nbsp;&nbsp;if (!</font><font color="#0000bb">is_file</font><font color="#007700">(</font><font color="#0000bb">$_FILES</font><font color="#007700">[</font><font color="#dd0000">'data'</font><font color="#007700">][</font><font color="#dd0000">'tmp_name'</font><font color="#007700">])) die (</font><font color="#dd0000">"Žádný soubor
jste neuploadovali !!!"</font><font color="#007700">);<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">move_uploaded_file</font><font color="#007700">(</font><font color="#0000bb">$_FILES</font><font color="#007700">[</font><font color="#dd0000">'data'</font><font color="#007700">][</font><font color="#dd0000">'tmp_name'</font><font color="#007700">], </font><font color="#dd0000">"./data.txt.gz"</font><font color="#007700">))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">ungzip</font><font color="#007700">(</font><font color="#dd0000">"data.txt"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">// zde je include
souboru s konstantami<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$soubor</font><font color="#007700">=</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"DOCUMENT_ROOT"</font><font color="#007700">].</font><font color="#dd0000">"/data.txt"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">mysql_unbuffered_query
</font><font color="#007700">(</font><font color="#dd0000">"LOAD DATA
INFILE '"</font><font color="#007700">.</font><font color="#0000bb">$soubor</font><font color="#007700">.</font><font color="#dd0000">"' INTO TABLE
`moje_tabulka`LINES TERMINATED BY '\r\n'"</font><font color="#007700">);&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;};<br>
else:<br>
</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;Nahrání souboru na server<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;form method="POST"
ENCTYPE="multipart/form-data" action="<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_SELF"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;table border="1" &gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;Textový
soubor&lt;/td&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input
type="HIDDEN" name="MAX_FILE_SIZE" VALUE=4000&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input
type="file" name="data" ACCEPT="text/*"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/td&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;(max. 4
kb)&lt;/td&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td colspan="3"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input
type="hidden" name="odeslano" value="1"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p
align="center"&gt;&lt;input type="submit" value="Odeslat"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/td&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/table&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;<br>
<font color="#0000bb">&lt;?<br>
</font><font color="#007700">endif;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>V tomto poněkud delším kódu jsou patrné dvě věci. Za prvé si
všimněte, že jsme sestavili a použili funkci ungzip. Ta funguje tak, že
vytvoří ze souboru něco.txt.gz soubor něco.txt. A příkaz LOAD DATA
INFILE se postará o zbytek. Ostatní části kódu jsou převzaty z dílu o
nahrávání dat na server.<br>
</p>
<p><span style="font-weight: bold;">Ruční způsob</span><br>
Někdy ovšem LOAD DATA INFILE selže nebo není povolen. V tom případě
nezbývá než data ze souboru postupně načítat a vkládat je do databáze
pomocí série příkazů INSERT. To má následující nevýhody:<br>
</p>
<ul>
  <li>Je to pomalejší než LOAD DATA INFILE (někdy až řádově).<br>
  </li>
  <li>Je to složitější na napsání kódu.</li>
  <li>Abychom to mohli provést, musíme znát strukturu tabulky.</li>
  <li>Ve vysoce konkurenčním prostředí může dojít k problémům se
zamykáním tabulek<br>
  </li>
</ul>
<p>Ovšem má to i výhodu - před vlastním vložením dat můžeme provést
pomocí PHP nějaké výpočty nebo kontroly, což při použití LOAD DATA
INFILE většinou není možné. V takovém případě by se řádek s příkazem
LOAD DATA INFILE uvedený výše musel vyměnit za sadu příkazů, které
soubor rozdělí, načtou jednotlivé hodnoty do příkazu SQL a soustí jej.<br>
</p>
<a name="000201"></a><h2>Závěr</h2>
<p> Vidíme, že importovat data do MySQL není zas až tak složité. Je
možné použít prakticky libovolné zdroje a pomocí konverze na texty
dosáhnout poměrně rychle kýženého výsledku. Pokud by import dat byl pro
běh webu závažný, měly by se naimportované hodnoty nějak odkontrolovat.
Více o tomto tématu bude řečeno v sesterském <a href="http://www.linuxsoft.cz/article_list.php?id_kategory=232">seriálu
o databázi MySQL</a>.<br>
</p>
<a name="000202"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (47) - Exportujeme data</h2>
			<p class="perex">Vytáhneme data ... a co dál? MySQL, PHP a export.
				<br>
			</p>
			<p>V předchozím díle jsme rozebírali možnosti importu dat do MySQL
databáze. Dnes se podíváme na opačnou úlohu - jak data z MySQL pomocí
PHP exportovat.</p>
<a name="000203"></a><h2>SELECT ... INTO OUTFILE<br>
</h2>
<p>Minule jsme rozebírali příkaz LOAD DATA INFILE. Jeho opakem je
rozšíření příkazu SELECT o klauzuli INTO OUTFILE. Jak asi tušíte, má to
za následek, že data se z databáze nevrátí ve formě sady záznamů, ale
jako soubor. Mohlo by se zdát, že následující kus kódu všechny problémy
s exportem dat z MySQL vyřeší:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$soubor</font><font color="#007700">=</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"DOCUMENT_ROOT"</font><font color="#007700">].</font><font color="#dd0000">"/data.txt"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_unbuffered_query </font><font color="#007700">(</font><font color="#dd0000">"SELECT * FROM psc WHERE
psc=47001 INTO OUTFILE '"</font><font color="#007700">.</font><font color="#0000bb">$soubor</font><font color="#007700">.</font><font color="#dd0000">"'"</font><font color="#007700">);&nbsp;&nbsp;&nbsp;&nbsp;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Bohužel to má některá vážná úskalí. Jedná se zejména o to, že:<br>
</p>
<ul>
  <li>SELECT ... INTO OUTFILE se nikdy nepokusí odstranit existující
soubor. Museli bychom to provést ručně před započetím exportu.</li>
  <li>Tento příkaz vytváří soubor na stroji, na němž běží MySQL. Pokud
PHP běží jinde než MySQL, je nám to k celkem k ničemu. Málokdy totiž v
takovém případě budeme mít ke vzdálenému stroji přístup.<br>
  </li>
  <li>Na provedení tohoto příkazu musíte mít na serveru MySQL
dostatečná práva - to asi nebude vždy.</li>
  <li>Konečně, vzniklý soubor je přístupný pro zápis všem uživatelským
účtům na serveru, na němž MySQL běží.</li>
</ul>
<a name="000204"></a><h2>"Ruční" způsob</h2>
<p>Naštěstí je řešení výše uvedených problémů poměrně jednoduché. Nic
nám nebrání vytvořit si sadu záznamů, procházet ji a cílový soubor si
sestavit takový, jaký chceme (a tam, kde to chceme). Náš příklad bychom
za tímto účelem mohli poupravit následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek </font><font color="#007700">= </font><font color="#0000bb">mysql_query </font><font color="#007700">(</font><font color="#dd0000">"SELECT * FROM psc WHERE
psc=47001"</font><font color="#007700">);<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$obsah </font><font color="#007700">.= </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"obec"</font><font color="#007700">];<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$obsah </font><font color="#007700">.= </font><font color="#dd0000">"\t"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$obsah </font><font color="#007700">.= </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">];<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$obsah </font><font color="#007700">.= </font><font color="#dd0000">"\n"</font><font color="#007700">;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;endwhile;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$soubor</font><font color="#007700">=</font><font color="#0000bb">fopen</font><font color="#007700">(</font><font color="#dd0000">"data.txt"</font><font color="#007700">, </font><font color="#dd0000">"w"</font><font color="#007700">); <br>
&nbsp;&nbsp;</font><font color="#0000bb">fwrite</font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">,</font><font color="#0000bb">$obsah</font><font color="#007700">); <br>
&nbsp;&nbsp;</font><font color="#0000bb">fclose</font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">); <br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Všimněte si, že tohle už nám dává trochu větší svobodu. Můžeme si
určit oddělovač polí (třeba tabelátor), oddělovač řádků a můžeme soubor
zapsat na libovolné místo. Nevýhodou je, že to je citelně pomalejší než
SELECT
... INTO OUTFILE.<br>
</p>
<a name="000205"></a><h2>Výstupní formáty<br>
</h2>
<p>Nikdo samozřejmě netvrdí, že jedinou možností výstupu dat z MySQL
pomocí PHP jsou textové soubory. Můžeme exportovat prakticky do
libovolného otevřeného formátu, protože PHP umí data zapisovat textově
i binárně.
Většinou už dokonce existují připravené nástroje, které můžeme použít.
Tak například na internetu existuje celá řada návodů na přímý export
z MySQL do XML. Můžete si je přizpůsobit, nebo můžete napsat sami něco
v tomto
duchu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek </font><font color="#007700">= </font><font color="#0000bb">mysql_query </font><font color="#007700">(</font><font color="#dd0000">"SELECT * FROM psc WHERE
psc=47001"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Type: text/xml"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo(</font><font color="#dd0000">"&lt;?xml version=\"1.0\"
encoding=\"UTF-8\" ?&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo(</font><font color="#dd0000">"&lt;obce&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$row </font><font color="#007700">= </font><font color="#0000bb">mysql_fetch_assoc </font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)) <br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t&lt;obec&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t\t&lt;psc&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"\t\t\t"</font><font color="#007700">.</font><font color="#0000bb">$row</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">].</font><font color="#dd0000">"\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t\t&lt;/psc&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t\t&lt;nazev&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"\t\t\t"</font><font color="#007700">.</font><font color="#0000bb">$row</font><font color="#007700">[</font><font color="#dd0000">"obec"</font><font color="#007700">].</font><font color="#dd0000">"\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t\t&lt;/nazev&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t&lt;/obec&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;echo(</font><font color="#dd0000">"&lt;/obce&gt;\n"</font><font color="#007700">); <br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Pokud nevíte, co je to XML, nemusíte se děsit. Ještě o něm bude v
našem seriálu řeč.<br>
</p>
<p style="font-style: italic;">Pozn.: Pokud naopak víte co je XML,
rovněž se nemusíte děsit. Takhle se v PHP s XML opravdu nepracuje, ale
chtěl jsem, aby to bylo názorné.<br>
</p>
<p>Možnosti PHP tímto nekončí. Používám s úspěchem například <a href="http://www.bettina-attack.de/jonny/view.php/projects/php_writeexcel/">třídu
pro přímou tvorbu souborů xls</a>. Rovněž je možné vytvářet dokumenty v
mnoha dalších formátech.
Těším se, že někdo napíše PHP program pro generování sešitu Open Office
(tedy formát sxw), zatím jsem nic použitelného nenašel. Kdybyste s tím
měli zkušenosti, můžete se o ně s námi podělit v diskusi.</p>
<a name="000206"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (48) - Práce s binárními daty (BLOB)</h2>
			<p class="perex">Měla by se binární data ukládat do databáze, nebo ne? A jestliže ano, jak s tím pak pracovat v PHP?
				<br>
			</p>
			<p>Tento díl seriálu jste si vyžádali ve svých e-mailových reakcích na
předchozí články. Zaznamenal jsem několik dotazů, jak v PHP a MySQL
pracovat s binárními daty.
</p>
<a name="000207"></a><h2>Proč to nemám rád</h2>
<p>Především, musím se přiznat, že taková řešení moc nepodporuji. Není
mnoho pádných důvodů pro ukládání binárních dat do MySQL databází,
jestliže tvoříte klasickou webovou aplikaci. Budete-li chtít ukládat do
MySQL například sérii obrázků, měli byste vědět, že:<br>
</p>
<ul>
  <li>to je pomalé. Minimálně pomalejší o databázovou režii.</li>
  <li>to zabere víc místa. MySQL musí mít uloženy informace nejen o
samotném souboru, ale i některá metadata.</li>
  <li>to většinou znamená celou řadu práce pro programátora navíc.</li>
</ul>
<p>Abychom byli upřímní, může to mít i výhody. Přišel jsem na dvě:</p>
<ul>
  <li>Možná, že binární data v databázi budeme moci lépe zabezpečit,
než kdyby byla na disku.</li>
  <li>Do binárního pole v databázi můžeme uložit prakticky cokoliv. V
jednom řádku dat to může být obrázek, v jiném třeba soubor obsahující
hudbu.</li>
</ul>
<p>Jestliže ale nemáte jinou možnost, nebo jestliže potřebujete ukládat
binární data, může Vám MySQL sloužit.<br>
</p>
<a name="000208"></a><h2>Co udělat v databázi</h2>
<p>V MySQL je pro uložení binárních dat použit sloupec <a href="http://dev.mysql.com/doc/mysql/en/BLOB.html">typu BLOB</a>
(binary large object). Takže, pokud budete chtít definovat tabulku pro
uložení obrázků s jedním sloupcem, můžete použít něco ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">CREATE TABLE obrazky
(id INT NOT NULL AUTO_INCREMENT ,<br>
obrazek BLOB NOT NULL , PRIMARY KEY (id));</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jestliže máte definici tabulky hotovou, můžete do ní směle vložit
data. Mějme například ve složce, z níž se skript spouští, uložen soubor
test.jpg. V takovém případě jej můžete načíst pomocí funkce fread do
proměnné a vložit do databáze. Jenže pozor: binární soubor může
obsahovat kdeco, včetně například apostrofů a jiných znaků, které by
při sestavování dotazu mohly databázi zmást. Kdyby se to stalo, uloží
se náš obrázek porušený nebo se dokonce neuloží vůbec. Musíme tedy
použít funkci addslashes, která
vkládaná data před jejich uložením oescapuje. Celé to může vypadat
následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">); <br>
&nbsp;&nbsp;</font><font color="#0000bb">$fp </font><font color="#007700">= </font><font color="#0000bb">fopen</font><font color="#007700">(</font><font color="#dd0000">"test.jpg"</font><font color="#007700">, </font><font color="#dd0000">"rb"</font><font color="#007700">); <br>
&nbsp;&nbsp;</font><font color="#0000bb">$binarydata </font><font color="#007700">= </font><font color="#0000bb">addslashes</font><font color="#007700">(</font><font color="#0000bb">fread</font><font color="#007700">(</font><font color="#0000bb">$fp</font><font color="#007700">, </font><font color="#0000bb">filesize</font><font color="#007700">(</font><font color="#dd0000">"test.jpg"</font><font color="#007700">))); <br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_query </font><font color="#007700">(</font><font color="#dd0000">"insert into obrazky
(obrazek) values ('" </font><font color="#007700">. </font><font color="#0000bb">$binarydata </font><font color="#007700">. </font><font color="#dd0000">"')"</font><font color="#007700">); <br>
&nbsp;&nbsp;</font><font color="#0000bb">fclose</font><font color="#007700">(</font><font color="#0000bb">$fp</font><font color="#007700">); <br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-style: italic;">Pozn.: Někteří tvrdí, že "úpravu"
spočívající v přidání escape znaků pomocí funkce addslashes nepřežijí
obrázky ve formátu jpeg. Sám jsem se s tím nesetkal. Kdyby Vás to
nicméně potkalo, můžete data zakódovat například pomocí funkce </span><a style="font-style: italic;" href="http://cz.php.net/manual/cs/function.base64-encode.php">base64_encode</a><span style="font-style: italic;">. Budou ale zabírat v databázi o třetinu
místa více.</span><br>
</p>
<a name="000209"></a><h2>Zobrazování binárních dat</h2>
<p>Jeden veliký problém spočívá v tom, že musíme vědět, s jakými
binárními daty právě pracujeme, a musíme to sdělit prohlížeči. Takže,
kdybychom měli zobrazovat obrázky uložené v tabulce podle předchozího
příkladu, můžeme směle použít něco jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;if (!isset(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"obrazek"</font><font color="#007700">])) die (</font><font color="#dd0000">"Nezadali jste
číslo obrázku"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek </font><font color="#007700">= </font><font color="#0000bb">mysql_query </font><font color="#007700">(</font><font color="#dd0000">"SELECT * FROM obrazky
where id="</font><font color="#007700">.</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"obrazek"</font><font color="#007700">]);<br>
&nbsp;&nbsp;if (!</font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)==</font><font color="#0000bb">1</font><font color="#007700">) die (</font><font color="#dd0000">"Nemáme takový
obrázek"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Type:
image/jpeg"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$row </font><font color="#007700">= </font><font color="#0000bb">mysql_fetch_assoc </font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
&nbsp;&nbsp;echo </font><font color="#0000bb">$row</font><font color="#007700">[</font><font color="#dd0000">"obrazek"</font><font color="#007700">];<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>přičemž řádek s voláním funkce header je nezbytný. Jinak totiž
nebohý prohlížeč nepozná, co má s došlými binárními daty dělat.<br>
</p>
<p>Co když ale potřebujeme zobrazit nejen samotný obrázek, ale stránku,
která bude obsahovat dejme tomu několik různých obrázků pocházejících z
databáze? To je problém, protože v tom případě nemůžeme použít funkci
header jako v předchozím případě. Máte zhruba tři možnosti:<br>
</p>
<ul>
  <li>Obrázky vyexportovat do souborů a použít je, jako by tam byly
odjakživa (brr, pomalé).</li>
  <li>Znásilnit funkce PHP pro práci s proudy a funkce pro práci s
buffery a nějak to před odesláním binárně poslepovat (brr, složité)</li>
  <li>Použít následující fintu:</li>
</ul>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;img
src="48_show.php?obrazek=1"&gt;&lt;br&gt;<br>
To je moje kočka ;-))&lt;br&gt;<br>
&lt;img src="48_show.php?obrazek=2"&gt;&lt;br&gt;<br>
Neuvěřitelná podobnost mého kamaráda a agenta Smithe z
Matrixu.&lt;br&gt;</font>
</code></div>
<!-- Zaza PHP kód END -->

<p>Opravdu to funguje a opravdu v tom není žádná záludnost. Prostě jsme
jako zdroj obrázku nepoužili soubor jpg, ale soubor, který jej "nějak"
generuje.<br>
</p>
<a name="000210"></a><h2>Závěr</h2>
<p>Ukládání binárních dat do databáze je většinou jako technika
kritizováno, ale někdy se to může hodit. Při vkládání dat používejte
addslashes. Pozor, je nutné vědět, jakého typu jsou vkládaná data,
pokud s nimi budete chtít pracovat pomocí PHP a zobrazovat je v
prohlížeči. </p>
<a name="000211"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (49) - Kam kráčíš, MySQL?</h2>
			<p class="perex">Dnes uzavřeme úsek seriálu o PHP, který se trochu specializoval na spolupráci s databází MySQL.
				<br>
			</p>
			<p>Shrňme si dnes poznatky, které se budou týkat PHP a MySQL, abychom
toto téma mohli s čistým svědomím opustit. Můžete to pojmout jako
shrnutí a zároveň jako malý rozcestníček. Budou tu odkazy na jiné
články uveřejněné tady na Linuxsoftu.<br>
</p>
<a name="000212"></a><h2>Co si zapamatovat</h2>
<p>Pravděpodobně to nejdůležitější co byste si měli zapamatovat je to,
že PHP používá pro práci s databází sadu příkazů, které všechny
začínají mysql_. Zopakujme si ty podstatné v přehledné tabulce:<br>
</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Příkaz</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Význam</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">mysql_connect<br>
      </td>
      <td style="vertical-align: top;">Připojí se k MySQL<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">mysql_select_db<br>
      </td>
      <td style="vertical-align: top;">Vybere pracovní databázi<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">mysql_query<br>
      </td>
      <td style="vertical-align: top;">Vykoná dotaz (výběrový,
aktualizační atd.)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">mysql_fetch_array (_row, _object)<br>
      </td>
      <td style="vertical-align: top;">Převezme řádek výsledku do
asoc.pole (pole, objektu)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">mysql_num_rows<br>
      </td>
      <td style="vertical-align: top;">Vrátí počet řádků ve výsledku<br>
      </td>
    </tr>
  </tbody>
</table>
<p>Pamatovat si alespoň tyto základní příkazy se vyplatí. PHP podporuje
celou řadu databází a příkazy pro práci s nimi jsou podobné; pouze
místo prefixu mysql_ začínají jinak.</p>
<p>To druhé, co byste si měli zapamatovat je, že MySQL, stejně jako
všechny ostatní databáze, používá nějaký dialekt jazyka SQL. To
znamená, že musíme vědět, jak máme formulovat příkaz předávaný pomocí
mysql_query tak, aby mu naše databáze skutečně rozuměla. Jedna rada:
Pakliže se rozhodnete pracovat převážně s MySQL, rzhodně stojí za to
naučit se dobře dialekt SQL, kterému MySQL rozumí. Pokud naopak budete
potřebovat pracovat s více databázemi, používejte manuály a vůbec se za
to nestyďte. SQL dialekty bývají totiž velmi podobné a snadno si je
budete plést.<br>
</p>
<p>Konečně, je třeba si přiznat, že ani ten nejlepší programátor nezná
všechno z hlavy. Měli byste mít vždycky při ruce manuál k MySQL. Jeho <a href="http://dev.mysql.com/doc/mysql/en/index.html">ON-LINE verze</a>
má tu výhodu, že obsahuje uživateli doplněné komentáře. Bývají
mimořádně cenné.</p>
<p></p>
<a name="000213"></a><h2>Programy, které je třeba znát<br>
</h2>
<p>Měli byste vědět, že vývoj pomocí PHP a MySQL bude pravděpodobně
vyžadovat další nástroje. Například asi budete chtít něco na prohlížení
dat v MySQL. Projektů je mnoho. Můžete si vybrat například pomocí <a href="http://www.linuxsoft.cz/article.php?id_article=255">našeho
seriálu</a> na Linuxsoftu, nebo se zeptat někoho, kdo s tím má nějaké
zkušenosti.<br>
</p>
<p>U nás vyšel rovněž rozsáhlý článek o <a href="http://www.linuxsoft.cz/article.php?id_article=298">administraci
MySQL</a>. Dovést databázovou aplikaci ke zdárnému konci vyžaduje
většinou mnoho úsilí, takže neváhejte a vyberte si takové nástroje,
které Vám padnou. Náš seriál samozřejmě nepokryl všechny aspekty práce
s MySQL. Nezapomeňte, že databáze potřebuje nejen data zapisovat a
vybírat. Potřebuje být:<br>
</p>
<ul>
  <li>správně nainstalována<br>
  </li>
  <li>optimalizována</li>
  <li>zálohována</li>
  <li>zabezpečena</li>
  <li>kontrolována</li>
  <li>vyladěna na výkon</li>
</ul>
<p>a tak dále. Naprostá většina těchto témat ale přesahuje rámec našeho
seriálu. Existují specializované servery, kde byste se měli dozvědět
všechno, co potřebujete. Server <a href="http://www.mysql.cz/">www.mysql.cz</a>
je zatím ve vývoji, <a href="http://www.mysql.sk/">www.mysql.sk</a> byl
nedávno spuštěn; snad se tam bude něco dít.<br>
</p>
<p></p>
<a name="000214"></a><h2>Kam kráčíš, MySQL?</h2>
<p>Je třeba dodat, že MySQL, stejně jako PHP je stále aktivně vyvíjena.
V době psaní tohoto článku je k dispozici stabilní verze MySQL 4.0.21 a
alfa verze 5.0.0. Pětkové verze by měly přinést to podstatné, co MySQL
zatím chybí, aby mohla mít punc "velké" databáze. Bude se jednat
zejména o následující věci:</p>
<ul>
  <li>Pohledy (views), a to jak read-only, tak i aktualizovatelné.</li>
  <li>Uložené procedury</li>
  <li>Spouště</li>
  <li>Lepší podpora transsakcí</li>
</ul>
<p>Jakmile se to stane, dostanou vývojáři do ruky nový mocný nástroj.
Některé věci, které se dnes dají provést pouze pomocí PHP+MySQL se
budou dát udělat v samotné databázi. Některé postupy představené v
našem seriálu přestanou platit, nebo budou zbytečně složité. To je
vývoj.<br>
</p>
<p>Aniž bych byl nějaký databázový guru, chtěl bych upozornit na jednu
věc: Se vzrůstajícícmi schopnostmi databáze se bude pochopitelně
snižovat její rychlost. Netuším, jestli to bude znamenat pohřeb pro
MySQL nebo ne, ale měli byste to vědět. Ostatně, nikdo Vám nebude
bránit používat starší verze, pokud si to budete přát. <br>
</p>
<p style="font-style: italic;">Pozn.: Mimochodem, zde na Linuxsoftu
běží ještě "trojková" verze MySQL. A vidíte - pro naše příklady to
bohatě stačilo.<br>
</p>
<p>Jestliže zavzpomínáte na úvodní článek o <a href="#000144">PHP a
databázích</a>, bylo tam řečeno, že existují i jiné "správné" databáze.
Z hlediska PHP je to většinou jedno, neb PHP umí přistupovat k naprosté
většině dnes existujících databází. Ať už přímo, nebo prostřednictvím
nějakého ODBC rozhraní. Chci tím říci, že kterériem pro výběr databáze
nebude "umí to pracovat s PHP?", ale "co to všechno umí?".<br>
</p>
<a name="000215"></a><h2>Závěr</h2>
<p>Pro malé až střední projekty, zejména pro ty databázové, bude
pravděpodobně ve většině případů databáze MySQL tou správnou volbou.
Pokud byste potřebovali něco většího, pravděpodobně se poohlédnete po
nějaké recenzi databázových produktů. Jednu tady na Linuxsoftu <a href="http://www.linuxsoft.cz/article.php?id_article=304">máme</a>,
prostudujte ji. Vítejte ve svobodném světě, volba je na Vás.<br>
</p>
<p>V dalším díle seriálu odhlédneme od světa databází a povíme si
některé věci o autorizování uživatelů při jejich přístupu na web.
Samozřejmě, pomocí PHP.</p>

<a name="000216"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (50) - Ověřování uživatelů</h2>
			<p class="perex">Jak pomocí PHP zajistit, aby se uživatel musel před shlédnutím stránky přihlásit?
				<br>
			</p>
			<p>Weby psané pomocí PHP se málokdy skládají z jedné stránky. Většinou
jde o sadu stránek, které jsou vzájemně nějak provázané a které
zajišťují různé úkoly. S tím souvisí otázka zabezpečení - asi nebudete
chtít pouštět uživatele na administrační stránku. Dnes si tedy ukážeme,
jak pomocí PHP přihlásit uživatele.</p>
<p>Ono to má související problém, a tím je sdílení dat mezi více
stránkami. Tomu se budeme postupně věnovat v následujících dílech
seriálu. Ale pochopitelně to, zda je uživatel přihlášen je rovněž často
potřeba vědět na více stránkách.<br>
</p>
<a name="000217"></a><h2>Ověřování pomocí WWW-Authenticate</h2>
<p>Mějme například následující stránku PHP:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$server</font><font color="#007700">=</font><font color="#dd0000">"mysql.linuxsoft.cz"</font><font color="#007700">;<br>
</font><font color="#0000bb">$user</font><font color="#007700">=</font><font color="#dd0000">"Petr Zajíc"</font><font color="#007700">;<br>
</font><font color="#0000bb">$password</font><font color="#007700">=</font><font color="#dd0000">"heslo"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Při přihlášení se musí použít
server &lt;B&gt;$server&lt;/B&gt;, <br>
uživatel &lt;B&gt;$user&lt;/B&gt; a heslo &lt;B&gt;$password&lt;/B&gt;."</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Asi chápete, že sem byste běžného uživatele pustit nechtěli. Pomocí
PHP však můžete povolit vstup pouze autentifikovaným uživatelům.
Princip je velmi jednoduchý. Musíte donutit server, aby si myslel, že
ke stránce nemá přístup kdekdo, a požádal Vás o autentifikaci. To lze
provést pomocí jedné z hlaviček protokolu http:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"WWW-Authenticate: Basic
realm=\"oblast_hesel\""</font><font color="#007700">);<br>
</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"HTTP/1.0 401 Unauthorized"</font><font color="#007700">);</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jakmile tato hlavička dorazí na server, neodešle klientovi (tedy
prohlížeči) tělo stránky, ale požadavek na autentifikaci. Takže se Vám
v prohlížeči objeví klasické okno pro zadání jména a hesla. To je pak
odesláno zpět na server a (což je pro nás důležité) uloženo pro další
práci jako součást informací v asociativním poli $_SERVER. Konkrétně je
to takto:<br>
</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Informace<br>
      </td>
      <td style="vertical-align: top;">Získaná pomocí<br>
      </td>
      <td style="vertical-align: top;">Je v proměnné<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Uživatelské jméno<br>
      </td>
      <td style="vertical-align: top;">kolonky "jméno uživatele"
přihlašovacícho dialogu<br>
      </td>
      <td style="vertical-align: top;">$_SERVER['PHP_AUTH_USER']<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Heslo<br>
      </td>
      <td style="vertical-align: top;">kolonky "heslo" přihlašovacícho
dialogu</td>
      <td style="vertical-align: top;">$_SERVER['PHP_AUTH_PW']</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Typ autentifikace<br>
      </td>
      <td style="vertical-align: top;">hodnoty hlavičky
WWW-Authenticate (PHP umí jen typ Basic)<br>
      </td>
      <td style="vertical-align: top;">$_SERVER['AUTH_TYPE']</td>
    </tr>
  </tbody>
</table>
<p>Aby nedošlo k mýlce - ověření jména a hesla musíme provést sami.
Uvedený postup jméno a heslo pouze od uživatele získal, informace však
nijak neporovnával s žádným seznamem povolených uživatelů a/nebo hesel.
Můžete například ověřit jméno a heslo proti databázi nebo je porovnat s
údaji v samotném skriptu. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Uvedené věci platí ovšem
jen tehdy, pokud PHP běží jako modul Apache. Jestliže běží jako
interpreter CGI, nebude to fungovat.<br>
</span></p>
<a name="000218"></a><h2>Praxe<span style="font-style: italic;"></span></h2>
<p>V praxi musíte pamatovat ještě na pár technických detailů. Příjemné
je například to, že po úspěšném ověření jsou přihlašovací informace pro
daný realm k dispozici i dalším skriptům, a to až do odhlášení nebo
uzavření prohlížeče. Z toho vyplývají dvě věci:<br>
</p>
<ul>
  <li>můžete napsat přihlašovací skript a včlenit jej do více stránek</li>
  <li>přihlašovací skript by měl nejprve zjistit, zda již autentifikace
neproběhla. Pokud neproběhla měl by ji provést; pokud však již
proběhla, měl by autentifikační údaje ověřit</li>
</ul>
<p>Mějme tedy jako příklad dvě "super tajné" stránky. Všimněte si, že z
každé vede odkaz na tu druhou:</p>
<p><a href="./examples/50_1.html" target="_blank">Ukázat
skript 1</a></p>
<p><a href="./examples/50_2.html" target="_blank">Ukázat
skript 2</a></p>
<p>Jestliže budeme chtít, aby na obě stránky měl přístup pouze uživatel
<span style="font-weight: bold;">Honza </span>s heslem <span style="font-weight: bold;">jezevec</span>, půjdeme na to následovně:
Nejprve si vytvoříme soubor auth.php, který bude obsluhovat ověřování:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">if (!IsSet(</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_AUTH_USER"</font><font color="#007700">]))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"WWW-Authenticate: Basic
realm=\"Hesla\""</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"HTTP/1.0 401
Unauthorized"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Přístup pouze na
uživatelské jméno a heslo."</font><font color="#007700">;<br>
&nbsp;&nbsp;exit;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_AUTH_USER"</font><font color="#007700">]!=</font><font color="#dd0000">"Honza"</font><font color="#007700">) { echo </font><font color="#dd0000">"Neplatné
přihlašovací jméno!"</font><font color="#007700">; exit;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"PHP_AUTH_PW"</font><font color="#007700">]!=</font><font color="#dd0000">"jezevec"</font><font color="#007700">) { echo </font><font color="#dd0000">"Neplatné
heslo!"</font><font color="#007700">; exit;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>A následně pomocí direktivy require tento soubor vložíme na začátek
našich dvou skriptů. Výsledek bude tento:</p>
<p><a href="./examples/50_1b.html" target="_blank">Ukázat
skript 1</a></p>
<p><a href="./examples/50_2b.html" target="_blank">Ukázat
skript 2</a></p>
<p>Všimněte si, že ověřování můžete zkazit jenom jednou, protože pak si již server zadané údaje pamatuje. 
To je trošičku nevýhoda uvedeného postupu, ale je víceméně jediná. Rovněž si všimněte, že po ověření z libovolného 
z obou skriptů je automaticky k dispozici i ten druhý.</p>
<p>V dalším díle našeho seriálu se podíváme na lehce příbuzné téma - a tím bude sdílení informací mezi stránkami.</p>

<a name="000219"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (51) - Přenos dat mezi stránkami</h2>
			<p class="perex">Mějme dva PHP skripty. Jak sdílet data mezi nimi? Budete to potřebovat!
				<br>
			</p>
			<p>V předchozím díle seriálu jsme si ukázali, že není až takový problém
pomocí PHP vyžádat po uživateli ověřující informace. Jejich výhoda je
ta, že se automaticky posílají na každou další stránku, takže ověření
uživatele stačí provést jenom jednou. Často budeme ale podobný
mechanismus potřebovat nejen pro přenos přihlašovacích údajů, ale i pro
jiné proměnné. </p>
<p>Předpokládejme malou aplikaci, do níž se uživatel již přihlásil.
Dejme tomu, že uvnitř aplikace budeme potřebovat mezi jednotlivými
stránkami zároveň přenášet nějaký identifikátor uživatele, čas
přihlášení a třebas počet stránek, které navštívil po svém přihlášení.
Pravděpodobně nejjednodušší bude zamontovat tyto informace do URL
stránky a neustále je mezi sebou posílat. Asi takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">if(isset(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])) </font><font color="#0000bb">$id</font><font color="#007700">=</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">]; else </font><font color="#0000bb">$id</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">;<br>
if(isset(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">])) </font><font color="#0000bb">$cas</font><font color="#007700">=</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">]; else </font><font color="#0000bb">$cas</font><font color="#007700">=</font><font color="#0000bb">time</font><font color="#007700">();<br>
if(isset(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">])) </font><font color="#0000bb">$stranek</font><font color="#007700">=++</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">]; else </font><font color="#0000bb">$stranek</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">;<br>
<br>
echo </font><font color="#dd0000">"&lt;h1&gt;Vítejte na naší
stránce&lt;/h1&gt;"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"&lt;p&gt;Vaše údaje jsou:"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"&lt;BR&gt;ID: "</font><font color="#007700">.</font><font color="#0000bb">$id</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"&lt;BR&gt;Čas přihlášení: "</font><font color="#007700">.</font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"j.n.Y G:i:s"</font><font color="#007700">,</font><font color="#0000bb">$cas</font><font color="#007700">);<br>
echo </font><font color="#dd0000">"&lt;BR&gt;Počet navštívených
stránek po přihlášení: "</font><font color="#007700">.</font><font color="#0000bb">$stranek</font><font color="#007700">;<br>
<br>
echo </font><font color="#dd0000">"&lt;p&gt;&lt;a
href=\"51_druha.php?id="</font><font color="#007700">.</font><font color="#0000bb">$id</font><font color="#007700">.</font><font color="#dd0000">"&amp;amp;cas="</font><font color="#007700">.</font><font color="#0000bb">$cas</font><font color="#007700">.</font><font color="#dd0000">"&amp;stranek="</font><font color="#007700">.</font><font color="#0000bb">$stranek</font><font color="#007700">.</font><font color="#dd0000">"\"&gt;Na další stránku aplikace&lt;/a&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Z celého příkladu bude pravděpodobně nejdůležitější poslední řádek.
Všimněte si, že musíme sestavit odkaz včetně toho, že do něj uvedeme
všechny proměnné, aby nám to mohlo fungovat.<br>
</p>
<p>V praxi má tento přístup jednu podstatnou výhodu - bude to pracovat
úplně všude. A zejména pro hodně malé projekty to bude pravděpodobně
stačit. Abychom byli upřímní, má tento přístup ke sdílení informací
mezi stránkami rovněž poměrně podstatné nevýhody. Asi tou největší je
fakt, že údaje přenášené mezi stránkami se dají jednoduše přečíst a
změnit. Jsou totiž vidět v prohlížeči v řádku s adresou.<br>
</p>
<p></p>
<a name="000220"></a><h2>Jak to napravit</h2>
<p>Pakliže byste trvali na přenosu dat pomocí parametrů, ale zároveň
byste chtěli zabránit jejich přečtení, mám pro Vás dobrou zprávu - jde
to. Nic Vám totiž nebrání přenášet parametry nějak zašifrovaně. Jedna
dobrá metoda spočívá v použití funkcí knihovny <a href="http://cz.php.net/manual/cs/ref.mcrypt.php">Mcrypt</a>, pokud ji
instalace PHP na vašem serveru podporuje. Jelikož jí instalace PHP na
vašem serveru z různých důvodů podporovat nemusí, můžete zkusit najít
nějaký hotový PHP skript na šifrování (já hledal třeba <a href="http://pear.php.net/package-search.php?pkg_name=crypt&amp;bool=AND&amp;submit=Search">tady</a>).<br>
</p>
<p>Lehce zmodifikovaný kód našeho původního skriptu by tedy byl:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">// odkaz na šifrovací třídu...<br>
</font><font color="#0000bb">$sifra</font><font color="#007700">= new </font><font color="#0000bb">Crypt_Xtea</font><font color="#007700">;<br>
<br>
</font><font color="#ff8000">// po přijetí data dekódujeme...<br>
</font><font color="#007700">if(isset(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])) </font><font color="#0000bb">$id</font><font color="#007700">=</font><font color="#0000bb">$sifra</font><font color="#007700">-&gt;</font><font color="#0000bb">decrypt</font><font color="#007700">(</font><font color="#0000bb">base64_decode</font><font color="#007700">(</font><font color="#0000bb">urldecode</font><font color="#007700">(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])),</font><font color="#dd0000">"klíč"</font><font color="#007700">); else </font><font color="#0000bb">$id</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">;<br>
if(isset(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">])) </font><font color="#0000bb">$cas</font><font color="#007700">=</font><font color="#0000bb">$sifra</font><font color="#007700">-&gt;</font><font color="#0000bb">decrypt</font><font color="#007700">(</font><font color="#0000bb">base64_decode</font><font color="#007700">(</font><font color="#0000bb">urldecode</font><font color="#007700">(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">])),</font><font color="#dd0000">"klíč"</font><font color="#007700">); else </font><font color="#0000bb">$cas</font><font color="#007700">=</font><font color="#0000bb">time</font><font color="#007700">();<br>
if(isset(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">])) </font><font color="#0000bb">$stranek</font><font color="#007700">=</font><font color="#0000bb">$sifra</font><font color="#007700">-&gt;</font><font color="#0000bb">decrypt</font><font color="#007700">(</font><font color="#0000bb">base64_decode</font><font color="#007700">(</font><font color="#0000bb">urldecode</font><font color="#007700">(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">])),</font><font color="#dd0000">"klíč"</font><font color="#007700">)+</font><font color="#0000bb">1</font><font color="#007700">; else </font><font color="#0000bb">$stranek</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">;<br>
<br>
</font><font color="#ff8000">// tady by byla práce s aplikací<br>
<br>
// před přenesením zakódujeme...<br>
</font><font color="#0000bb">$id</font><font color="#007700">=</font><font color="#0000bb">urlencode</font><font color="#007700">(</font><font color="#0000bb">base64_encode</font><font color="#007700">(</font><font color="#0000bb">$sifra</font><font color="#007700">-&gt;</font><font color="#0000bb">encrypt</font><font color="#007700">((string)</font><font color="#0000bb">$id</font><font color="#007700">, </font><font color="#dd0000">"klíč"</font><font color="#007700">)));<br>
</font><font color="#0000bb">$cas</font><font color="#007700">=</font><font color="#0000bb">urlencode</font><font color="#007700">(</font><font color="#0000bb">base64_encode</font><font color="#007700">(</font><font color="#0000bb">$sifra</font><font color="#007700">-&gt;</font><font color="#0000bb">encrypt</font><font color="#007700">((string)</font><font color="#0000bb">$cas</font><font color="#007700">, </font><font color="#dd0000">"klíč"</font><font color="#007700">)));<br>
</font><font color="#0000bb">$stranek</font><font color="#007700">=</font><font color="#0000bb">urlencode</font><font color="#007700">(</font><font color="#0000bb">base64_encode</font><font color="#007700">(</font><font color="#0000bb">$sifra</font><font color="#007700">-&gt;</font><font color="#0000bb">encrypt</font><font color="#007700">((string)</font><font color="#0000bb">$stranek</font><font color="#007700">, </font><font color="#dd0000">"klíč"</font><font color="#007700">)));<br>
<br>
echo </font><font color="#dd0000">"&lt;p&gt;&lt;a
href=\"51_druha_s.php?id="</font><font color="#007700">.</font><font color="#0000bb">$id</font><font color="#007700">.</font><font color="#dd0000">"&amp;amp;cas="</font><font color="#007700">.</font><font color="#0000bb">$cas</font><font color="#007700">.</font><font color="#dd0000">"&amp;stranek="</font><font color="#007700">.</font><font color="#0000bb">$stranek</font><font color="#007700">.</font><font color="#dd0000">"\"&gt;Na nějakou jinou stránku&lt;/a&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/51_prvni_s.html" target="_blank">Ukázat
celý skript</a></p>
<p>Vidíme, že skript obsahuje několik nových věcí. Tak především je to
použití třídy Crypt_Xtea ze stejnojmenného balíčku staženého z
repository <a href="http://pear.php.net/package/Crypt_Xtea">PEAR</a>.
Tato třída se stará o vlastní šifrování dat pomocí klíče, který jsme
vtipně nazvali "klíč".<br>
</p>
<p style="font-style: italic;">Pozn.: Malá odbočka - pokud si
vzpomínáte na díl seriálu o <a href="#000078">objektovém
programování</a>, tohle je přesně příklad demonstrující použití
objektů. Vůbec nemusím vědět, jak funguje třída Crypt_Xtea vevnitř,
stačí mi, když si v <a href="http://pear.php.net/package/Crypt_Xtea/docs/1.1.0RC1/Crypt_Xtea/Crypt_Xtea.html">dokumentaci</a>
najdu co umí a jak to použít. V produkčním nasazení byste pochopitelně
každý kód měli řádně testovat. O kódu přejatém to platí dvojnásob.<br>
</p>
<p>Potom je tu použita funkce <a href="http://cz.php.net/manual/en/function.base64-encode.php">base64_encode</a>.
Ta už neprovádí žádné
šifrování dat, pouze je kóduje. To je nutné, protože výstup z
šifrovacího algoritmu skoro určitě bude obsahovat binární data a ta
bychom jako parametr příkazové řádky nepřenesli. Konečně, <a href="http://cz.php.net/manual/en/function.urlencode.php">urlencode</a>
zase zajistí, že do parametru se nedostanou znaky, které tam nemají co
dělat. <br>
</p>
<p>Při načítání stránky data zpracujeme pomocí odpovídajících funkcí
<a href="http://cz.php.net/manual/en/function.urldecode.php">urldecode</a>,
<a href="http://cz.php.net/manual/en/function.base64-decode.php">base64_decode</a>
a decrypt, pochopitelně v tomto pořadí. Tak
tedy můžeme mezi stránkami přenášet informace zašifrovaně. Což řeší
problém s jejich odhalením nebo modifikací. Ovšem, neřeší to jiný vážný
problém: Někdo by mohl zkopírovat celou adresu skriptu včetně parametrů
a mohl by se na naši stránku dostat.<br>
</p>
<p>To se nějak obecně řešit nedá a je to asi největší úskalí tohoto
způsobu práce mezi stránkami. Pokud byste ovšem používali šifrování,
můžete si pohrát s myšlenkou dynamické změny klíče (třeba v závislosti
na čase serveru). Pokud bychom například použili čas přihlášení jako
klíč (či jako podklad pro jeho generování), pravděpodobně bychom měli
problém vyřešen.<br>
</p>
<a name="000221"></a><h2>Výhody a nevýhody</h2>
<p>Předávání informací důležitých pro běh skriptu jako parametry URL má
tedy následující výhody:<br>
</p>
<ul>
  <li>Bude to fungovat úplně všude</li>
  <li>Trochu se to dá šifrovat</li>
</ul>
a následující nevýhody:<br>
<ul>
  <li>Je to náročné na psaní kódu</li>
  <li>Hrozí neoprávněný přístup</li>
  <li>Nehodí se to pro mnoho dat ani pro dlouhá data</li>
  <li>Je to relativně pomalé</li>
</ul>
<p>Příště si ukážeme, jak obdobný problém řešit jiným způsobem. Budou
to
cookies.</p>
<a name="000222"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (52) - Cookies</h2>
			<p class="perex">Mohou nám cookies usnadnit práci s PHP a webem? Zjistěme to!
				<br>
			</p>
			<p>Minule jsme sdíleli informace mezi stránkami pomocí parametrů v
odkazech. Dnes se podíváme na to, jak lze pro obdobnou činnost využít
cookies.<br>
</p>
<a name="000223"></a><h2>Cookies</h2>
<p>Cookies představují mechanismus pro ukládání informací na počítači
klienta. Tedy tam, kde spouštíme prohlížeč. Cookies (všimněte si, že se
to do češtiny nijak nepřekládá, přestože pokusy tu byly) fungují na
velice jednoduchém principu:<br>
</p>
<ol>
  <li>Pomocí PHP vysvětlíme serveru, že by s nějakou stánkou (tedy
odpovědí) měl
odeslat do prohlížeče rovněž jednu nebo více cookies</li>
  <li>Cookies (které obsahují název a hodnotu) se pošlou prohlížeči
spolu s požadovanou stránkou (a to v hlavičce)</li>
  <li>Prohlížeč pochopí, že by měl cookies nějak zpracovat a
"zapamatuje" si jejich název a hodnotu</li>
  <li>Když se pomtom prohlížeč na stejnou stránku (resp. stejný server)
vrátí, bude automaticky posílat cookies.<br>
  </li>
</ol>
<p>PHP má pro ukládání cookies příkaz <a href="http://cz.php.net/manual/cs/function.setcookie.php">setcookie</a>.
Než to nějak dlouhosáhle vysvětlovat, raději si to ukážeme na malém
příkladu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
SetCookie </font><font color="#007700">(</font><font color="#dd0000">"nazev_cookie"</font><font color="#007700">, </font><font color="#dd0000">"hodnota"</font><font color="#007700">);<br>
echo </font><font color="#dd0000">"Tato stránka Vám poslala cookie!"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p style="font-style: italic;">Pozn.: Jelikož se cookies odesílají v
hlavičce odpovědi, neměli byste příkaz SetCookie použít poté, co byl
jakýkoli jiný výstup odeslán do prohlížeče. Což je úplně stejná zásada
jako při použití příkazu header. Ve skutečnosti, pokud se vyznáte v
syntaxi hlaviček, můžete nastavovat cookies i pomocí příkazu header.</p>
<p>Pakliže používáte nějaký vyspělý prohlížeč (třeba Mozillu, v IE to
opravdu nehledejte), máte většinou k dispozici Správce souboru
Cookies (V mozille je v nástrojích). Zde se můžete podívat, že daná
cookie Vám byla skutečně
odeslána.<br>
</p>
<a name="000224"></a><h2>Platnost cookie</h2>
<p>Příkaz setcookie má ještě nepovinné parametry. Hned prvním
nepovinným parametrem je doba platnosti cookie. Udává se jako unixový
čas a znamená, že prohlížeč bude danou cookie odesílat na server jen
určitou dobu, a pak ji zapomene. Takže, kdybychom chtěli v předchozím
případě naši cookie považovat za platnou například deset minut, můžeme
použít konstrukci</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
SetCookie </font><font color="#007700">(</font><font color="#dd0000">"nazev_cookie"</font><font color="#007700">, </font><font color="#dd0000">"hodnota"</font><font color="#007700">, </font><font color="#0000bb">time</font><font color="#007700">()+</font><font color="#0000bb">10</font><font color="#007700">*</font><font color="#0000bb">60</font><font color="#007700">);<br>
echo </font><font color="#dd0000">"Tato stránka Vám poslala cookie!"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p><span style="font-style: italic;">Pozn.: Abyste mohli prohlížeč
vypnout a znova zapnout, a aby si tu cookie stále pamatoval, musí ji
pochopitelně uložit na disk. V Mozille například k tomu slouží soubor
cookies.txt v adresáři profilu prohlížeče. Cookies bez udané doby
platnosti jsou zapomenuty po ukončení práce s prohlížečem a většina
prohlížečů je vůbec na disk neukládá.</span><br>
</p>
<a name="000225"></a><h2>Čtení cookies</h2>
<p>Čtení cookies je opravdu jednoduché. Protože cookies jsou v PHP k
dispozici pomocí asociativního pole $_COOKIE (pozor, není to
$_COOKIES). Takže můžeme pro práci s cookies použít něco ve stylu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"&lt;p&gt;Hodnota
naší cookie je "</font><font color="#007700">.</font><font color="#0000bb">$_COOKIE</font><font color="#007700">[</font><font color="#dd0000">"nazev_cookie"</font><font color="#007700">];<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Je to dost podobné jako použití proměnných z $_GET nebo $_POST. Ve
skutečnosti platí, že lze použít asociativní pole $_REQUEST nejen na
proměnné získané pomocí metod GET nebo POST, ale i na cookies.<br>
</p>
<p style="font-style: italic;">Pozn.: Název cookie by neměl obsahovat
"bílé" znaky (mezery, konce řádků a tabelátory). Jednak je to v rozporu
se <a href="http://wp.netscape.com/newsref/std/cookie_spec.html">specifikací</a>,
a jednak většina takových prohlížečů potom cookie sice uloží, ale už
nám ji nevrátí.<br>
</p>
<a name="000226"></a><h2>Náš příklad</h2>
<p>Připomeňme si, že minule jsme v příkladu potřebovali evidovat
identifikátor uživatele, čas přihlášení a počet stránek navštívených po
přihlášení. Kdybychom to chtěli přepsat do podoby s použitím cookies,
dopadne to takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">if(!isset(</font><font color="#0000bb">$_COOKIE</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])) </font><font color="#0000bb">setcookie </font><font color="#007700">(</font><font color="#dd0000">"id"</font><font color="#007700">, </font><font color="#0000bb">1</font><font color="#007700">);<br>
if(!isset(</font><font color="#0000bb">$_COOKIE</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">])) </font><font color="#0000bb">setcookie </font><font color="#007700">(</font><font color="#dd0000">"cas"</font><font color="#007700">, </font><font color="#0000bb">time</font><font color="#007700">());<br>
if(isset(</font><font color="#0000bb">$_COOKIE</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">])) </font><font color="#0000bb">setcookie </font><font color="#007700">(</font><font color="#dd0000">"stranek"</font><font color="#007700">, ++</font><font color="#0000bb">$_COOKIE</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">]); else </font><font color="#0000bb">setcookie</font><font color="#007700">(</font><font color="#dd0000">"stranek"</font><font color="#007700">,</font><font color="#0000bb">1</font><font color="#007700">);<br>
<br>
echo </font><font color="#dd0000">"&lt;h1&gt;Vítejte na naší
stránce&lt;/h1&gt;"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"&lt;p&gt;Vaše údaje jsou:"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"&lt;BR&gt;ID: "</font><font color="#007700">.</font><font color="#0000bb">$_COOKIE</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">];<br>
echo </font><font color="#dd0000">"&lt;BR&gt;Čas přihlášení: "</font><font color="#007700">.</font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"j.n.Y G:i:s"</font><font color="#007700">,</font><font color="#0000bb">$_COOKIE</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">]);<br>
echo </font><font color="#dd0000">"&lt;BR&gt;Počet navštívených
stránek po přihlášení: "</font><font color="#007700">.</font><font color="#0000bb">$_COOKIE</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">];<br>
<br>
echo </font><font color="#dd0000">"&lt;p&gt;&lt;a
href=\"52_druha.php\"&gt;Na další stránku aplikace&lt;/a&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Náš skript obsahuje několik změn a taky se trochu jinak chová.
Především si všimněte použítí příkazu setcookie a pole $_COOKIE. Když
si to budete chtít spustit, uvidíte rovněž, že nově nastavená cookie
jsou (logicky) k dispozici až po dalším načtení stránky, takže na to v
reálném světě pamatujte (asi by se postupovalo tak, že by se
zobrazované informace uložily do lokálních proměnných). Konečně si
všimněte příjemné věci - že další stránky aplikace můžeme volat bez
jakýchkoli parametrů.<br>
</p>
<a name="000227"></a><h2>Problémy s cookies</h2>
<p>Ačkoli jsou cookies mnohem jednodušší na používání než předávání
hodnot pomocí url (byla o tom řeč minule), přesto jejich používání
přináší jisté problémy. Asi nejhorší je, že uživatel může ukládání
cookies v prohlížeči <span style="font-weight: bold;">zakázat</span>.
Pakliže Vaše aplikace na cookies závisí, jste v takovém případě
nahraní. Lze sice otestovat, zda se cookie uložila, ale už nelze
bezpečně zjistit, zda uživatel nezakázal prohlížeči práci s cookies
třebas druhý den.<br>
</p>
<p>Související problém je ten, že uživatel může cookies <span style="font-weight: bold;">změnit </span>či <span style="font-weight: bold;">smazat </span>ručně. Vždyť se ukládají do
textových souborů. Server si tedy nikdy nemůže být jist, zda cookie,
kterou dostal je táž, kterou prohlížeč kdysi uložil.<br>
</p>
<p>Konečně, informace uložené pomocí cookies jsou snadno <span style="font-weight: bold;">čitelné</span>. Můžete je sice šifrovat
(mluvili jsme o tom minule), ale to jejich použití zase už nebude tak
jednoduché. Takže byste nikdy neměli do cookies ukládat nějak extrémně
citlivé informace.<br>
</p>
<p>Příště se podíváme na způsob přenosu informací mezi stránkami, který
má asi nejméně omezení z dosud uvedených. Budou to sessions.</p>
<a name="000228"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (53) - Sessions</h2>
			<p class="perex">Dá se použít něco jiného než cookies? Ano, sessions. Dnes se v našem seriálu podíváme, jak na to v PHP. 
				<br>
			</p>
			<p>Pokud jste dávali pozor při sledování minulého dílu našeho seriálu,
pravděpodobně jste zjistili, že cookies jsou relativně složité. Server
je musí
vygenerovat a poslat prohlížeči, který je následně posílá zase zpět na
server. Nedalo by se něco takového dělat přímo na serveru, bez
odesílání dat sem a tam? Ano, to by se dalo. Mechanismus, který takto
funguje, nazýváme sessions.<br>
</p>
<p>Myšlenka sessions není nová a PHP rozhodně není první jazyk, který
sessions podporoval. Ve skutečnosti jsou sessions v PHP podporovány až
od verze 4.0. To v současné době už moc nevadí, většina serverů používá
"čtyřkové" PHP. Jazyk PHP má práci se sessions docela
propracovanou. Jak to celé funguje? Zjednodušeně řečeno je to takto:<br>
</p>
<ul>
<li>Jakmile PHP obdrží příkaz k započetí session, zjistí nejprve, zda
již session neběží. Pokud ne vytvoří ji, pokud ano, připojí se k ní.
PHP přidělí session identifikátor a vyhradí si někde místo pro ukládání
tzv.
session-proměnných.</li>
<li>Od tohoto místa dále si můžete u libovolné proměnné zvolit, že
bude součástí session, a server si pak její obsah pamatuje mezi
stránkami.</li>
<li>Session můžete kdykoli ukončit. Když to neuděláte, zruší se
zavřením prohlížeče.</li>
</ul>
<p>Asi si říkáte, jak server jednotlivé prohlížeče od sebe odliší. Je
to jednoduché. Použije buďto cookie, o níž jsme mluvili minule, nebo
předá identifikátor session jako parametr do url, o čemž jsme mluvili
předminule. Rozdíly oproti předchozím dvěma způsobům předávání
informací mezi stránkami jsou přitom zejména tyto:<br>
</p>
<ul>
<li>Nepřenášejí se všechny proměnné spojené s danou session, nýbrž
jen jeden údaj - identifikátor samotné session.</li>
<li>O celou věc se PHP stará naprosto automaticky (nemusíte tedy
například měnit odkazy, abyste přenesli identifikátor session)</li>
<li>Můžete si zvolit, kde budou proměnné vázané k session uloženy (v
souboru na serveru, v databázi a podobně)</li>
</ul>
<span style="font-style: italic;">Pozn.: Výraz "session" se většinou
nepřekládá. Viděl jsem ucho počítačového experta drásájící
výrazy typu "sezení" či dokonce "seance". My se místo toho raději
přidržíme původního, anglického výrazu.<br>
</span>
<p>Předpokládám, že po tomto poněkud teoretickém úvodu se už těšíte na
nějaké příklady v PHP. Nuže, pojďme na to.<br>
</p>
<a name="000229"></a><h2>Sessions a PHP</h2>
<p>V PHP, jak už bylo řečeno, jsou od verze 4.0 sessions <a href="http://cz.php.net/manual/cs/ref.session.php">k dispozici v
"základní výbavě"</a> jazyka. To samozřejmě neznamená, že každý PHP
skript spouští session. Abyste mohli začít pracovat v session, musíte
to PHP oznámit pomocí příkazu session_start (). Typický skript
využívající session vypadá tedy následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
session_start</font><font color="#007700">();<br>
</font><font color="#0000bb">session_register</font><font color="#007700">(</font><font color="#dd0000">"promenna"</font><font color="#007700">);<br>
</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"promenna"</font><font color="#007700">]=</font><font color="#dd0000">"hodnota"</font><font color="#007700">;<br>
</font><font color="#ff8000">// ... atd...<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<p>Korektura: Sessions se od verze PHP 4.1.0 dají spouštět automaticky
a volání příkazu session_start tak není nutné. Konfigurační direktiva
session.auto_start ovlivňuje v tomto případě chování PHP. Více viz <a href="http://cz.php.net/manual/en/ref.session.php">manuál</a>. </p>
<!-- Zaza PHP kód END -->
<p>Tedy, jakmile je session nastartována, můžeme prohlásit, že proměnná
"promenna" je od této chvíle součástí session a je tudíž přístupná
pomocí prvku "promenna" globálního asociativního pole $_SESSION. Takže
libovolný další PHP skript na stejném serveru bude mít k této proměnné
přístup, za předpokladu, že bude součástí session. Je samozřejmě možné
mít zároveň i celou řadu proměnných, které <span style="font-style: italic;">nebudou </span>součástí session a
které při ukončení skriptu zmizí v propadlišti dějin.<br>
</p>
<p>Teď je ten správný čas přepsat naše dva skripty vyměňující si
informace do tvaru, kdy budou moci použít session. Bude to vypadat
takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
session_start</font><font color="#007700">();<br>
</font><font color="#0000bb">session_register</font><font color="#007700">(</font><font color="#dd0000">"id"</font><font color="#007700">);<br>
</font><font color="#0000bb">session_register</font><font color="#007700">(</font><font color="#dd0000">"cas"</font><font color="#007700">);<br>
</font><font color="#0000bb">session_register</font><font color="#007700">(</font><font color="#dd0000">"stranek"</font><font color="#007700">);<br>
<br>
if(!isset(</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])) </font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">]=</font><font color="#0000bb">1</font><font color="#007700">;<br>
if(!isset(</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">])) </font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">]=</font><font color="#0000bb">time</font><font color="#007700">();<br>
if(isset(</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">])) ++</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">]; else </font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">]=</font><font color="#0000bb">1</font><font color="#007700">;<br>
<br>
echo </font><font color="#dd0000">"&lt;h1&gt;Vítejte na naší
stránce&lt;/h1&gt;"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"&lt;p&gt;Vaše údaje jsou:"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"&lt;BR&gt;ID: "</font><font color="#007700">.</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">];<br>
echo </font><font color="#dd0000">"&lt;BR&gt;Čas přihlášení: "</font><font color="#007700">.</font><font color="#0000bb">date</font><font color="#007700">(</font><font color="#dd0000">"j.n.Y G:i:s"</font><font color="#007700">,</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">]);<br>
echo </font><font color="#dd0000">"&lt;BR&gt;Počet navštívených
stránek po přihlášení: "</font><font color="#007700">.</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"stranek"</font><font color="#007700">];<br>
echo </font><font color="#dd0000">"&lt;p&gt;&lt;a
href=\"53_druha.php\"&gt;Na další stránku aplikace&lt;/a&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Celý skript jsme již komentovali minule; nové je jen použití
session. Rovněž zde je třeba si uvědomit, že session musí být
nastartována předtím, než je jakýkoli výstup odeslán prohlížeči; to je
kvůli hlavičkám. Ve skutečnosti vám příklad v závislosti na nastavení
vašeho prohlížeče nemusí
fungovat. V úvodu jsem tvrdil, že identifikátor session je uložen buď v
cookie, nebo si ho PHP přidává do url. Ten druhý způsob je ale méně
bezpečný, a proto bývá někdy na serverech vypnut. Vypnut je i na
Linuxsoftu. Pokud tedy zakážete přijímat cookies ze serveru
www.linuxsoft.cz, nebude Vám výše uvedený příklad fungovat, protože PHP
nemá šanci předat prohlížeči identifikátor session a tudíž ji nemůže
použít.<br>
</p>
<p style="font-style: italic;">Pozn.: V takovém případě se ani
nepřihlásíte jako
uživatel, protože samotný portál linuxsoft pracuje se sessions. Což si
můžete ověřit, neb po přihlášení budete mít na svém počítači uloženou
cookie obsahující identifikátor session.<br>
</p>
<a name="000230"></a><h2>Kde jsou data?</h2>
<p>Data spojená s probíhající session jsou umístěna většinou v souboru
na serveru, a to mimo kořenový adresář serveru. Pro představu: jestliže
tedy spustíte výše uvedený příklad, vznikne na serveru soubor s
přibližně tímto obsahem:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">id|i:1;cas|i:1096972373;stranek|i:8;</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>O veškerou režii v souvislosti s tímto souborem se stará PHP, takže
to uvádím jen jako informaci pro lepší pochopení celého mechanizmu. PHP
se například postará o "úklid" souboru po zrušení session a podobně.<br>
</p>
<p>V souvislosti s tím se sluší zmínit ještě jednu věc: PHP umí (a na
většině serveru je toto povoleno) použít uživatelem definované
zacházení s sessions. To znamená, že můžete "přebít" funkci, kterou PHP
použije při správě session. Není vůbec neobvyklé ukládat si sessions do
databáze MySQL; někteří vývojáři tvrdí, že to může zvýšit výkon skriptu
nebo zabezpečení sessions. Můžete také napsat funkci, která data
session šifruje. Tak či onak, vynikající příklad definice uživatelské
správy sessions můžete najít například <a href="http://www.zend.com/zend/spotlight/code-gallery-wade8.php">zde</a>.
Jedná se právě o uložení proměnných session do databáze MySQL.</p>
<a name="000231"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (54) - Dodržování webových standardů</h2>
			<p class="perex">Při psaní v PHP byste měli dodržovat webové standardy. Jak? Uvidíte v dnešním článku.
				<br>
			</p>
			<p>Jelikož je PHP velmi úzce spojeno s tvorbou webu, je při psaní
stránek pomocí PHP potřeba myslet na dodržování určitých norem. Pojďme
se v
dnešním díle našeho seriálu podívat, jak nám PHP může být v tomto
ohledu nápomocno a jakých chyb bychom se měli v této souvislosti
naopak vyvarovat.</p>
<a name="000232"></a><h2>Stránky a normy</h2>
<p>Pakliže nejste na internetu úplnými nováčky, pravděpodobně víte, že
HTML
dokumenty mají svoji strukturu, která je předem daná. Na našem webu se
o tom
psalo například <a href="http://www.linuxsoft.cz/article.php?id_article=185">v seriálu o
HTML</a>, ale psalo se o tom samozřejmě i na mnoha jiných místech. Při
vývoji aplikace byste měli mít na paměti, že výsledkem PHP skriptu
bývají
HTML stránky a tyto stránky by měly odpovídat normám.<br>
</p>
<p>Tak například na webu <a href="http://www.w3.org/">World Wide Web
consortia</a> můžete najít vyčerpávající informace o webových
dokumentech, jejich specifikacích a můžete tam rovněž najít HTML <a href="http://validator.w3.org/">validátor</a>, který Vám umožní vaše
stránky (nebo skripty) ON-LINE otestovat. Měli byste si zvyknout
testovat validitu stránek již během vývoje, zejména pokud se jedná o
větší projekty. Je to dobrý zvyk - bez norem by web vůbec nemohl
existovat; úplně stačí, že normy okázale ignorují některé prohlížeče.<br>
</p>
<p style="font-style: italic;">Pozn.: Tady na Linuxsoftu máme například
pravidlo, podle něhož si autor má zkontrolovat validitu článku předtím,
než jej předá k uveřejnění. To je nanejvýš rozumné, protože to pomáhá
jak autorovi, tak editorovi, tak čtenáři.<br>
</p>
<p>Pojďme se teď podívat na některé konkrétní věci, jež s tím souvisejí
a jež můžeme ovlivnit pomocí PHP.<br>
</p>
<a name="000233"></a><h2>Hlavičky</h2>
<p>Jednou z věcí, které Váš webový dokument musí mít v pořádku jsou
hlavičky. Možná si vzpomínáte na hlavičku Location, pomocí níž můžeme
donutit server, aby načetl jinou stránku. Následující hlavička Location
je například formálně nesprávná, přestože se v tomto stylu na internetu
hojně vyskytuje (a přestože vám většinou bude fungovat):</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
header </font><font color="#007700">(</font><font color="#dd0000">"Location:
neco.php"</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Nesprávná je proto, že podle <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">specifikace</a>
by url v této hlavičce mělo být vždy absolutní. Přitom pomocí PHP není
problém absolutní hlavičku sestavit. Již jsme to v seriálu dělali,
takže jen připomenu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$path</font><font color="#007700">=</font><font color="#0000bb">SubStr</font><font color="#007700">(</font><font color="#0000bb">$SCRIPT_NAME</font><font color="#007700">, </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">StrRPos</font><font color="#007700">(</font><font color="#0000bb">$SCRIPT_NAME</font><font color="#007700">,</font><font color="#dd0000">"/"</font><font color="#007700">)).</font><font color="#dd0000">"/neco.php"</font><font color="#007700">;<br>
</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Location: http://"</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SERVER_NAME"</font><font color="#007700">].</font><font color="#dd0000">":"</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SERVER_PORT"</font><font color="#007700">].</font><font color="#0000bb">$path</font><font color="#007700">);&nbsp;&nbsp;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Podobným problémem může být použití hlavičky Expires, kterážto by
měla donutit prohlížeč nečíst (případně) odpověď z vyrovnávací paměti,
ale požádat o ni server v případě, že vyprší doba platnosti. Často se
nesprávně používá takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
header</font><font color="#007700">(</font><font color="#dd0000">"Expires:
0"</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Zase - podle <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">normy</a>
by za Expires mělo následovat datum, ne nula. A to ještě ne datum
napsané lecjak, ale podle <a href="http://www.faqs.org/rfcs/rfc822.html">specifikace</a>. Sestavit
takové datum pomocí PHP samozřejmě NENÍ problém, takže není důvod proč
nevyhovět normě a nenapsat něco jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$header</font><font color="#007700">=</font><font color="#dd0000">"Expires:
"</font><font color="#007700">.</font><font color="#0000bb">GMDate</font><font color="#007700">(</font><font color="#dd0000">"D, d M Y H:i:s \G\M\T"</font><font color="#007700">);<br>
</font><font color="#0000bb">Header </font><font color="#007700">(</font><font color="#0000bb">$header</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Takhle bychom mohli pokračovat. Tyto dvě chyby však jsou zdaleka
nejčastější, kterých se programátoři PHP při generování hlaviček
dopouštějí. Pokud si nejste jisti, jak má nějaká hlavička vypadat,
podívejte se do specifikace.<br>
</p>
<a name="000234"></a><h2>Tělo dokumentu</h2>
<p>Při práci na složitějších webech může být až neuvěřitelně složité
zachovat správné pořadí tagů
&lt;HTML&gt;&lt;HEAD&gt;...&lt;/HEAD&gt;&lt;BODY&gt;...&lt;/BODY&gt;&lt;/HTML&gt;.
To proto, že&nbsp; výstup do prohlížeče může pocházet z několika
různých skriptů a že občas potřebujeme odeslat nějakou tu hlavičku
předtím, než pošleme prohlížeči cokoliv jiného.&nbsp; "Nejlepší" řešení
tohoto problému asi neexistuje, ale mohu Vám ukázat některá "správná"
řešení. Jedno spočívá v nějaké logické organizaci skriptů a používání
include, resp. require ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"&lt;HTML&gt;"</font><font color="#007700">;<br>
require </font><font color="#dd0000">"./hlavicka.php"</font><font color="#007700">;<br>
require </font><font color="#dd0000">"./telicko.php"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"&lt;/HTML&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Jiné dobré řešení spočívá v nasazení nějakého šablonovacího systému,
který bude formátování držet pevně ve své režii. Jeho výběr záleží
pochopitelně na Vás, můžete se porozhlédnout třeba <a href="http://sourceforge.net/projects/xtpl">tady</a>.<br>
</p>
<p>Poměrně častý problém v těle dokumentu (sám se toho s oblibou
dopouštím) je špatné uvádění odkazů. Co byste řekli na následující kód?</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$odkaz</font><font color="#007700">=</font><font color="#dd0000">"&lt;a
href=\"neco.php?id=1&amp;user=2\"&gt;Odkaz&lt;/a&gt;"</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$odkaz</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Je špatně! Ampresandy nemají v URL co dělat! A přitom by stačilo tak
málo. Přepsat kód do podoby:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
$odkaz</font><font color="#007700">=</font><font color="#dd0000">"&lt;a
href=\"neco.php?id=1&amp;amp;user=2\"&gt;Odkaz&lt;/a&gt;"</font><font color="#007700">;<br>
echo </font><font color="#0000bb">$odkaz</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<a name="000235"></a><h2>Znakové sady</h2>
<p>Ještě malou poznámku ke znakovým sadám: Znakovou sadu stránky byste
zcela určitě měli specifikovat v odpovídající hlavičce. Pokud je to jen
trochu možné (například, když se rozhodujete při tvorbě nového webu),
měli byste dát přednost UTF-8, protože je jakýmsi "nepsaným
standardem". Vím o čem mluvím. Tuto radu ocení zejména programátoři
pracující v systémech Windows i Linux; důsledné používání UTF Vám
ušetří hodně starostí při vývoji na více než jedné platformě. </p>
<p>Nejčastější důvod (a špatný) proč to nedělat je ten, že některé
editory zdrojového kódu zkrátka v UTF-8 ukládat neumějí. Jsem ale
přesvědčen, že je lepší zvyknout si na jiný editor, než neustále
bojovat s konverzemi mezi win CP 1250, ISO 8859-2 a unikódem.<br>
</p>
<p><span style="font-style: italic;">A ještě malá poznámka k seriálu -
většinu zde uvedených pravidel v příkladech nedodržuji. Je to schválně
- s cílem napsat co nekratší kód, který bude ilustrovat to, k čemu byl
napsán, a nic jiného. Pochopitelně, že v "ostrém" provozu by tato
filozofie byla odsouzeníhodná. Přesto (nebo možná právě proto?) jsem
rád, když na případné odchylky od norem poukazujete ve svých
komentářích pod články.</span></p>
<a name="000236"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (55) - Odesílání e-mailů</h2>
			<p class="perex">Pomocí PHP lze odesílat e-maily. I ve formátu HTML, i s přílohami. Jak? Podívejte se do dnešního dílu seriálu.
				<br>
			</p>
			<p>V několika následujících dílech našeho seriálu se podíváme na služby
a vlastnosti PHP, které s provozem internetu úzce souvisejí a které
lze&nbsp; jednoduše použít. Dnes se zaměříme na to, jak lze pomocí PHP
odesílat e-maily.</p>
<p>Existuje samozřejmě mnoho důvodů, proč byste mohli chtít e-mail z PHP
odeslat. Na webovém obchodě e-mailem potvrdíte objednávku, na komunitní
stránce e-mailem odešlete zapomenuté heslo, na stránce mobilného
operátora si necháte e-mailem poslat fakturu a tak dále. Takže, jak na
to?<span style="font-weight: bold;"></span></p>
<p> </p>
<p><span style="font-weight: bold;"></span></p>
<a name="000237"></a><h2>Funkce mail<br>
</h2>
<p>Nejjednodušším způsobem posílání e-mailů pomocí PHP je funkce <a href="http://cz.php.net/manual/cs/function.mail.php">mail()</a>. Ta
funguje tak, že převezme adrsáta, předmět e-mailu a jeho tělo, celé to
předá poštovnímu systému a ten to odešle. Mohlo by to vypadat
následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp; mail</font><font color="#007700">(</font><font color="#dd0000">"nekdo@server.cz"</font><font color="#007700">, </font><font color="#dd0000">"Velmi důležitý
předmět"</font><font color="#007700">, </font><font color="#dd0000">"Vážení
přátelé, ..."</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Někdy to však nemusí stačit. Funkce mail proto obsahuje nepovinný
čtvrtý parametr, který Vám umožní přidat jednu nebo více e-mailových
hlaviček. Abyste například specifikovali odesílatele, můžete použít
hlavičku From:. Hlaviček můžete použít i více najednou. Nicméně, čtverý
parametr funkce mail není pole; jednotlivé hlavičky by se měly oddělit
znakem nového řádku (\n). Hlaviček specifikuje poměrně známá <a href="http://www.freesoft.org/CIE/RFC/822/index.htm">norma RFC 822</a>
celou řadu, můžete jich použít kolik uznáte za vhodné.<br>
</p>
<p>Funkce mail () se spoléhá na místí poštovní systém. Neboli, na PC
nepřipojeném k síti samozřejmě nebude fungovat. Na PC s Windows
pravděpodobně nebude fungovat. (Pokud ano, dejte nám vědět v diskusi).
Na běžném linuxovém webhostingu pravděpodobně BUDE fungovat, neboť
takové stroje
buď zároveň slouží jako poštovní servery, nebo alespoň mají nastavené
použití nějakého "spřáteleného" poštovního serveru.<br>
</p>
<p>Z toho vyplývá, že minimálně při psaní kódu na nějaké lokální
stanici byste měli počítat s tím, že funkce může skončit chybou. Takže
asi budete chtít tuto chybu zpracovat (nebo potlačit). Více o tom byla
řeč v <a href="#000117">díle
o chybách</a>.<br>
</p>
<a name="000238"></a><h2>Mobilní telefony</h2>
<p>Uvedená funkce může rovněž docela dobře sloužit pro odesílání
textových zpráv SMS na mobilní telefony. Jak asi víte, není internetové
doručování SMS nic jiného než doručení zprávy na mobilní e-mailovou
adresu. Při tomto režimu však musíme myslet na to, že délka zprávy bývá
omezena na nějakých 120-160 znaků a že by zpráva neměla obsahovat
diakritiku. Co se týče délky zprávy, můžete jí rozdělit pomocí funkcí
PHP pro práci s řetězci a poslat zpráv několik. Pokud se jedná o
odstranění diakritiky z textu, má PHP krásnou funkci <a href="http://cz.php.net/manual/cs/function.strtr.php">StrTr</a>. Ta
nám
umožní sestavit konverzní tabulku pro nahrazení jednoho řetězce jiným a
mohlo by to vypadat takhle:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<br>
&nbsp;&nbsp;</font><font color="#007700">function </font><font color="#0000bb">BezDK</font><font color="#007700">(</font><font color="#0000bb">$text</font><font color="#007700">) <br>
&nbsp;&nbsp;{ <br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">StrTr</font><font color="#007700">(</font><font color="#0000bb">$text</font><font color="#007700">,</font><font color="#dd0000">"áčďěéëíľĺňóöřšťůúüýž"</font><font color="#007700">,</font><font color="#dd0000">"acdeeeillnoorstuuuyz"</font><font color="#007700">); <br>
&nbsp;&nbsp;} <br>
</font><font color="#0000bb">&nbsp; mail </font><font color="#007700">(</font><font color="#dd0000">"marie@operator.cz"</font><font color="#007700">, </font><font color="#dd0000">"Rande"</font><font color="#007700">, </font><font color="#0000bb">BezDK</font><font color="#007700">(</font><font color="#dd0000">"Ahoj Mary, těším se na tebe. Sejdeme se v devět!!!"</font><font color="#007700">));<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Jinak pro práci s textovkami platí to, co o mailech. Ještě pár tipů:<br>
</p>
<ul>
  <li>Snažte se posílat na mobilní telefony maily s co možná nejmením
počtem hlaviček. Většinou je stejně nebudou umět telefony zpracovat; v
horším případě je vypíší na display a nevejde se tam zpráva.</li>
  <li>Pamatujte, že doručení zprávy pomocí internetu může operátor
zpoplatňovat. A pamatujte, že uživatel proto může mít nastavené
filtrování a Vaši zprávu nepřijme.</li>
</ul>
<a name="000239"></a><h2>HTML maily a přílohy</h2>
<p>Osobně dávám přednost e-mailům ve formátu HTML než v prostém textu.
I když jsou větší, mohou obsahovat obrázky, formátování, odkazy, mohou
definovat znakovou sadu a dělat mnoho dalších věcí. Pomocí samotné
funkce mail však takovou zprávu nesestavíte. A už vůbec nesestavíte
mail s přílohou. Abyste mohli něco takového dělat, budete se muset
porozhlédnout po nějaké chytřejší knihovně pro práci s maily.<br>
</p>
<p>Konkrétní výběr je samozřejmě na Vás. Já s oblibou a úspěchem již
několik let používám <a href="http://phpmailer.sourceforge.net/">třídu
PHPMailer</a> dostupnou pod licencí LGPL. Po nainstalování Vám umožní
poslat e-maily až pohádkově jednoduchým způsobem včetně HTML, příloh,
vložených obrázků a mnoha dlaších věcí. Mohl bych o tom dlouho
vyprávět, ale myslím, že lépe poslouží příklad fragmentu kódu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;$mail </font><font color="#007700">= new </font><font color="#0000bb">PHPMailer</font><font color="#007700">();<br>
&nbsp;&nbsp;</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">IsMail</font><font color="#007700">(); <br>
</font></font></code><code><font color="#000000"><font color="#007700">&nbsp;
</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">IsHTML</font><font color="#007700">(</font><font color="#0000bb">true</font><font color="#007700">);&nbsp;&nbsp;&nbsp;&nbsp;
</font></font></code><br>
<code><font color="#000000"><font color="#007700">&nbsp;&nbsp;</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">CharSet&nbsp;&nbsp;</font><font color="#007700">= </font><font color="#dd0000">"utf-8"</font><font color="#007700">; <br>
&nbsp;&nbsp;</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">From&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">= </font><font color="#dd0000">"nekdo@nekde.cz"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">FromName </font><font color="#007700">= </font><font color="#dd0000">"Petr Zajíc"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">WordWrap </font><font color="#007700">= </font><font color="#0000bb">50</font><font color="#007700">;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp; </font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">AddStringAttachment </font><font color="#007700">(</font><font color="#0000bb">$data</font><font color="#007700">, </font><font color="#dd0000">"zakaznik.txt"</font><font color="#007700">, </font><font color="#dd0000">"base64"</font><font color="#007700">, </font><font color="#dd0000">"text/plain"</font><font color="#007700">);<br>
</font><font color="#007700">&nbsp; </font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">Subject&nbsp;&nbsp;</font><font color="#007700">=&nbsp;&nbsp;</font><font color="#dd0000">"Zapomenuté
heslo"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">Body&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">=&nbsp;&nbsp;</font><font color="#0000bb">$body</font><font color="#007700">; </font><font color="#ff8000">//<br>
&nbsp;&nbsp;</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">AltBody&nbsp;&nbsp;</font><font color="#007700">=&nbsp;&nbsp;</font><font color="#dd0000">"Byla
učiněna nová registrace"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">AddAddress</font><font color="#007700">(</font><font color="#0000bb">$prijemce</font><font color="#007700">,</font><font color="#0000bb">$prijemce</font><font color="#007700">); <br>
&nbsp;&nbsp;</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">AddReplyTo</font><font color="#007700">(</font><font color="#dd0000">"info@nekde.cz"</font><font color="#007700">);<br>
&nbsp;&nbsp;if(!</font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">Send</font><font color="#007700">())<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Nepodařilo
se odeslat vzkaz &lt;p&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"došlo k
chybě: " </font><font color="#007700">. </font><font color="#0000bb">$mail</font><font color="#007700">-&gt;</font><font color="#0000bb">ErrorInfo</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;exit;<br>
&nbsp;&nbsp;}<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>S podobně kvalitní konihovnou zvládnete prakticky jakoukoli práci
orientovanou na odesílání pošty. A, ano, takto vytvořené zprávy půjdou
bez problémů přečíst i v poštovních klientech typu Microsoft Outlook
nebo Microsoft Outlok Express. Pozor na výkon - sestavování dlouhých
zpráv může pořádně zatopit procesoru serveru a jejich odesílání zase
může snížit propustnost vaší linky do internetu.</p>
<a name="000240"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (56) - Tisk a PDF</h2>
			<p class="perex">Podívejme se, jak lze pomocí PHP realizovat tisk informací z webových stránek a jejich export do PDF!
				<br>
			</p>
			<p>
Jestliže používáte PHP pro tvorbu opravdu pokročilých aplikací,
dříve či později narazíte na problém tvorby nějakých solidních
tiskových
výstupů. Většinou totiž nestačí data prezentovat na webové stránce, ale
bývá potřeba zajistit, aby si je uživatel mohl vytisknout. Dnes si
ukážeme na několik způsobů, jak tento problém řešit.
</p>

<p>
Dejme tomu, že budeme potřebovat vytisknout seznam všech pražských
PSČ (narážím na tento poněkud nereálný příklad proto, že máme k
dispozici databázi s PSČ). Ukažme si, jak na to s pomocí PHP můžeme jít
dvěma
různými způsoby.<br>
</p>

<a name="000241"></a><h2>HTML stránka optimalizovaná pro tisk</h2>

<p>
Tuto možnost nabízí mnoho webů. Není to nic magického; informace se
postě zformátují tak, aby se daly snadno vytisnkout a zobrazí se. Při
tvorbě stránky pro tištění byste měli mít na paměti tyto zásady:
</p>

<ul>
  <li>Co nejméně druhů písma - třeba i jen jeden</li>
  <li>Co nejméně grafiky - nejlépe žádná, ještě tak nějaké to
jednoduché logo</li>
  <li>Co nejméně barev - měla by stačit černá a bílá.</li>
</ul>

<p>Kdybychom uvedené zásady použili pro náš příklad, mohli bychom
napsat něco jako:
</p>

<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from psc where
obec like '%Praha%'"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TABLE border=\"1\"
style=\"border-collapse: collapse;\"&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"obec"</font><font color="#007700">].</font><font color="#dd0000">"&lt;/TD&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TD&gt;"</font><font color="#007700">.</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">].</font><font color="#dd0000">"&lt;/TD&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/TR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;endwhile;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/TABLE&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code>
</div>
<!-- Zaza PHP kód END -->


<p>
To s sebou přináší pochopitelně mnoho problémů. Především, musíme se
spoléhat na tiskové schopnosti našeho prohlížeče, a ty nejsou vždy
dostačující. A také nejsou ve všech prohlížečích srovnatelné. Je třeba
dosti velký problém nastavit okraje stránky tak, aby sestava vypadala
ucházejícím způsobem (i když se spokojíme s testováním jen na několika
nejběžnějších prohlížečích). Je jasné, že pro kvalitní výstupy se
budeme muset
porozhlédnout po něčem jiném.<br>
</p>

<a name="000242"></a><h2>PHP a PDF</h2>

<p>
Naprosto ideální je pro tiskové výstupy z PHP použít legendární
formát PDF. U PDF
totiž můžete lehce nastavit takové "drobnosti" jako písmo, znakovou
sadu, orientaci
stránky a její velikost, okraje a tak dále. Navíc máte jistotu, že
sestava bude vypadat na všech systémech stejně, a to je k nezaplacení.
Poměrně propracovaný projekt, zabývající se přímou tvorbou souborů PDF
pomocí PHP je <a href="http://www.fpdf.org/">FPDF</a>. <br>
</p>

<p>
Pokud byste chtěli knihovnu FPDF ve svých skriptech použít, asi Vám
nezbude nic jiného, než si trochu projít dokumentaci. Naznačím ale, jak
by se výše
uvedený příklad převedl do situace, v níž budeme výstup exportovat do
PDF. Vložený soubor fpdf.php obsahuje definici třídy, sloužící pro
tvorbu pdf.<br>
</p>

<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">require(</font><font color="#dd0000">'fpdf.php'</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$pdf</font><font color="#007700">=new </font><font color="#0000bb">FPDF</font><font color="#007700">();<br>
&nbsp;&nbsp;</font><font color="#0000bb">$pdf</font><font color="#007700">-&gt;</font><font color="#0000bb">AddFont</font><font color="#007700">(</font><font color="#dd0000">'Arial'</font><font color="#007700">,</font><font color="#dd0000">''</font><font color="#007700">,</font><font color="#dd0000">'arial.php'</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$pdf</font><font color="#007700">-&gt;</font><font color="#0000bb">AddPage</font><font color="#007700">();<br>
&nbsp;&nbsp;</font><font color="#0000bb">$pdf</font><font color="#007700">-&gt;</font><font color="#0000bb">SetFont</font><font color="#007700">(</font><font color="#dd0000">'Arial'</font><font color="#007700">,</font><font color="#dd0000">''</font><font color="#007700">);<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from psc where
obec like '%Praha%'"</font><font color="#007700">);<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$pdf</font><font color="#007700">-&gt;</font><font color="#0000bb">Cell</font><font color="#007700">(</font><font color="#0000bb">120</font><font color="#007700">,</font><font color="#0000bb">8</font><font color="#007700">, </font><font color="#0000bb">iconv</font><font color="#007700">(</font><font color="#dd0000">"UTF-8"</font><font color="#007700">, </font><font color="#dd0000">"ISO-8859-2"</font><font color="#007700">, </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"obec"</font><font color="#007700">]),</font><font color="#0000bb">1</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$pdf</font><font color="#007700">-&gt;</font><font color="#0000bb">Cell</font><font color="#007700">(</font><font color="#0000bb">20</font><font color="#007700">,</font><font color="#0000bb">8</font><font color="#007700">, </font><font color="#0000bb">iconv</font><font color="#007700">(</font><font color="#dd0000">"UTF-8"</font><font color="#007700">, </font><font color="#dd0000">"ISO-8859-2"</font><font color="#007700">, </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">]),</font><font color="#0000bb">1</font><font color="#007700">,</font><font color="#0000bb">1</font><font color="#007700">,</font><font color="#dd0000">'R'</font><font color="#007700">);<br>
&nbsp;&nbsp;endwhile;<br>
<br>
&nbsp;&nbsp;</font><font color="#0000bb">$pdf</font><font color="#007700">-&gt;</font><font color="#0000bb">Output</font><font color="#007700">();<br>
</font><font color="#0000bb">?&gt;</font>
</font></code>
</div>
<!-- Zaza PHP kód END -->


<p>
Vypadá to jednoduše a skutečně to jednoduché je. Klíčovou funkcí je
funkce Cell, popaná podrobně <a href="http://www.fpdf.org/en/doc/cell.htm">v manuálu</a>. Její funkce
je zjednodušeně řečeno taková, že umístí text na předem daný "čtverec"
ve výsledném dokumentu PDF. Funkce AddFont vloží písmo do PDF
dokumentu, takže máme jistotu, že na všech systémech se dokument objeví
stejně.<br>
</p>

<p>
Pokud budete chtít mít v PDF správně češtinu (jako že asi chtít
budete), může se Vám celý export změnit v peklo na zemi. Následující
postřehy by Vás měly ušetřit nejhoršího:<br>
</p>

<ol>
  <li>Je potřeba použít české fonty. Jejich tvorbu a vložení do
výsledného PDF souboru popisuje <a href="http://www.fpdf.org/en/tutorial/tuto7.htm">manuál k FPDF</a>.
Vřele doporučuji nejprve to celé přečíst, pak pochopit a nakonec udělat
(ne obráceně ;-)))</li>
  <li>FPDF nepodporuje UTF-8. Z toho vyplývá, že české fonty musejí být
v ISO-8859-2 (nebo v cp 1250, ale proč???). Existuje sice <a href="http://www.acko.net/node/56">klon projektu FPDF</a>, který by
měl toto omezení odstraňovat, ale nefungoval mi. <br>
  </li>
  <li>Jestliže použijete znakovou sadu ISO-8859-2, musíte vkládat
řetězce v ISO-8859-2!!! Jelikož máme databázi PSČ uloženou v UTF-8,
příklad výše používá <a href="http://cz.php.net/manual/cs/function.iconv.php">funkci iconv</a>
k zajištění správného překódování.</li>
</ol>

<p>
Knihovna FPDF toho umí samozřejmě víc. Text můžete zarovnávat, sázet
ve sloupcích, otáčet a tak dále. Na stránce projektu je rovněž mnoho
příkladů. Domnívám se, že tento styl uvažování (PHP-&gt;PDF) má ve
světě otevřených formátů svoji budoucnost a že tiskových exportů tohoto
typu bude přibývat. Takže, vzhůru do studia...
</p>
<a name="000243"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (57) - XML</h2>
			<p class="perex">XML se stalo módou současných systémů. Podívejme se, jak na něj jít pomocí PHP.
				<br>
			</p>
			<p>XML je fenoménem posledních několika let. Pro ty z vás, kdo by snad
nevěděl o co
se jedná: XML označuje způsob velmi pružného ukládání dat pomocí
souborů obsahujících značky. Je to trochu podobné jako HTML, které
rovněž obsahuje data a
značky (tagy), ale v trochu jiném slova smyslu. Podobnost mezi <a href="http://www.w3.org/MarkUp/">HTML</a> (Hypertext Markup Language
česky něco jako "značkový jazyk pro práci s hypertextem") a <a href="http://www.w3.org/XML/">XML</a> (Extensible Markup Language,
česky něco jako"rozšiřitelný jazyk se značkami") není čistě náhodná,
oba jazyky mají stejného rodiče. Je jím SGML (Standard Generalized
Markup Language, "standardní zobecnění jazyk se značkami").<br>
</p>
<p>XML nám umožňuje vytvářet sktrukturované dokumenty. "Sktrukturované"
znamená, že budou obsahovat "značky" a "znaky". Značky dávají dokumentu
XML strukturu, kdežto znaky jim dávají obsah. XML dokumenty mohou být
značně rozsáhlé, ale přesto (a to je asi hlavní výhoda) bývají snadno
čitelné jak lidem, tak i počítačům. Zkrátíme úvod tím, že si
předvedeme, jak takový XML dokument může vypadat:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?xml
version</font><font color="#007700">=</font><font color="#dd0000">"1.0"
</font><font color="#0000bb">encoding</font><font color="#007700">=</font><font color="#dd0000">"UTF-8"</font><font color="#0000bb">?&gt;<br>
</font>&lt;FINANCE&gt;<br>
&nbsp;&nbsp;&lt;PRIJMY&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;PRIJEM id="1"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;NAZEV&gt;Plat&lt;/NAZEV&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;CASTKA&gt;12000&lt;/CASTKA&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/PRIJEM&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;PRIJEM id="2"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;NAZEV&gt;Články na
Linuxsoft&lt;/NAZEV&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;CASTKA&gt;3000&lt;/CASTKA&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/PRIJEM&gt;<br>
&nbsp;&nbsp;&lt;/PRIJMY&gt;<br>
&nbsp;&nbsp;&lt;VYDAJE&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;VYDAJ id="1"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;NAZEV&gt;Byt&lt;/NAZEV&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;CASTKA&gt;4500&lt;/CASTKA&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/VYDAJ&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;VYDAJ id="2"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;NAZEV&gt;Jídlo&lt;/NAZEV&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;CASTKA&gt;2500&lt;/CASTKA&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/VYDAJ&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;VYDAJ id="3"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;NAZEV&gt;Koníčky&lt;/NAZEV&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;CASTKA&gt;1500&lt;/CASTKA&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/VYDAJ&gt;<br>
&nbsp;&nbsp;&lt;/VYDAJE&gt;<br>
&lt;/FINANCE&gt;</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>To by mělo odstranit všechny nejasnosti kolem výhod XML. Vidíte, že
formát je to opravdu pohodový. XML se skládá z několika oddílů neboli
uzlů. Popis využití XML a technik jeho
zpracování by vydal na nejednu knihu a skutečně na toto téma bylo mnoho
knih vydáno. My si v našem seriálu ukážeme
pouze dvě základní věci: Nejprve jak data z XML pomocí PHP číst
a potom jak elegantně data do XML pomocí PHP zapisovat.<br>
</p>
<p style="font-style: italic;">Pozn.: Celému problému se šířeji věnuje
například náš <a href="http://www.linuxsoft.cz/article_list.php?id_kategory=182">seriál
na Linuxsoftu</a>. Věc je to technicky zaměřená, poměrně erudovaně
napsaná a podstatně rozsáhlejší než našich několik dílů, které se budou
XML věnovat. <a href="http://www.linuxsoft.cz/user_page.php?user_id=450">Aleš Hakl</a>
se však soustřeďuje převážně na práci v Javě, okrajově v FreePascalu a
Pythonu, takže se vzájemně nebudeme křížit.</p>
<a name="000244"></a><h2>Expat a PHP<br>
</h2>
<p>Asi tušíte, že když má XML nějakou strukturu, že nebude nutné k němu
přistupovat bajt po bajtu a luštit jej pomocí funkcí sestavených v potu
vlastní programátorské tváře (ačkoliv možné to samozřejmě je). Existují
již hotové knihovny pro práci s XML. PHP například používá <a href="http://www.jclark.com/xml/expat.html">Expat</a>. Expat patří do
velké skupiny software, kterou nazýváme <span style="font-weight: bold;">XML parsery</span>. "Parser" si můžete
představit jako program, který rozumí XML a umí k němu strukturovaně
přistupovat. Parser rovněž ví, co má udělat, když v XML dokumentu
narazí na určitou jeho část (třeba, když narazí na značku).<br>
</p>
<p>PHP, pokud to výslovně nezakážete, má po instalaci podporu XML
zapnutou. Takže můžeme hned začít využívat funkcí pro práci s XML.
Nejdřív vám vysvětlím, co všechno musí skript zpracovávající soubor XML
dělat:<br>
</p>
<ol>
  <li>Musí vytvořit instanci parseru.</li>
  <li>Musí zaregistrovat obslužné funkce. Tento hrozný výraz znamená
prostě to, že se definují funkce v PHP, které stanoví, co s danou věcí
(značky, data) dělat poté, co se na ni v dokumentu narazí. A parseru se
řekne, že má tyto funkce zavolat.<br>
  </li>
  <li>Konečně, parseru se předá vlastní xml soubor a ten jej zpracuje a
skončí.</li>
</ol>
<p style="font-style: italic;">Pozn.: Celé je to trochu zjednodušené.
Například jsme nehovořili o zpracování chyb. Ale pro představu by to
mělo stačit.<br>
</p>
<p>Tak, a teď ukázka. Mějme soubor finance.xml (viz výše) a ukažme si,
jak jej zpracovat naším v PHP vytvořeným parserem.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;$nas_soubor</font><font color="#007700">=</font><font color="#dd0000">"./finance.xml"</font><font color="#007700">;<br>
<br>
&nbsp;&nbsp;</font><font color="#ff8000">//co se má stát, když narazíme
na počáteční a koncovou značku<br>
&nbsp;&nbsp;</font><font color="#007700">function </font><font color="#0000bb">PocatecniZnacka </font><font color="#007700">(</font><font color="#0000bb">$parser</font><font color="#007700">, </font><font color="#0000bb">$nazev</font><font color="#007700">, </font><font color="#0000bb">$atributy</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Narazil
jsem při čtení na značku $nazev s atributy:"</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#0000bb">print_r</font><font color="#007700">(</font><font color="#0000bb">$atributy</font><font color="#007700">).</font><font color="#dd0000">"&lt;BR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;function </font><font color="#0000bb">KoncovaZnacka </font><font color="#007700">(</font><font color="#0000bb">$parser</font><font color="#007700">, </font><font color="#0000bb">$nazev</font><font color="#007700">) {}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#ff8000">// fáze 1) instance parseru<br>
&nbsp;&nbsp;</font><font color="#0000bb">$nas_parser</font><font color="#007700">=</font><font color="#0000bb">xml_parser_create</font><font color="#007700">();<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#ff8000">// fáze 2) řekneme parseru, co
má udělat když se dostane k <br>
&nbsp;&nbsp;// počáteční značce<br>
&nbsp;&nbsp;</font><font color="#0000bb">xml_set_element_handler </font><font color="#007700">(</font><font color="#0000bb">$nas_parser</font><font color="#007700">, </font><font color="#dd0000">"PocatecniZnacka"</font><font color="#007700">, </font><font color="#dd0000">"KoncovaZnacka"</font><font color="#007700">);<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#ff8000">// fáze 3) vlastní čtení
souboru, práce s ním a ukončení parseru<br>
&nbsp;&nbsp;</font><font color="#007700">if (!(</font><font color="#0000bb">$obsahsouboru </font><font color="#007700">= </font><font color="#0000bb">fopen</font><font color="#007700">(</font><font color="#0000bb">$nas_soubor</font><font color="#007700">, </font><font color="#dd0000">"r"</font><font color="#007700">))) <br>
&nbsp;&nbsp;&nbsp;&nbsp;die(</font><font color="#dd0000">"Nemohu
otevřít XML pro čtení."</font><font color="#007700">);<br>
<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$data </font><font color="#007700">= </font><font color="#0000bb">fread</font><font color="#007700">(</font><font color="#0000bb">$obsahsouboru</font><font color="#007700">, </font><font color="#0000bb">5</font><font color="#007700">)) <br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">xml_parse</font><font color="#007700">(</font><font color="#0000bb">$nas_parser</font><font color="#007700">, </font><font color="#0000bb">$data</font><font color="#007700">, </font><font color="#0000bb">feof</font><font color="#007700">(</font><font color="#0000bb">$obsahsouboru</font><font color="#007700">));<br>
<br>
&nbsp;&nbsp;</font><font color="#0000bb">xml_parser_free</font><font color="#007700">(</font><font color="#0000bb">$nas_parser</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>Takovýhle parser je nám pochopitelně celkem na nic, ale dá se na něm
alespoň pěkně zjistit, jak to celé funguje. Všimněte si funkce
xml_set_element_handler. Ta registruje funkci, která bude provedena
pokud se při procházení dokumentu XML narazí na značky. V našem případě
to je vypsání do prohlížeče, může to však být libovolná akce, kterou je
PHP schopno provést. Rovněž si všimněte, že pro obsluhu koncové značky
jsme zaregistrovali funkci, která nedělá vůbec nic. To je v pořádku,
funcke se nám může hodit později, takže byste si měli zvyknout to tak
dělat.<br>
</p>
<p>Příště si ukážeme, jak sestavit poněkud chytřejší parser. Bude to
aplikace, která nám řekne, koli si ještě na základě našich příjmů a
výdajů můžeme dovolit utratit ;-) když se všechny příjmy a výdaje
sečtou. Jinými slovy uvidíme, že parser umí (pochopitelně) pracovat
nejen se značkami, ale rovněž s daty.
</p>

<a name="000245"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (58) - XML lépe a radostněji</h2>
			<p class="perex">Dnes si ukážeme na efetivnější metody zpracování XML pomocí PHP.
				<br>
			</p>
			<p>Minule jsme předložili něco teorie kolem XML a ukázali jsme si, jak
sestavit nejjednodušší parser. Dnes si ukážeme, jak pomocí PHP sestavit
parser, který bude maličko užitečnější než ten první; bude totiž
skutečně něco reálného dělat. Bude to výpočet bilance z našeho
ukázkového souboru <a href="./examples/finance.xml">finance.xml</a>.</p>
<a name="000246"></a><h2>Zpracování dat</h2>
<p>Minule jsme si předvedli, že existuje funkce
xml_set_element_handler, která definuje, co se má stát když při
parsování XML dokumentu narazíme na značky. Existuje pochopitelně
funkce <a href="http://cz.php.net/manual/cs/function.xml-set-character-data-handler.php">xml_set_character_data_handler</a>,
která se zase naopak stará o
data. Rozšiřme tedy minulý příklad do podoby, v níž bude tato funkce
obsažena:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// úvod ...<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#007700">function </font><font color="#0000bb">data </font><font color="#007700">(</font><font color="#0000bb">$parser</font><font color="#007700">, </font><font color="#0000bb">$data</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;global </font><font color="#0000bb">$znacka</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;global </font><font color="#0000bb">$bilance</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;global </font><font color="#0000bb">$jeprijem</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$znacka</font><font color="#007700">==</font><font color="#dd0000">"CASTKA" </font><font color="#007700">and </font><font color="#0000bb">$jeprijem</font><font color="#007700">) </font><font color="#0000bb">$bilance</font><font color="#007700">+=</font><font color="#0000bb">$data</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$znacka</font><font color="#007700">==</font><font color="#dd0000">"CASTKA" </font><font color="#007700">and !</font><font color="#0000bb">$jeprijem</font><font color="#007700">) </font><font color="#0000bb">$bilance</font><font color="#007700">-=</font><font color="#0000bb">$data</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$nas_parser</font><font color="#007700">=</font><font color="#0000bb">xml_parser_create</font><font color="#007700">();&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#0000bb">xml_set_element_handler </font><font color="#007700">(</font><font color="#0000bb">$nas_parser</font><font color="#007700">, </font><font color="#dd0000">"PocatecniZnacka"</font><font color="#007700">, </font><font color="#dd0000">"KoncovaZnacka"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">xml_set_character_data_handler</font><font color="#007700">(</font><font color="#0000bb">$nas_parser</font><font color="#007700">, </font><font color="#dd0000">"data"</font><font color="#007700">);<br>
<br>
&nbsp;&nbsp;</font><font color="#ff8000">// atd. <br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#007700">echo </font><font color="#0000bb">$bilance</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/58_print.html">Ukázat celý skript</a>
</p>
<p>To je (jak můžete vidět ze zobrazení celého skriptu) poměrně názorné
řešení. Nejprve si při procházení značkami "přepneme semafor" $jeprijem
na hodnotu TRUE nebo FALSE pokaždé, když narazíme při čtení značky na
hodnotu PRIJEM nebo VYDAJ. Jestliže potom v datech (obsažených mezi
značkami CASTKA, jiné nás nezajímají) narazíme na číslo, přičteme jej
nebo odečteme, a to podle toho, zda se jedná o příjem nebo výdaj.<br>
</p>
<p>Tento skript je sice poměrně názorný, je však nešikovně napsaný.
Protože, jak jsme již uvedli v <a href="#000060">díle o
funkcích</a>, nejsou automaticky globální proměnné k dispozici v těle
fukcí, a to tak dlouho, dokud jim to nenařídíme pomocí klíčového slova
global. Takže je na to potřeba myslet. Elegantním řešením by bylo
přepsat celou záležitost s použitím třídy, protože proměnné třídy jsou
v čleských funcích k dispozici. Mohlo by to vypadat třeba takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">// nejdřív definice třídy<br>
&nbsp;&nbsp;</font><font color="#007700">class </font><font color="#0000bb">bilance<br>
&nbsp;&nbsp;</font><font color="#007700">{<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$soubor</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$bilance</font><font color="#007700">=</font><font color="#0000bb">0</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$priv_jeprijem</font><font color="#007700">=</font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$priv_znacka</font><font color="#007700">=</font><font color="#dd0000">""</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var </font><font color="#0000bb">$priv_parser</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000bb">PocatecniZnacka
</font><font color="#007700">(</font><font color="#0000bb">$parser</font><font color="#007700">, </font><font color="#0000bb">$nazev</font><font color="#007700">, </font><font color="#0000bb">$atributy</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">// atd...<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000bb">KoncovaZnacka
</font><font color="#007700">(</font><font color="#0000bb">$parser</font><font color="#007700">, </font><font color="#0000bb">$nazev</font><font color="#007700">) {}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000bb">data </font><font color="#007700">(</font><font color="#0000bb">$parser</font><font color="#007700">, </font><font color="#0000bb">$data</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">// atd...<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;function </font><font color="#0000bb">parse </font><font color="#007700">()<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">priv_parser</font><font color="#007700">=</font><font color="#0000bb">xml_parser_create</font><font color="#007700">();<br>
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font><font style="font-weight: bold;" color="#0000bb">xml_set_object</font><font style="font-weight: bold;" color="#007700">(</font><font style="font-weight: bold;" color="#0000bb">$this</font><font style="font-weight: bold;" color="#007700">-&gt;</font><font style="font-weight: bold;" color="#0000bb">priv_parser</font><font style="font-weight: bold;" color="#007700">, </font><font style="font-weight: bold;" color="#0000bb">$this</font><font color="#007700"><span style="font-weight: bold;">);</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">xml_set_element_handler
</font><font color="#007700">(</font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">priv_parser</font><font color="#007700">, </font><font color="#dd0000">"PocatecniZnacka"</font><font color="#007700">, </font><font color="#dd0000">"KoncovaZnacka"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">xml_set_character_data_handler</font><font color="#007700">(</font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">priv_parser</font><font color="#007700">, </font><font color="#dd0000">"data"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(</font><font color="#0000bb">$obsahsouboru
</font><font color="#007700">= </font><font color="#0000bb">fopen</font><font color="#007700">(</font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">soubor</font><font color="#007700">, </font><font color="#dd0000">"r"</font><font color="#007700">))) die(</font><font color="#dd0000">"Nemohu otevřít
XML pro čtení."</font><font color="#007700">);&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (</font><font color="#0000bb">$data
</font><font color="#007700">= </font><font color="#0000bb">fread</font><font color="#007700">(</font><font color="#0000bb">$obsahsouboru</font><font color="#007700">, </font><font color="#0000bb">1024</font><font color="#007700">)) </font><font color="#0000bb">xml_parse</font><font color="#007700">(</font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">priv_parser</font><font color="#007700">, </font><font color="#0000bb">$data</font><font color="#007700">, </font><font color="#0000bb">feof</font><font color="#007700">(</font><font color="#0000bb">$obsahsouboru</font><font color="#007700">));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">xml_parser_free</font><font color="#007700">(</font><font color="#0000bb">$this</font><font color="#007700">-&gt;</font><font color="#0000bb">priv_parser</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#ff8000">// teď vlastní program<br>
&nbsp;&nbsp;</font><font color="#0000bb">$moje_bilance </font><font color="#007700">= new </font><font color="#0000bb">bilance</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$moje_bilance</font><font color="#007700">-&gt;</font><font color="#0000bb">soubor </font><font color="#007700">= </font><font color="#dd0000">"./finance.xml"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$moje_bilance</font><font color="#007700">-&gt;</font><font color="#0000bb">parse</font><font color="#007700">();<br>
&nbsp;&nbsp;echo </font><font color="#0000bb">$moje_bilance</font><font color="#007700">-&gt;</font><font color="#0000bb">bilance</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><a href="./examples/58_print2.html">Ukázat celý skript</a>
</p>
<p>Omlouvám se za poněkud delší ukázku, ale kratší to být nemohlo. Co
se s naším kódem stalo? Všechny ty otravné práce s parsováním jsme
zapouzdřili do třídy nazvané bilance. Takže, všimnete-li si závěru,
stačí zavést novou instanci této třídy, předat jí soubor ke zpracování,
spustit parser a nechat si zobrazit výsledek. V třídě samotné je
podstatný řádek s voláním funkce <a href="http://cz.php.net/manual/cs/function.xml-set-object.php">xml_set_object</a>
(v kódu výše jsem to zvýraznil), která umožní použít pro zpracování
členské funkce třídy namísto veřejných funkcí. Neboli, kdybyste řádek s
voláním xml_set_object zakomentovali, nenajde parser funkce
PocatecniZnacka, KoncovaZnacka a data, protože žádné takové veřejné
funkce ve skriptu neexistují (jsou to "jen" členské funkce dané třídy).<br>
</p>
<p>Použitím třídy jsme se samozřejmě rovněž vyhnuli nutnosti neustále
používat klíčové slovo global. Místo toho sice používáme konstrukci
this-&gt;proměnná k volání členských proměnných třídy, ale je to daleko
elegantnější. Kromě toho lze třídu podle potřeby rozšířit nebo napsat
dceřinné třídy.<br>
</p>58_
<p style="font-style: italic;">Pozn.: Trochu odbočím. Kdykoli se Vám
během programování bude zdát, že něco sice funguje, ale šlo by to
napsat přehledněji, nelitujte a přepište to. Příklad výše je toho
typickou ukázkou. Odměnou Vám bude nejen přehlednější kód, ale
(většinou) i kód rychlejší a skoro vždy to oceníte časem, až se k
danému programu budete vracet a budete se v něm muset vyznat.<br>
</p>
<p>Příště se zaměříme na problém tvorby XML dokumentů pomocí PHP.</p>
<a name="000247"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (59) - zapisujeme XML</h2>
			<p class="perex">Číst soubory XML už umíme. Ale jak je zapisovat? Ukažme si na několik způsobů.
				<br>
			</p>
			<p>
V předchozích dvou dílech seriálu jsme si ukázali, jak pomocí funkcí
parseru číst hotové dokumenty XML. To se samozřejmě hodí v případě, kdy
již máme nějaký ten XML soubor k dispozici. Co ale dělat v případě, kdy
naopak bude chtít někdo XML soubor po nás?
</p>

<p>
Taková situace není nereálná. Jelikož, jak jsme uvedli, slouží XML
převážně pro výměnu dat, může nějaký externí systém požadovat po naší
aplikaci data v XML. Projděme si tedy několik způsobů, jak takovou
úlohu splnit.
</p>

<a name="000248"></a><h2>Ruční způsob</h2>

<p>
S tímto způsobem jsme se již seznámili v díle o<a href="http://www.linuxsoft.cz/article.php?id_article=414"> exportu dat
z MySQL</a>. Jen připomenu, že se jednalo o přímý zápis dat a značky se
dopisovaly do výstupního souboru (nebo do výstupního proudu) ručně.
Tento způsob je pracný a zejména při vytváření složitěji
strukturovaných XML dokumentů můžeme snadno udělat chybu. Jádro kódu
pro export dat do XML vypadalo následovně:
</p>

<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">echo(</font><font color="#dd0000">"&lt;obce&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$row </font><font color="#007700">= </font><font color="#0000bb">mysql_fetch_assoc </font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)) <br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t&lt;obec&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t\t&lt;psc&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"\t\t\t"</font><font color="#007700">.</font><font color="#0000bb">$row</font><font color="#007700">[</font><font color="#dd0000">"psc"</font><font color="#007700">].</font><font color="#dd0000">"\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t\t&lt;/psc&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t\t&lt;nazev&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"\t\t\t"</font><font color="#007700">.</font><font color="#0000bb">$row</font><font color="#007700">[</font><font color="#dd0000">"obec"</font><font color="#007700">].</font><font color="#dd0000">"\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t\t&lt;/nazev&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo (</font><font color="#dd0000">"\t&lt;/obec&gt;\n"</font><font color="#007700">);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;echo(</font><font color="#dd0000">"&lt;/obce&gt;\n"</font><font color="#007700">); <br>
</font><font color="#0000bb">?&gt;</font>
</font></code>
</div>
<!-- Zaza PHP kód END -->

<p>
Ruční způsob nedoporučuji. Povede nejspíš ke zmatkům; nemluvě o
situaci, kdy budeme potřebovat změnit strukturu exportovaného
dokumentu. Daleko lepší bude poohlédnout se po nějakém elegantnějším
řešení. <br>
</p>

<a name="000249"></a><h2>Serializer</h2>

<p>
Jednou z mnoha možností je využít hotovou knihovnu <a href="http://pear.php.net/package/XML_Serializer">serializer</a>. Té
stačí
předat pole (nebo objekt) a seznam voleb, a vrátí hotový XML dokument.
Nejprve to předveďme:
</p>


<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">//data<br>
&nbsp;&nbsp;</font><font color="#007700">require(</font><font color="#dd0000">"Serializer.php"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#ff8000">// zde je include souboru s
konstantami<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek </font><font color="#007700">= </font><font color="#0000bb">mysql_query </font><font color="#007700">(</font><font color="#dd0000">"SELECT * FROM psc WHERE
psc=47001"</font><font color="#007700">);<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$row </font><font color="#007700">= </font><font color="#0000bb">mysql_fetch_array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">))<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$xml</font><font color="#007700">[] = array ( </font><font color="#dd0000">"nazev" </font><font color="#007700">=&gt; </font><font color="#0000bb">$row</font><font color="#007700">[</font><font color="#0000bb">0</font><font color="#007700">], </font><font color="#dd0000">"psc" </font><font color="#007700">=&gt; </font><font color="#0000bb">$row</font><font color="#007700">[</font><font color="#0000bb">1</font><font color="#007700">]);<br>
&nbsp;&nbsp;</font><font color="#ff8000">//serializace<br>
&nbsp;&nbsp;</font><font color="#0000bb">$options </font><font color="#007700">= array( </font><font color="#dd0000">"addDecl" </font><font color="#007700">=&gt; </font><font color="#0000bb">true</font><font color="#007700">,&nbsp;&nbsp;</font><font color="#dd0000">"defaultTagName"
</font><font color="#007700">=&gt; </font><font color="#dd0000">"obec"</font><font color="#007700">,<br>
&nbsp;&nbsp;</font><font color="#dd0000">"linebreak" </font><font color="#007700">=&gt; </font><font color="#dd0000">""</font><font color="#007700">,&nbsp;&nbsp;</font><font color="#dd0000">"encoding" </font><font color="#007700">=&gt; </font><font color="#dd0000">"UTF-8"</font><font color="#007700">,&nbsp;&nbsp;</font><font color="#dd0000">"rootName" </font><font color="#007700">=&gt; </font><font color="#dd0000">"obce"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$serializer </font><font color="#007700">= new </font><font color="#0000bb">XML_Serializer</font><font color="#007700">(</font><font color="#0000bb">$options</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$serializer</font><font color="#007700">-&gt;</font><font color="#0000bb">serialize</font><font color="#007700">(</font><font color="#0000bb">$xml</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#ff8000">// výstup<br>
&nbsp;&nbsp;</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Type: text/xml"</font><font color="#007700">);<br>
&nbsp;&nbsp;echo </font><font color="#0000bb">$serializer</font><font color="#007700">-&gt;</font><font color="#0000bb">getSerializedData</font><font color="#007700">();<br>
</font><font color="#0000bb">?&gt;</font>
</font></code>
</div>
<!-- Zaza PHP kód END -->



<p>
Poznamenejme rovnou, že tento způsob je daleko elegantnější než
ruční varianta. Rovněž stojí za zmínku, že v případě většiny exportů
(například, v případě exportu z jedné MySQL tabulky) bude vytvoření
pole poměrně triviální záležitost a tudíž celý kód nejenom dobře
poběží, ale bude rovněž hezky vypadat.<br>
</p>

<p style="font-style: italic;">Pozn.: To je vidět na příkladu výše.
Povšimněme si, že zatímco funkce mysql_fetch_array vkládá každý řádek
do pole, funkce array vkládá toto pole ... (ano!) zase do pole. $xml je
jednorozměrné pole tvořené prvky, z nichž každý je rovněž jednorozměrné
pole. Komu se z toho točí hlava, může nahlédnout do <a href="#000074">dílu seriálu
o polích</a>.<br>
</p>

<p style="font-style: italic;"></p>

<a name="000250"></a><h2>DOM</h2>

<p>
DOM, neboli Document Object Model je jiný mechanizmus pro čtení
(anebo zápis) XML dokumentů. Spočívá v tom, že se celý XML dokument
nejprve načte do paměti, tam se zanalyzuje a pak se k němu přistupuje
pomocí objektového modelu. To zní dobře. Podpora DOM je implementována
v mnoha programovacích jazycích, <a href="http://cz.php.net/manual/cs/ref.domxml.php">v PHP</a> však není
tak dobrá, jak by mohla být. Pokud znáte mechanismus fungování DOM z
jiných programovacích jazyků, pravděpodobně po něm sáhnete i v PHP.
Měli byste ale mít na paměti následující věci:<br>
</p>

<ul>
  <li>PHP musí být přeloženo s podporou DOM. Pokud nebude, nebude Vám
fungovat ani související kód</li>
  <li>Některé DOM funkce zastarávají. Jak se PHP vyvíjí, jeho
implementace DOM prochází rovněž bouřlivým vývojem (momentálně je
zastaralých 18(!) funkcí, což by mě rozhodně rozladilo, kdybych DOM v
PHP používal)</li>
  <li>Implementace DOM se LIŠÍ v PHP4 a PHP5. Takže, v "pětce" Vám
"čtyřkový" kód volající DOM může a nemusí fungovat.</li>
  <li>Pokud chcete ladit (nebo provozovat?) PHP na Windows, pamatujte
na to, že instalace a konfigurace DOM pro PHP může znamenat roční
kopírování knihoven do systémové složky. <br>
  </li>
</ul>

<a name="000251"></a><h2>Ostatní</h2>

<p>
Uvedené metody pochopitelně nejsou jediné způsoby, jak s pomocí PHP
vytvářet XML dokumenty. Pokud máte jiný osvědčený způsob, můžete se s
námi podlěit v diskusi. Každopádně, než se rozhodnete preferovat
některou z variant, měli byste vzít v úvahu takové věci, jako je
rychlost, čitelnost kódu, rozšiřitelnost a bezpečnost. Koneckonců,
výsledek záleží na Vás.
</p>
<a name="000252"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (60) - Rozsáhlejší projekty 1.</h2>
			<p class="perex">Umět PHP neznamená jen syntaxi. Pojďme se podívat, na co myslet při vývoji rozsáhlejších projektů.
				<br>
			</p>
			<p>V několika předchozích dílech našeho seriálu jsme si ukázali, jak
může PHP spolupracovat s takovými záležitostmi, jako je XML,
elektronická pošta či publikování pomocí PDF. Takto by se dalo
pokračovat popisem dalších možností, aplikací a protokolů, které PHP
podporue; nicméně byly by to věci již
poměrně specifické a pro většinu čtenářů obtížně stravitelné. My se teď
v seriálu vrhneme trochu jiným směrem - pokusíme se dát (zejména
začínajícím) programátorům několik rad k vývoji rozsáhlejších projektů.<br>
</p>
<p>Důvod je prostý - programátorem se člověk nestane tím, že se naučí
syntaxi některého jazyka (třeba PHP). Programátorem se člověk stává,
když si osvojí určité zvyky. Většinou zvyky, které mu práci buď ulehčí,
nebo systematizují. Zamysleme se tedy na tím, co je potřeba při vývoji <span style="font-style: italic;">rozsáhlejších projektů</span> v PHP.
Budeme tomu věnovat několik dílů našeho seriálu; nejprve teoretických a
následně se pokusíme jeden takový "větší" projekt napsat a odladit.<br>
</p>
<a name="000253"></a><h2>Rozsáhlejší projekty</h2>
<p>Zatím jsme v tomto seriálu uváděli příklady co možná nejkratší.
Třeba jedna funkce, jedna třída, jeden skript. V reálném světě to tak
pochopitelně není; většina webů se skládá z několika až několika
desítek vzájemně provázaných skriptů. Ty musí být schopny fungovat jako
jeden celek. Což znamená mnohem víc, než prostě místo jednoho skriptu
jich napsat několik. Znamená to důsledné plánování, většinou projití
několika slepých cest, prošvihnutí pár termínů a několik bezesných
nocí. Většině z toho lze předejít a tom si právě něco řekneme.<br>
</p>
<p style="font-style: italic;">Pozn.: Osobně mě velmi pobuřuje přístup,
používaný v mnoha knihách (bohužel i v některých knihách o PHP). Autor
nejprve uvede několikastránkový skript nebo skripty, a pak je uvede
znova a prokládá je komentáři, co že ten který kousek kódu vlastně
dělá. Ale nikde už není uvedeno, co musel autor udělat, aby daný kód
sestavil. Na jaké problémy narazil? Fungovalo to hned? Musel něco
přepisovat? Přeskupovat? Vynechat? Proč to napsal právě takhle, když
jiný způsob se nabízí hned na první pohled...???<br>
</p>
<a name="000254"></a><h2>Analýza</h2>
<p>Prakticky každý trochu složitější projekt je potřeba nejprve
zanalyzovat. Nestačí vědět, že zákazník potřebuje mít "databázi" a
"nějaké vyhledávání". Bude databáze rozsáhlá? Bude se k ní připojovat
pár lidí, nebo pár tisíc lidí najednou? Bude se z ní převážně číst,
nebo se do ní bude převážně zapisovat? Má být výstup čitelný na
palmtopu (mobilu...)? Bude aplikce ve více jazykových verzích? Otázek
je mnoho. Zlatá rada zní: Pokud pracujete pro někoho, konzultujte!
Cílem Vaší analýzy by měl být (písemný!) cílový koncept. Kdybyste
například měli dělat portál podobný Linuxsoftu, mohla by část cílového
konceptu vypadat následovně:</p>
<ul>
  <li>Portál bude obsahovat databázi Linuxového software s možností
zadávání položek uživateli a schvalování administrátory</li>
  <li>Uživatelé budou mít své profily. V profilu budou moci být
obsaženy informační údaje...</li>
  <li>Server bude obsahovat rovněž články. I ty se budou před vydáním
schvalovat administrátory.</li>
  <li>Atd...</li>
</ul>
<p>Je to důležité! Viděl jsem již příliš mnoho projektů, které
zkrachovaly v momentě, kdy zákazník řekl: "Ale já myslel, že to bude
umět to či ono!" S kvalitní analýzou a písemným cílovým konceptem se
Vám to nemůže stát.<br>
</p>
<p style="font-style: italic;">Pozn.: Nebo cílový koncept doplníte... a
máte v ruce argument k navýšení ceny!</p>
<a name="000255"></a><h2>Nástroje a postupy</h2>
<p>To, že budete Vaší vysněnou aplikaci psát v PHP neznamená, že
nebudete potřebovat další nástroje. Asi druhou nejpalčivější potřebou
bude většinou volba databáze. O tom jsme již v našem seriálu <a href="#000144">mluvili</a>
a (jak jsem předpokládal) strhla se kolem toho rovněž diskuse. Obecně
řečeno - pokud bude Váš projekt vyžadovat databázi, měli byste si ji
vybrat již v této fázi "boje". Přechod z jedné databáze na jinou v
polovině vývoje znamená většinou smrt projektu.</p>
<p style="font-style: italic;">Pozn.: Výjimkou jsou samozřejmě
aplikace, které jsou od počátku psány tak, aby uměly pracovat s více
databázemi.<br>
</p>
<p>Je rovněž možné, že budete potřebovat nějaké PHP moduly nebo externí
software. Může se to týkat systému správy chyb, modulů pro export a
import dat a podobně. Měli byste pokud možno tyto potřeby odhadnout a
vše potřebné si připravit a nachystat, aby Vás to později během práce
nezdržovalo.<br>
</p>
<p>Organizačně vzato bývá ještě praktické dohodnout časový harmonogram
a nějaký způsob, jak můžete zákazníka informovat o postutpu práce. V
PHP to většinou nebývá problém; dělá se to tak, že existuje zkušební
umístění, na němž aplikace běží a k němuž má zákazník přístup. Tak může
sledovat, jak Vám práce "roste pod rukama". S tím souvisí i další bod -
pro úspěch je nutné mít kvalitní zázemí na straně serveru.<br>
</p>
<p> </p>
<a name="000256"></a><h2>Hosting</h2>
<p>Většina zákazníků má již nějakou internetovou prezentaci a tudíž
nějaký hosting. Bude však tento hosting vyhovovat potřebám Vaší
aplikace? To není jednoduchá otázka. Většinou nestačí, že hosting
podporuje běh skriptů PHP. Abyste si udělali základní představu o
serveru a prostředí, může použít funkci <a href="http://cz.php.net/manual/cs/function.phpinfo.php">phpinfo()</a>.
Je to velmi jednoduché a poskytne Vám to základní představu o systému a
použitém vybavení:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;phpinfo</font><font color="#007700">();<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->

<p>V tabulce uveďme nejdůležitější informace, které Vám funkce phpinfo
vypíše a které byste rozhodně měli zvážit:<br>
</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; font-weight: bold;">Údaj<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Důvod<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">PHP Version<br>
      </td>
      <td style="vertical-align: top;">Verze PHP by neměla být příliš
zastaralá, ani by to neměla být nejnovější beta. Obojí by znamenalo, že
administrátor je trochu mimo.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">System<br>
      </td>
      <td style="vertical-align: top;">Základní problém je: Windows
versus Linux. Ano, aplikace Vám může běžet na PHP + Windows, ale...<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Configure command<br>
      </td>
      <td style="vertical-align: top;">Popisuje s jakými volbami bylo
PHP konfigurováno. Užitečné, pokud potřebujete například podporu XML a
podobně.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Server API<br>
      </td>
      <td style="vertical-align: top;">Tady bude převážně Apache, ale
není to podmínka. A navíc, může se jednat o Apache 1.x nebo 2.x a tak
dále.<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<p>Další věc ke zvážení je "lidský faktor". Většinou bývá dobré se
ujistit zda a jaká systémová podpora ze strany správců je k dispozici a
zda jsou schopni pružně reagovat na Vaše požadavky. Pokud zjistíte, že
potřebujete jiné prostředí než to, které je na současném webu k
dispozici, můžete se pokusit přimět administrátory webu ke změně
nastavení, nebo můžete změnit poskytovatele webového prostoru. Je to na
Vás. Není ale nic otravnějšího než čekání na změny v nastavení, které
měl někdo udělat před několika dny a ono to stále není hotové. Zejména
když na tom "visí" další práce.<br>
</p>
<p>V dalším díle seriálu se naučíme, jak "pracovat s rozmyslem" při
organizování dat v databázi a členění programů.</p>
<a name="000257"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (61) - Rozsáhlejší projekty 2.</h2>
			<p class="perex">Jak se neztratit při vývoji rozsáhlejšího PHP projektu - databáze a fundované psaní kódu.
				<br>
			</p>
			<p>V předchozím díle našeho seriálu jsme nakousli téma vývoje
rozsáhlejších projektů. Dnes budeme pokračovat; řekneme si něco o
přípravě struktury databáze a o členění programu. Tyto věci je potřeba
udělat již v poměrně rané fázi vývoje, abyste měli jasno, kam se bude
Vaše aplikace ubírat.<br>
</p>
<a name="000258"></a><h2>Data a databáze</h2>
<p>Pokud aplikace má (a ona má skoro vždycky) nějaký vztah k databázi,
bývá dobrým zvykem navrhnout si, jak bude taková databáze vypadat. To
je velmi důležitá část přípravy. Není nic horšího než dodělávání
struktury databáze "za chodu", a to zejména mají-li se měnit relační
vztahy mezi tabulkami. Obecné pravidlo, jak to udělat "napoprvé a
dobře" pravděpodobně neexistuje. Ale jako příklad naznačíme, jak by se
mohla ubírat naše představivost při sestavování (dejme tomu) protálu
pro ON-LINE evidenci půjčování knížek z knihovny.<br>
</p>
<p style="font-style: italic;">Pozn.: Musíte uznat, že to je daleko
méně otřepaný příklad než ON-LINE obchod.<br>
</p>
<p>Důležité je si uvědomit, že každá tabulka by měla shromažďovat data
o jedné "entitě". Tento hrozný výraz zkrátka znamená, že budeme mít
tabulku "knih", tabulku "čtenářů" a tabulku "výpůjček". V MySQL by
návrh mohl vypadat nějak takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">CREATE TABLE ctenari (<br>
&nbsp;&nbsp;id int(11) NOT NULL auto_increment,<br>
&nbsp;&nbsp;prijmeni varchar(20) NOT NULL default '',<br>
&nbsp;&nbsp;jmeno varchar(10) default NULL,<br>
&nbsp;&nbsp;PRIMARY KEY&nbsp;&nbsp;(id)<br>
) <br>
<br>
CREATE TABLE knihy (<br>
&nbsp;&nbsp;id int(11) NOT NULL auto_increment,<br>
&nbsp;&nbsp;nazev varchar(50) NOT NULL default '',<br>
&nbsp;&nbsp;popis varchar(255) default NULL,<br>
&nbsp;&nbsp;PRIMARY KEY&nbsp;&nbsp;(id)<br>
) <br>
<br>
CREATE TABLE vypujcky (<br>
&nbsp;&nbsp;id int(11) NOT NULL auto_increment,<br>
&nbsp;&nbsp;ctenar int(11) NOT NULL ,<br>
&nbsp;&nbsp;kniha int(11) NOT NULL ,<br>
&nbsp;&nbsp;datum_od date NOT NULL ,<br>
&nbsp;&nbsp;PRIMARY KEY&nbsp;&nbsp;(id)<br>
) </font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Bude to stačit? V případě, že budeme půjčovat jen jednu knihu, zcela
určitě to jako kostra stačit bude; pokud bychom najednou půjčovali více
knih, stojí za zvážení zřízení další tabulky, aby se nám udaj "půjčeno
od" neopakoval zbytečně v mnoha řádcích. Níže uveďme některé technické
zásady, které byste měli mít při tvorbě tabulek k dispozici:<br>
</p>
<ul>
  <li>Ujasněte si, zda budete používat v názvech databázových objektů
malá, velká písmena nebo jejich kombinace. V MySqL to totiž není jedno.</li>
  <li>Zaveďte si nějakou metodiku pojmenování polí. Například já jsem
použil "id" jako název klíče v každé tabulce. To Vám může a nemusí
vyhovovat (někdo třeba používá "ctenari_id", "knihy_id" a podobně).</li>
  <li>Je-li to jen trochu možné, používejte nějaké vizuální pomůcky pro
návrh databáze</li>
  <li>Navrhněte nejprve pole, sloužící jako primární a cizí klíče.
Například, tabulka výpůjček bude jistě mít i pole datum_do, knihy
mohou mít čárový kód a podobně. Nicméně, pro představu o vztazích mezi
tabulkami stačí výše uvedená sktruktura.</li>
</ul>
<p> </p>
<a name="000259"></a><h2>Členění programu</h2>
<p>Dobře napsanou funkci můžete použít vícekrát. A to i v mnoha
projektech a
v
tom je kouzlo opakovaného používání kódu. Zvažme, například,
následující kód pro ověření hesla, který bychom chěli využít v několika
projektech:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
</font><font color="#007700">function </font><font color="#0000bb">overheslo
</font><font color="#007700">(</font><font color="#0000bb">$uzivatel</font><font color="#007700">, </font><font color="#0000bb">$heslo</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#dd0000">"localhost"</font><font color="#007700">, </font><font color="#dd0000">"root"</font><font color="#007700">, </font><font color="#dd0000">""</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#dd0000">"lsoft"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from hesla
where uzivatel=$uzivatel"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$radku</font><font color="#007700">=</font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$radku</font><font color="#007700">==</font><font color="#0000bb">0</font><font color="#007700">) return </font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$zaznam </font><font color="#007700">= </font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"heslo"</font><font color="#007700">]==</font><font color="#0000bb">$heslo</font><font color="#007700">) return </font><font color="#0000bb">true</font><font color="#007700">; else return </font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
}<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Poctivě řečeno, tato funkce moc dobře napsána není. V reálné
aplikaci by pravděpodobně stačilo použít existující připojení k
databázi, spíše než uvnitř těla funkce vytvářet nové (důvodem je to, že
pravděpodobně už nějaké to připojení k databázi bude existovat, nebo by
zanedlouho stejně vzniklo). Další problém je logický - nejprve
zjišťujeme zda existuje uživatel a potom, zda má správně heslo. To by
se dalo spojit do jednoho kroku. Třetí důvod proč to nepůjde použít je
ten, že k funkci není žádná dokumentace. Po úpravě by to mohlo vypadat
mnohem nadějněji (třeba takto):</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
</font><font color="#007700">function </font><font color="#0000bb">overheslo
</font><font color="#007700">(</font><font color="#0000bb">$link</font><font color="#007700">, </font><font color="#0000bb">$uzivatel</font><font color="#007700">, </font><font color="#0000bb">$heslo</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#ff8000">/*<br>
&nbsp;&nbsp;&nbsp;&nbsp;funkce ověří heslo proti datům v tabulce hesel<br>
&nbsp;&nbsp;&nbsp;&nbsp;vyžaduje:<br>
&nbsp;&nbsp;&nbsp;&nbsp;$link - existující spojení na databázi<br>
&nbsp;&nbsp;&nbsp;&nbsp;$uzivatel - id ověřovaného uživatele<br>
&nbsp;&nbsp;&nbsp;&nbsp;$heslo - nešifrovaná podoba hesla<br>
&nbsp;&nbsp;&nbsp;&nbsp;vrací:<br>
&nbsp;&nbsp;&nbsp;&nbsp;TRUE v případě, že daný uživatel má dané heslo,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;FALSE ve všech ostatních případech<br>
&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from hesla
where uzivatel=$uzivatel and heslo='"</font><font color="#007700">.</font><font color="#0000bb">$heslo</font><font color="#007700">.</font><font color="#dd0000">"'"</font><font color="#007700">, </font><font color="#0000bb">$link</font><font color="#007700">);<br>
&nbsp;&nbsp;return (boolean) </font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
}&nbsp;&nbsp;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Všimněte si (vím, že se opakuji), že kvalitní kód obsahuje
komentáře. To proto, abyste se v něm vyznali, když jej budete za
nějakou dobu chtít opravit - nebo znovupoužít. Toto téma je tak
důležité, že mu věnujeme i část následujícího dílu.</p>
<a name="000260"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (62) - Rozsáhlejší projekty 3.</h2>
			<p class="perex">Jak se neztratit v proměnných, konstantách, souborech, třídách a projektech. Jde to vůbec?
				<br>
			</p>
			<p>Dnes budeme pokračovat zcela v duchu minulých dvou dílů a rozebereme
si další způsoby, jak se neztratit při psaní nějakého rozsáhlejšího
projektu. Nebudou to věci překvapivě nové, ale věci překvapivě účinné,
pokud se rozhodnete řídit se jimi.</p>
<a name="000261"></a><h2>Komentáře</h2>
<p>Kvalitní kód je zcela vždy dokumentovaný kód. Paradoxně zjistíte, že
když budete programovat delší dobu, budete psát spíše více komentářů
než méně. To proto, že zralí programátoři jsou si vědomi potřebného
psaní komentářů velmi dobře (věřte mi, každý z nich totiž zažil fázi,
kdy se nevyznal ani ve svém vlastním projektu). Co by měly správné
komentáře obsahovat?<br>
</p>
<ul>
<li>U funkcí okomentujte, co musí být splněno, aby vracela to, co má.
Mohou to být "vnější" vlivy, jako je existující připojení k databázi,
existující rozšíření PHP a kdovíco ještě.</li>
<li>U funkcí okomentujte vstupní parametry. Měl by mít parametr
nějaký konkrétní typ? Hodnotu? Hodnotu z nějakého rozsahu? Napište si
to. Později to zcela jistě oceníte.</li>
<li>U funkcí okomentujte hodnoty, které může vrátit, a jejich význam.
Je hrozné mít funkci, která sice dělá to, co by měla, ale nikdo neví,
proč to bylo potřeba.</li>
<li>U tříd nějak okomentujte parametry. Snažte se rozlišit veřejné a
privátní členy, protože PHP je v tom dosti benevolentní.<br>
</li>
<li>V těle programu komentujte kód vždy, když je principiálně
nepřehledný. Usnandí vám to orientaci.</li>
<li>Pokud jste nějakou část kódu přepsali, je lepší tu původní
zakomentovat než odstranit. Později se Vám může stará verze hodit.</li>
</ul>
<p style="font-style: italic;">Pozn.: Ten poslední bod by se měl brát s
rezervou. Stejnou, ne-li lepší službu pro nás udělají systémy pro
správu zdrojových kódů. Ještě o nich bude řeč.<br>
</p>
<p>Někteří programátoři doporučují do poznámek psát rovněž datumy, kdy
se kód upravoval a některé další věci. Je to diskutabilní. Pokud je to
pro Vás přínosné, udělejte to.<br>
</p>
<p>Ještě pro doplnění: Některé čtenáře nadzvedlo, že jsem v předchozím
díle komentoval činnost procedury v jejím těle a ne před jejím
začátkem. Uvědomte si ale, že je mnohem důležitější to, <span style="font-style: italic;">zda</span> komentáře máte než to, <span style="font-style: italic;">kde</span> je máte. Budete-li chtít
přístup k psaní komentářů nějak unifikovat, mohou rozhodnout
následující činitele:<br>
</p>
<ul>
<li>Vaše zvyky</li>
<li>To, zda se chcete nebo musíte řídit nějakými konvencemi
(například firemními)</li>
<li>To, zda chcete nebo musíte používat nějaké nástroje pro
automatizovanou dokumentaci</li>
</ul>
<p></p>
<a name="000262"></a><h2>Typové konvence</h2>
<p>Už o tom rovněž byla řeč. Měli byste si zavést a dodržovat určitý
pořádek v názvech proměnných, funkcí, tříd, konstant a souborů. Náhledů
jak to dělat správně je mnoho. Pamatujte si, že většinou se budete na
linuxovém prostředí setkávat s tím, že na velikosti písmen bude
záležet, takže s tím počítejte. Někdo například názvy všech souborů
píše s malými písmeny.</p>
<p>Určitý systém lze vnést i do proměnných. Praktické je, když je z
názvu proměnné poznat k čemu slouží (nebo dokonce jaký je její datový
typ). Srovnejte, prosím, následující dva řádky kódu (třeba přitom
můžete zavzpomínat na školní léta):</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;$c</font><font color="#007700">=</font><font color="#0000bb">$z</font><font color="#007700">*</font><font color="#0000bb">$p</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>anebo je čitelnější toto?<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;$dblCast</font><font color="#007700">=</font><font color="#0000bb">$intZaklad</font><font color="#007700">*</font><font color="#0000bb">$dblPocet_procent</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Samozřejmě, se vzrůstající náročností kódu oceníte takovou čitelnost
ještě více. Hodně se dá napravit rovněž vhodným zavedením konstant a
logickými názvy souborů. Porovnejte, prosím, následující dva fragmenty
kódu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
</font><font color="#007700">if (</font><font color="#0000bb">$err</font><font color="#007700">==</font><font color="#0000bb">1</font><font color="#007700">):<br>
&nbsp;&nbsp;require (</font><font color="#dd0000">"file.php"</font><font color="#007700">);<br>
elseif (</font><font color="#0000bb">$err</font><font color="#007700">==</font><font color="#0000bb">2</font><font color="#007700">):<br>
&nbsp;&nbsp;require (</font><font color="#dd0000">"file2.php"</font><font color="#007700">);<br>
elseif (</font><font color="#0000bb">$err</font><font color="#007700">==</font><font color="#0000bb">3</font><font color="#007700">):<br>
&nbsp;&nbsp;require (</font><font color="#dd0000">"file3.php"</font><font color="#007700">);<br>
endif;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>anebo</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
define </font><font color="#007700">(</font><font color="#dd0000">"ERR_NO_FILE"</font><font color="#007700">, </font><font color="#0000bb">1</font><font color="#007700">); <br>
</font><font color="#0000bb">define </font><font color="#007700">(</font><font color="#dd0000">"ERR_EMPTY_FILE"</font><font color="#007700">, </font><font color="#0000bb">2</font><font color="#007700">); <br>
</font><font color="#0000bb">define </font><font color="#007700">(</font><font color="#dd0000">"ERR_CANT_WRITE"</font><font color="#007700">, </font><font color="#0000bb">3</font><font color="#007700">); <br>
<br>
if (</font><font color="#0000bb">$err</font><font color="#007700">==</font><font color="#0000bb">ERR_NO_FILE</font><font color="#007700">): <br>
&nbsp;&nbsp;require (</font><font color="#dd0000">"nofile.php"</font><font color="#007700">);<br>
elseif (</font><font color="#0000bb">$err</font><font color="#007700">==</font><font color="#0000bb">ERR_EMPTY_FILE</font><font color="#007700">): <br>
&nbsp;&nbsp;require (</font><font color="#dd0000">"emptyfile.php"</font><font color="#007700">);<br>
elseif (</font><font color="#0000bb">$err</font><font color="#007700">==</font><font color="#0000bb">ERR_CANT_WRITE</font><font color="#007700">): <br>
&nbsp;&nbsp;require (</font><font color="#dd0000">"cantwrite.php"</font><font color="#007700">);<br>
endif; <br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Ačkoli oba kousky kódu dělají v podstatě totéž - ke kterému z nich
byste se raději vraceli a luštili, co se v něm vlastně děje?<br>
</p>
<a name="000263"></a><h2>Organizace projektu</h2>
<p>Mám na mysli organizaci kódu do souborů a složek operačního systému.
Tady je každá rada drahá. U jednodušších věcí asi vystačíte s tím, že
můžete všechny skripty umístit do kořenové složky webu, u složitějších
projektů se vyplatí nějak zorganizovat složky. Například bývá často k
vidění uspořádání, kde soubory začlenění jsou v samostatné složce, v
jiné složce soubory pro import/export a podobně. Pozor pak musíte dávat
při vkládání soubrů pomocí include(require), protože vyžadují správné
uvádění cest. Můžete v zásadě použít dvě metody - uvádět relativně od
existujícího dokumentu a uvádět relativně od kořenové složky webu.
Obojí má své pro a proti, ale příliš se nevyplácí to míchat:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#007700">require (</font><font color="#dd0000">"./inc/somefile.php"</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a ten druhý způsob</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#007700">require (</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"DOCUMENT_ROOT"</font><font color="#007700">].</font><font color="#dd0000">"/inc/somefile.php"</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Pochopitelně, můžete mít nějaký vlastní systém. Ale ve větším
projektu se vkládání souborů prakticky nevyhnete, takže se s tím budete
muset nakonec nějak popasovat.</p>
<a name="000264"></a><h2>Dokumentace<br>
</h2>
<p>Konečně, každý projekt by měl mít nějakou dokumentaci. Nemluvím teď
o dokumentaci k vlastní aplikaci, ale o technické specifikaci
jednotlivých funkcí a procedur. Tady se vývojáři dělí na několik typů:</p>
<ul>
<li>na ty, kteří to nepíší vůbec</li>
<li>na ty, kteří to píší částečně nebo jen u větších věcí</li>
<li>a na ty, kteří to dělají ze zvyku a poměrně pravidelně</li>
</ul>
<p>Zejména těmu ukázněným pak mohou pomocí nástroje typu <a href="http://phpdoc.org/index.php">phpDocumentor</a>. My se spokojíme
s tvrzením, že by se to dělat mělo a v dalším díle se podívame na to,
jak si při vývoji pomoci cizími kódy, nástroji pro správu zdrojových
kódů a několika programovacími triky.</p>
<a name="000265"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (63) - Rozsáhlejší projekty 4.</h2>
			<p class="perex">Jak si při programování v PHP zorganizovat a ještě více ulehčit práci?
				<br>
			</p>
			<p>Vývoj kvalitního kódu zahrnuje rovněž umění "vyznat se sám sobě".
Mám tím na mysli vědět, co si při psaní kódu mohu dovolit, kde je nutné
být sám na sebe přísný a kde je možné si práci nějakým způsobem
ulehčit. Dnes se podíváme na některé takové metody a postupy.<br>
</p>
<a name="000266"></a><h2>Buďte líní</h2>
<p>Nevím, zda je to dokázáno vědecky, ale správný programátor by měl
být především líný. To mu umožní nedělat žádnou zbytečnou práci; a té
je při psaní kódu možné udělat více než dost. Kdykoli se tedy chystáte
psát
nějaký kód, měli byste se nejprve sami sebe ptát:<br>
</p>
<ul>
  <li>Nepsal už jsem někdy podobnou funkci nebo skript?</li>
  <li>Nemám k dispozici cizí kód, který by podobnou záležitost řešil?</li>
  <li>Dal by se najít příklad takové věci na internetu?</li>
  <li>Jestliže ne, mohl bych se alespoň inspirovat podobnou úlohou?<br>
  </li>
</ul>
<p>Většinou, zejména u jednoduchých úloh zjistíte, že nemusíte pracně
"vynalézat kolo". Jestliže ale narazíte na úlohu tak speciální, že
skutečně nenajdete podklady pro její řešení a budete to muset napsat od
nuly, mohli byste uvažovat následovně:<br>
</p>
<ul>
  <li>Jestliže ten kód budete opravdu potřebovat jen jednou, napište
jej a přestaňte na to myslet</li>
  <li>Jestliže tušíte, že byste ten kód mohli použít vícekrát, napište
jej pořádně a vytvořte k němu dokumentaci (viz minulý díl)</li>
  <li>Pokud jste napsali něco opravdu unikátního, zvažte možnost, že
byste se o kód mohli rozdělit s ostatními (ať už free, nebo za peníze)</li>
</ul>
<p style="font-style: italic;">Pozn.: Využívání cizích kódů s sebou
samozřejmě přináší problém licencování. Měli byste se ubezpečit, že to,
co děláte je zákonné. <br>
</p>
<a name="000267"></a><h2>Stanovte si postup</h2>
<p>Je třeba si práci nějak zorganizovat. Mě se osvědčil následující
postup: Zjistil jsem, že většina práce na zdrojovém kódu se dá rozdělit
na dvě skupiny - na kód, který budu muset teprve pracně vymyslet a na
kód, který budu psát téměř "z hlavy", protože vím, jak na to. Pokud
máte "tvůrčí vlnu", nezabývejte se otrockým psaním "nudného" kódu, ale
udělejte si "vycpávku". Vysvětlím na příkladu přihlašování k databázi:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#007700">if (</font><font color="#0000bb">validuser</font><font color="#007700">(</font><font color="#0000bb">$database</font><font color="#007700">, </font><font color="#0000bb">$user</font><font color="#007700">, </font><font color="#0000bb">$password</font><font color="#007700">))<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//kód pro
autorizované uživatele<br>
&nbsp;&nbsp;</font><font color="#007700">}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;function </font><font color="#0000bb">validuser </font><font color="#007700">(</font><font color="#0000bb">$database</font><font color="#007700">, </font><font color="#0000bb">$user</font><font color="#007700">, </font><font color="#0000bb">$password</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//todo - dodělat
přihlašování<br>
&nbsp;&nbsp;</font><font color="#007700">}<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Neboli, v dané chvíli se vůbec nemusíte zabývat vlastním kódem
funkce validuser, můžete směle pokračovat psaním dalšího kódu v těle
skriptu (označil jsem to jako "kód pro
autorizované uživatele". Kód funkce validuser může být pro Vás tak
triviální, že jej budete schopni napsat "zpaměti o půlnoci" a můžete se
věnovat "více tvůrčí" práci ve zbytku skriptu. Je samozřejmě důležité
poznamenat si někam, že se kus kódu musí dopsat, jinak na to
pravděpodobně
zapomenete. <br>
</p>
<p style="font-style: italic;">Pozn.: Jelikož v kódu PHP nezáleží, kde
je ve skriptu funkce umístěna, může být třeba i za místem, z něhož je
volána. Zde popsanému přístupu to zcela vyhovuje, lidé odkojení jazyky
typu Pascalu to asi moc mít rádi nebudou.<br>
</p>
<p>Toto samozřejmě není jediný možný ani jediný správný postup. Ale
pokud máte někdy náladu na "hardcore" programování a jindy ne, může to
pro Vás být to pravé. Další možné postupy jsou třeba "podle předem
stanoveného plánu" a "jak mě napadne". Ovšem, zejména poslední příklad
většinou nevede ke kýženému cíli ;-))<br>
</p>
<a name="000268"></a><h2>Spravujte zdrojový kód</h2>
<p>I při sebelepší práci se Vám občas stane, že dojdete k názoru, že
určitá předchozí verze kódu je lepší než ta současná. Jenomže ji už
nemáte k dispozici. Aby se to nestávalo, existují nástroje pro správu
zdrojového kódu (třeba <a href="https://www.cvshome.org/">cvs</a> nebo
<a href="http://subversion.tigris.org/">subversion</a>). Fungují tak,
že vytvoří "úložiště" kódu (tzv. repository) a vývojář může kód z
úložiště načíst, pracovat na něm a pak jej uložit zpět. Úložiště může
být přístupné více vývojářům, může být umístěno na síti a sleduje
veškeré změny v kódu, které byly provedeny "venku" mezi načtením a
uložením aktuální verze. Úložiště je schopno pracovat s libovolnými
textovými soubory (jako jsou třeba zdrojové kódy PHP) a rovněž s
binárními daty a není vázáno na
žádný konkrétní programovací jazyk.<br>
</p>
<p>V případě, že dva nebo více vývojářů změní stejný soubor, existují v
těchto nástrojích "správci konfliktů", kteří vám pomohou sladit změny
provedené více uživateli. Úložiště mohou být rovněž přístupné jako
webové služby a tak máte ke svým zdrojovým kódů přístup prakticky
odkudkoli. Většina lidí si myslí, že zavést nástroje pro
správu kódu ma význam až v momentě, kdy na projektu pracuje více
vývojářů, ale když se nad tím zamyslíte, není to tak. I když pracujete
sami, může se Vám hodit
odpověď na otázky typu:<br>
</p>
<ul>
  <li>Kdy jsem provedl poslední změnu v tomto souboru</li>
  <li>Jak vypadala tato složka před 14 dny?</li>
  <li>Program xxx ve verzi aaa.bbb nefunguje dobře. Co se tam měnilo?</li>
</ul>
<p>Můžete se vrátit k libovolné uložené verzi dokumentu a můžete dělat
celou řadu dalších věcí. Můžete dokonce smazat soubor z pracovní kopie
s tím, že úložiště si jej bude pamatovat. <br>
</p>
<p>Někdy Vám může "zachránit život" skutečnost, že máte úložiště kódu
přístupné přes prohlížeč nebo umístěné mimo vaše "obvyklé stanoviště".
Je to samozřejmě otázka zabezpečení, ale docela se může hodit možnost
mít své zdrojové kódy kdykoliv k dispozici. Kolegovi někdo nedávno
ukradl notebook... a i když to samozřejmě BYL problém, nepřišel díky
umístění kódu v repository alespoň o podstatnou část své práce.<br>
</p>
<p style="font-style: italic;">Pozn.: Uznávám, že u PHP není tato
otázka
tak palčivá. Obvykle si můžete zdrojové kódy PHP postahovat z běžícího
webu, když není jiná možnost. To u kompilovaných jazyků samozřejmě
nejde.<br>
</p>
<p>V dalším díle našeho seriálu se zaměříme na některé způsoby, jimiž
můžete části svého kódu ladit. Těšte se, budeme si "hrát" s kódem z
tohoto seriálu, v němž jste objevili chybu!</p>
<a name="000269"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (64) - Ladění kódu</h2>
			<p class="perex">Aplikace v PHP (jako kdekoli jinde) se musejí po napsání odladit. Podívejme se jak na to.
				<br>
			</p>
			<p>Přestože dobří vývojáři dokáží napsat i dlouhé části kódu bez
syntaktických chyb, prakticky vždy je potřeba kód odladit, dříve než se
na něj můžeme spolehnout. Dnes si ukážeme na některé běžnější metody,
jak ladění provádět a podíváme se, jak takové věci lze provozovat s
přihlédnutím k programování v PHP.<br>
</p>
<a name="000270"></a><h2>Obecné zásady</h2>
<p>Při ladění kódu byste měli pamatovat na několik jednoduchých zásad.
Je až s podivem, kolik vývojářů na ně nedbá, takže si uveďme alespoň ty
nejdůležitější:</p>
<p><span style="font-weight: bold;">Velikost kódu</span><br>
Měli byste psát jen takové celky kódu (pod výrazem "celky" myslím třeba
funkce nebo objekty), které se dají odladit samostatně. Nemá smysl
naskládat celou aplikační logiku do jednoho dlouhatánského skriptu a
pak v něm hledat chyby. Mě osobně kratší kusy kódu i lépe působí na
psychiku, když mám hledat chybu v hotové aplikaci.<br>
</p>
<p><span style="font-weight: bold;">Předpokládejte co nejméně</span><br>
Murphyho zákon říká, že každý program obsahuje nejméně jednu chybu. Kéž
by to byla pravda; většina programů obsahuje desítky chyb. Snažte se,
aby vaše malinkaté kousky kódu (třeba funkce) obsahovaly co nejméně
chyb, nebo aby chyby v nich pokud možno nepoškodily zbytek kódu. Pište
tak, aby byly skripty co možná nejspolehlivější a pamatujte na to, že
spolehlivost celku závisí jednak na spolehlivosti dílů, a jednak na
jejich počtu.<br>
</p>
<p><span style="font-weight: bold;">Metoda simulovaného průšvihu</span><br>
Tohle je selský rozum - každé testované jednotce (tak třeba funkci)
předhoďte nejprve správná data, a potom ta špatná. Zatímco v prvním
případě byste měli dostat správný výsledek, ve druhém případě se může
stát hodně věcí. Tak například funkce dělící nějaké číslo vstupním
parametrem by neměla přijímat nulu. Co se stane, když ji nulu předáte?
Budou následky tak hrozné, že vaši aplikaci odešlou do věčných lovišť,
nebo se uživatel "jen" dozví, že došlo k chybě "Division by zero"?<br>
</p>
<p><span style="font-style: italic;">Pozn.:Ačkoli se Vám uvedené
pravidlo může zdát jako samozřejmé, divili byste se, kolik vývojářů se
ani nepokusí shodit svůj vlastní kód podstrčením nějakých nevhodných
parametrů. Jak potom mohou vědět, co to udělá, když to za ně vyzkouší
někdo jiný?</span><br>
</p>
<p>Podívejme se teď, jak konkrétně můžeme kód v PHP testovat. Možností
je mnoho a volit byste měli podle toho, jak důležitá vaše aplikace bude
a také podle toho, jak moc máte chyby v kódu rádi (já je moc rád nemám).<br>
</p>
<a name="000271"></a><h2>Vypisování proměnných</h2>
<p>Následující metodu pravděpodobně budete tak či tak znát a používat.
Na podezřelé místo v
kódu
lze vložit příkaz echo (případně print_r) a vypsat si proměnné, které
se v kódu používají. Mějme například následující funkci pro převod
řetězce představujícího datum na český formát:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">datum
</font><font color="#007700">(</font><font color="#0000bb">$datum</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;return </font><font color="#0000bb">strftime</font><font color="#007700">(</font><font color="#dd0000">"%d.%m.%Y"</font><font color="#007700">,</font><font color="#0000bb">strtotime</font><font color="#007700">(</font><font color="#0000bb">$datum</font><font color="#007700">));<br>
}<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Můžete si myslet, že té funkci vůbec nic není, a můžete mít pravdu.
Potíž může spočívat v parametru $datum. Možná, že v nějaké složitější
části kódu nebude na první pohled zřejmé, co se předává. Takže pro
účely ladění
pravděpodobně každý rozumný programátor přepíše funkci ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">datum
</font><font color="#007700">(</font><font color="#0000bb">$datum</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;echo </font><font color="#0000bb">$datum</font><font color="#007700">;<br>
&nbsp;&nbsp;return </font><font color="#0000bb">strftime</font><font color="#007700">(</font><font color="#dd0000">"%d.%m.%Y"</font><font color="#007700">,</font><font color="#0000bb">strtotime</font><font color="#007700">(</font><font color="#0000bb">$datum</font><font color="#007700">));<br>
}<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>A v prohlížeči hned uvidí, co že se to do funkce vlastně dostává v
parametru $datum.
Celá ta taškařice s vypisováním proměnných se rovněž dá udělat daleko
inteligentněji - například lze v úvodu skriptu definovat konstantu
DEBUGGING a podle toho, zda ji nastavíte na hodnotu TRUE nebo FALSE ve
funkcích vypisovat ladící údaje. Náš jednoduchoučký příklad by potom
mohl vypadat následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
define </font><font color="#007700">(</font><font color="#dd0000">"DEBUGGING"</font><font color="#007700">, </font><font color="#0000bb">FALSE</font><font color="#007700">);<br>
function </font><font color="#0000bb">datum </font><font color="#007700">(</font><font color="#0000bb">$datum</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">DEBUGGING</font><font color="#007700">) echo </font><font color="#0000bb">$datum</font><font color="#007700">;<br>
&nbsp;&nbsp;return </font><font color="#0000bb">strftime</font><font color="#007700">(</font><font color="#dd0000">"%d.%m.%Y"</font><font color="#007700">,</font><font color="#0000bb">strtotime</font><font color="#007700">(</font><font color="#0000bb">$datum</font><font color="#007700">));<br>
}<br>
<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p style="font-style: italic;">Pozn.: Tento nápad samozřejmě není můj.
Používá se to například v
projektu <a href="http://www.phpbb.com/">PhP BB</a> a pokud chcete
nahlédnout do zdrojových kódů této aplikace, můžete se podívat na
soubory constants.php a functions.php ve složce includes.</p>
<p><span style="font-style: italic;">Pozn.: Studium cizích otevřených
kódů vůbec není špatná věc, protože je jasné, že mnoho problémů, třeba
zrovna to ladění, se tam již nějak řešilo.<br>
</span></p>
<a name="000272"></a><h2>Debug_backtrace</h2>
<p>Tato užitečná <a href="http://cz.php.net/manual/cs/function.debug-backtrace.php">PHP
funkce</a> nám může ušetřit mnoho času při zjišťování, kde se při
ladění nacházíme, protože poskytuje informace o aktuálním názvu
zpracovávaného souboru, funkci, řádku, vstupních parametrech a o
několika dalších věcech. Její typické použití může být ve spojení s
funkcí var_dump následující (tento kód by mohl být použit namísto
výpisu prostřednictvím echo):</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">if (</font><font color="#0000bb">DEBUGGING</font><font color="#007700">) </font><font color="#0000bb">var_dump</font><font color="#007700">(</font><font color="#0000bb">debug_backtrace</font><font color="#007700">());<br>
&nbsp;&nbsp;</font><font color="#ff8000">// atd.<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Mít jistotu, že kód obsahuje málo chyb a že bude dělat to, co
očekáváme je pochopitelně velmi důležité. Proto se budeme laděním kódu
zabývat i v následujících dvou dílech našeho seriálu, kde se postupně
dotkneme takových témat, jako jsou aserce, logování, testovací skripty
a PHP debuggery. Takže, máte se na co těšit.</p>
<a name="000273"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (65) - Ladění kódu 2.</h2>
			<p class="perex">Další techniky ladění kódu PHP. Aserce, testovací skripty.
				<br>
			</p>
			<p>Pokračujme dnes tím, co jsme načali v minulém díle - a sice postupy
a metodami, které mohou zbavit náš kód chyb. Ladit kód můžeme i jinak
než jen vypisováním proměnných a nastavováním příznaků pro ladění.
Podívejme se nejprve třeba na aserce.<br>
</p>
<a name="000274"></a><h2>Aserce</h2>
<p>Tento výraz souvisí s asertivním chováním. Když to hodně
zjednodušíme (psychlogové prominou) tak bychom mohli aserce definovat
jako "ozvi se, když není po tvém". V programování se aserce používají
jakožto ladící nástroj a PHP aserce realizuje pomocí příkazu <a href="http://cz.php.net/manual/cs/function.assert.php">assert()</a>.
Následuje primitivní ukázka, jak by se mohly aserce použít, jestliže
předpokládáme, že proměnná $denvmesici označuje pořadové číslo dne v
měsíci:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#ff8000">//dřívější kód<br>
</font><font color="#0000bb">assert</font><font color="#007700">(</font><font color="#0000bb">is_integer</font><font color="#007700">( </font><font color="#0000bb">$denvmesici </font><font color="#007700">) &amp;&amp;
(</font><font color="#0000bb">$denvmesici </font><font color="#007700">&gt;=
</font>1<font color="#007700">) &amp;&amp; (</font><font color="#0000bb">$denvmesici
</font><font color="#007700">&lt;= </font><font color="#0000bb">31</font><font color="#007700">)); <br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Je jasné, že když proměnná $denvmesici nebude celé číslo nebo když
nebude v rozsahu od 1 do 31, že se PHP ozve. K asercím bych chtěl
připojit dvě důležitá varování, která je potřeba brát vážně:<br>
</p>
<ol>
  <li>Aserce nejsou nástroj na programování, ale nástroj na ladění.
Takže byste jimi neměli kontrolovat vstupní parametry, k tomu slouží
jiné nástroje (třeba konstrukce case, switch nebo if). Aserce by vám
pouze měly pomoci v ladění kódu. Skript by měl fungovat jak se
zapnutými asercemi, tak s vypnutými (o zapínání a vypínaní asercí bude
řeč za chvíli).<br>
  </li>
  <li>PHP zachází s asercemi jinak než kompilované jazyky. Kompilované
jazyky mají většinou jako výchozí nastavení to, že aserce jsu zapnuty
ve vývojovém prostředí a vypnuty ve spustitelném (přeloženém, binárním)
souboru. V PHP, jelikož není kompilovaný ale interpretovaný se aserce
vypínají, zapínají a nastavují z kódu.</li>
</ol>
<p>Uvedl jsem, že když podmínka v aserci splněna nebude, PHP "se ozve".
Co PHP udělá, to se dá nastavit pomocí funkce <a href="http://cz.php.net/manual/cs/function.assert-options.php">assert_options()</a>.
Přičemž možnosti josu poměrně pestré a může to být jedna nebo více z
následujících akcí:</p>
<ul>
  <li>Zobrazit varovaní (ASSERT_WARNING)</li>
  <li>Přerušit běh skriptu (ASSERT_BAIL)</li>
  <li>Zavolat uživatelem definovanou funkci (ASSERT_CALLBACK)</li>
</ul>
<p>Assert_options dělá ještě jednu dosti podstatnou věc, a to tu, že
aserce vypíná a zapíná (dělá se to voláním funkce s parametrem
ASSERT_ACTIVE). Vhodnou kombinací voleb aserce a zejména vhodným
napsáním funkce, která aserce ošetřuje můžete získat poměrně mocný
ladící nástroj. Znovu ale opakuji, že pokud používáte aserce, měli
byste je ve finálním kódu VYPNOUT.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Aserce Vám rovněž mohou
připomenout, co se v kódu děje. V uvedeném příkladu sice bylo z názvu
proměnné vidět, co asi obsahuje, ale to nemusí platit vždy. Takže z
vhodně napsané aserce můžete poznat, že při psaní kódu jste počítali s
tím, že určitá pravidla BUDOU platit. Tento fakt může být neocenitelný,
zejména když kód ladíte po delší době.</span> </p>
<a name="000275"></a><h2>Logování</h2>
<p>Kromě možnosti vypisovat údaje z běžícího skriptu pro účely ladění
do prohlížeče máme samozřejmě možnost vypisovat je do souborů. To může
být velmi mocná zbraň. Soubor s protokolem může být odeslán na vzdálené
místo, nebo se dá průběžně monitorovat a o případných chybách tak
víte prakticky okamžitě. PHP obsahuje vetavěnou podporu pro odesílání
chybových stavů do protokolu pomocí funkce <a href="http://cz.php.net/manual/cs/function.error-log.php">error_log()</a>.
<br>
</p>
<p>Error_log může při chybě odeslat informace do systémového logu,
e-mailem nebo&nbsp; může spolupracovat s debuggery. Ačkoli je to funkce
velmi mocná, není samospasitelná. Její hlavní nevýhodou je fakt, že
protokoluje pouze chyby. Přitom čas od času budete potřebovat něco
jiného - například můžete pro účely ladění chtít vědět, kolikrát za den
se ta která část kódu spouští, nebo prostě budete chtít logovat něco
jiného (hodnoty proměnných, například). Ukažme si, jak využít&nbsp;
třídu Log, kterou byste našli v odpovídajícím balíčku na serveru
<a href="http://pear.php.net/package/Log">pear.php.net</a>:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?php<br>
</font><font color="#ff8000">// třída pro logování<br>
</font><font color="#007700">require_once </font><font color="#dd0000">'Log.php'</font><font color="#007700">;<br>
</font><font color="#ff8000">//konfigurace loggeru<br>
</font><font color="#0000bb">$conf </font><font color="#007700">=
array(</font><font color="#dd0000">'mode' </font><font color="#007700">=&gt;
</font><font color="#0000bb">0600</font><font color="#007700">, </font><font color="#dd0000">'timeFormat' </font><font color="#007700">=&gt; </font><font color="#dd0000">'%X %x'</font><font color="#007700">);<br>
</font><font color="#0000bb">$logger </font><font color="#007700">=
&amp;</font><font color="#0000bb">Log</font><font color="#007700">::</font><font color="#0000bb">singleton</font><font color="#007700">(</font><font color="#dd0000">'file'</font><font color="#007700">, </font><font color="#dd0000">'out.log'</font><font color="#007700">, </font><font color="#dd0000">'ident'</font><font color="#007700">, </font><font color="#0000bb">$conf</font><font color="#007700">);<br>
</font><font color="#ff8000">//logování<br>
</font><font color="#0000bb">$logger</font><font color="#007700">-&gt;</font><font color="#0000bb">log</font><font color="#007700">(</font><font color="#dd0000">"Skript spuštěn."</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Celý skript by, po nahlédnutí do souboru protokolu, způsobil v logu
zhruba následující záznam:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">12:37:14 11/08/04 ident
[info] Skript spuštěn.</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Tím možnosti logovací třídy nekončí - lze zapisovat do databáze,
nastavovat příznaky logovaných událostí a podobně. Podstatné přitom je,
že můžete vlastní logování zařídit jedním řádkem kódu - a přitom má
výstup do souboru profesionální úroveň.<br>
</p>
<p style="font-style: italic;">Pozn.: Jelikož patří třída log na
serveru PEAR k těm jednodušším, mohli by ji rovněž využít pro vlastní
zkoumáni lidé, zajímající se do hloubky o objektové programování v PHP.
Najdete tam pár zajímavých věcí, které se vám mohou hodit.</p>
<a name="000276"></a><h2>Testovací skripty<br>
</h2>
<p>Nakolik se to může zdát na první pohlad nesmysl, lze někdy odladit
část kódu tak, že vyzkoušíme kombinaci všech možných hodnot vstupních
parametrů. Pochopitelně to nebudeme dělat ručně, napíšeme si "skript
testující skript". To může být zdlouhavá a úmorná práce, ale může se to
bohatě vyplatit. Otestováním všech vstupních hodnot totiž získáte téměř
stoprocentní jistotu, že skript běhá tak, jak má.<br>
</p>
<p>Pokud si vzpomínáte na díl, v němž jsme <a href="#000065">programovali
kalendář</a>, bylo jeho těžiště ve funkci, která přijímala jako
argument měsíc a rok:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">Kalendar
</font><font color="#007700">(</font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#ff8000">//atd.<br>
</font><font color="#007700">}<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>To je příklad funkce, která by se dala otestovat skriptem. Mohl by
vypadat nějak následovně:
<!-- Zaza PHP kód BEGIN --></p>
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">for (</font><font color="#0000bb">$rok</font><font color="#007700">=</font><font color="#0000bb">1998</font><font color="#007700">; </font><font color="#0000bb">$rok</font><font color="#007700">&lt;=</font><font color="#0000bb">2001</font><font color="#007700">; </font><font color="#0000bb">$rok</font><font color="#007700">++) <br>
{<br>
&nbsp;&nbsp;for (</font><font color="#0000bb">$mesic</font><font color="#007700">=</font><font color="#0000bb">1</font><font color="#007700">; </font><font color="#0000bb">$mesic</font><font color="#007700">&lt;=</font><font color="#0000bb">12</font><font color="#007700">; </font><font color="#0000bb">$mesic</font><font color="#007700">++) <br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">Kalendar</font><font color="#007700">(</font><font color="#0000bb">$mesic</font><font color="#007700">, </font><font color="#0000bb">$rok</font><font color="#007700">);<br>
&nbsp;&nbsp;}<br>
}<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Vidíme, že v tom nejsou žádné záludnosti a že se tak poměrně
jednoduše lze propracovat k uspokojivým výsledkům. V praxi nebudou
všechny příklady ani zdaleka tak jednoduché, a v podobných případech
jistě stojí za to si to odzkoušet.</p>
<a name="000277"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (66) - PHP debugger</h2>
			<p class="perex">Dnes se podíváme na zoubek PHP debuggerům. Uvidíme zda a jaké existují a jak je rozumně použít.
				<br>
			</p>
			<p>Přemýšlím nad nějakým smysluplným zahájením. Co třeba takhle: "Celý
jsem strávil rozchozením nějakého nekomerčního PHP debuggeru, a zatím
žádná sláva". Nebylo by to sice dvakrát optimistické, ale pěkně by to
vystihovalo situaci, v níž se nacházím. Leč popořadě.<br>
</p>
<a name="000278"></a><h2>Debuggery</h2>
<p>Mezi většinou vývojářů napříč programovacími jazyky získala velkou
oblibu integrovaná vývojová prostředí (Integrated Development
Environment, IDE (neplést s disky)). Jedná se o vylepšené editory,
které kromě úprav zdrojového textu umí třeba spustit překladač (to se
PHP
samozřejmě netýká), a umí provádět ladění kódu za běhu. Mezi typické
činnosti takového procesu ladění patří zejména:</p>
<ul>
  <li>zarážky - možnost zastavit běh kódu na předem daném místě, ať už
"natvrdo" nebo při splnění nějaké podmínky</li>
  <li>krokování - možnost spouštět jednotlivé kroky programu po kouscích</li>
  <li>sledování hodnot proměnných</li>
  <li>sledování volání (stack, zásobník) - tedy můžete odpovědět na
otázku "která funkce zavolala naši funkci"</li>
  <li>případně "ad-hoc" provedení nějakého příkazu zapsaného z konzoly</li>
</ul>
<p>Bylo by samozřejmě velmi hezké mít takové integrované prostředí i
pro práci s PHP a taková prostředí skutečně existují. Většina z nich má
však dvě podstatné nectnosti - buď jsou za peníze, nebo fungují pouze
pod windows (nebo dokonce obojí). Pokusil jsem se podívat na zoubek
dvěma nástrojům, které se tvářily, že jsou zdarma.</p>
<a name="000279"></a><h2>DBG</h2>
<p><a href="http://dd.cron.ru/dbg/">DBG</a> je de facto část balíku z <a href="http://www.nusphere.com/">PHPEd</a>, což je jedno takové PHP
IDE. Na stránce projektu se o něm dozvíme, že je šířen ve dvou verzích,
verze 2.16.x je součástí zmiňovaného IDE a je za peníze, verze 2.11.x
je distribuovaná samostatně a je zdarma. Instalace debuggeru je na
stránkách projektu <a href="http://dd.cron.ru/dbg/installation.php">popsána</a>
a na první pohled vypadá celkem zajímavě. Jelikož je PHP samozřejmě
serverová záležitost, řeší se zde spolupráce ladícího procesu s PHP
instalací modulu dbg.so
jakožto rozšíření PHP (tedy extension). Sama instalace je triviální,
spočívá v nakopírování souboru dbg.so do složky s php rozšířeními a v
editaci souboru php.ini (měl by být v /etc/php.ini). To, že se modul
úspěšně nahrál, můžete zjistit pomocí skriptu phpinfo(), protože údaje
o modulu dbg se v informacích z phpinfo <span style="font-style: italic;">objeví</span>.<br>
</p>
<p style="font-style: italic;">Pozn.: Pokud si to přejete, můžete
dbg.so kompilovat ze zdrojového kódu. V každém případě byste měli
vědět, že verze souboru dbg.so (nebo dbg.dll pro Windows) by měla
odpovídat
verzi nainstalovaného PHP.</p>
<p>To byly dobré zprávy. Teď to horší. Zatímco pod Windows existuje k
DBG grafický frontend (<a href="http://dd.cron.ru/dbg/sshot.php">screenshoty</a>),
pod Linuxem je zdarma k dispozici pouze řádkový klient dbg-cli. Aby nám
to nebylo líto jsme informováni, že "dbg-cli může být použito k ladění
skriptů buďto přímo, nebo pod GNU debuggerem <a href="http://www.gnu.org/software/ddd/">DDD</a> 3.3.9". Rozchodit
samotný debugger mi nedělalo problém, zatímco skloubit jeho činnost s
dbg-cli se mi nepodařilo. Nebyl jsem sám, v diskusi k projektu je
tomuto problému věnováno <a href="http://support.nusphere.com/viewtopic.php?t=734">téma</a> s
několika reakcemi. Poučné jsou i odpovědi autora, který dává
jednoznačně najevo, že podporuje především placenou verzi programu, což
je logické. <br>
</p>
<p>Asi bych si tento software nezvolil. Možná, že nějaký laskavý čtenář
má zkušenosti s placenou verzí tohoto software. Dejte nám, prosím,
vědět v diskusi, zda a jak to v takovém případě funguje. Pro někoho by
taková informace mohla být cenná, pokud bude uvažovat o koupi nějakého
komerčního PHP debuggeru.<br>
</p>
<p></p>
<a name="000280"></a><h2>GUBED</h2>
<p>To je zajímavější část mého snažení. <a href="http://gubed.mccabe.nu/">Gubed</a> je debugger postavený na
samotném PHP (pokud nevěříte, že něco takového je možné, podívejte se
do <a href="http://gubed.mccabe.nu/?module=article&amp;page=articleview&amp;category_id=3&amp;article_id=541">dokumentace</a>).
Z toho vyplývá příjemná vlastnost - a to ta, že se kvůli němu nemusí
instalovat na server žádný modul PHP ani žádné rozšíření serverového
software. To mimo jiné znamená, že můžete ladit své skripty ve
skutečném prostředí (!) serveru, na němž budou běžet.<br>
</p>
<p>GUBED samozřejmě vyžaduje kromě serverové části i nějaký klientský
software, který bude
výsledky ladění odchytávat. Tím softwarem může být buďto populární
editor <a href="http://quanta.sourceforge.net/">Quanta</a>, nebo s
projektem dodávaný front-end nazvaný wxGubed. Zkusil jsem Quantu. Ta
podporuje GUBED až od verze 3.3, což je hotové neštěstí, pokud si toho
nevšimnete. Takže pozor, ve většině distribucí bývá Quanta 3.2,
zkontrolujte to, případně updatujte. (SUSE 9.1, na níž jsem to zkoušel
měla Quantu 3.2. Aby toho nebylo málo, jmenuje se balíček ve verzi 3.3
nikoli quanta, ale kdewebdev3).<br>
</p>
<p>Instalace <span style="font-weight: bold;">serverové</span> části
GUBEDu je triviální. Stačí nakopírovat adresář Gubed (obsahuje php
skripty, nic jiného) z instalačního balíčku do kořenové
složky webu a vytvořit soubor s konfigurací (localsettings.php), který
může vypadat nějak následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?php<br>
$gbdDebugServer </font><font color="#007700">= </font><font color="#dd0000">"localhost"</font><font color="#007700">;<br>
</font><font color="#0000bb">$dbgDebugPort </font><font color="#007700">=
</font><font color="#0000bb">8016</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Celý postup popisuje soubor docs/serversetup.txt z originálního
instalačního balíku. Je nutno podotknout, že při nasazení na veřejně
přístupný server se musejí dořešit otázky zabezpečení, protože debugger
pochopitelně načítá zdrojové soubory php. Zmínka o zabezpečení je
rovněž v dokumentaci.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Osobně bych to zprovozňoval
pouze na místím počítači nebo v místní síti.<br>
</span></p>
<p><span style="font-weight: bold;">Klientská</span> část&nbsp;
debuggeru spočívá v nastavení Quanty tak, aby pro daný projekt spustila
debugger. Provedete to v menu Project/Project properties na záložce
Možnosti. Pokud se tak nestane automaticky, je ještě nutné spustit
proces ladění pomocí volby Debug/Session/Start session. V nástrojovém
pruhu Quanty byste měli mít lištu Debugger toolbar, která Vám umožní
krokovat kód, nastavovat zarážky a vypisovat hodnoty proměnných (<a href="http://gubed.mccabe.nu/?module=media&amp;page=mediaview&amp;media_id=3&amp;gallery_id=9&amp;media_medialist_sort=mm.media_id%20DESC">screenshot</a>).
A lidi - ono to opravdu funguje.<br>
</p>
<p>Ladění se <span style="font-weight: bold;">spouští </span>z
prohlížeče pomocí skriptu index.php ve složce Gubed, kterou jste si
nainstalovali do kořenové složky webu, takže vám většinou bude stačit
zadat do prohlížeče http://localhost/Gubed. Subjektivně se mi zdá
krokování poměrně pomalé, ale v praxi to pochopitelně nevadí, protože
při ladění programu se obvykle nespěchá.<br>
</p>
<a name="000281"></a><h2>Závěr</h2>
<p>Pro rozsáhlejší projekty bych si debugger určitě pořídil. Pokud
používáte pro vývoj Quantu, prakticky není co řešit. Pro jednodušší
věci mi to přijde jako trochu zbytečná věc, ale ladit kód debuggerem je
bezesporu pohodlné. Více než kdy předtím ocením vaše postřehy v diskusi
- používáte někdo zde uveené nebo jiné debuggery pro PHP? A jestliže
ano, s jakými výsledky?</p>
<a name="000282"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (67) - Zdroje informací o PHP</h2>
			<p class="perex">Knihy, stránky a projekty související s PHP, které Vám mohou vydatně pomoci.
				<br>
			</p>
			<p>V našem seriálu jsme se dotkli mnoha podstatných věcí, týkajících se
PHP. Pevně věřím, že to bylo pro čtenáře užitečné. Seriál ještě
nekončí; dnes se podíváme na některé zdroje, které Vám při práci s PHP
mohou výrazně pomoci.<br>
</p>
<a name="000283"></a><h2>Knihy</h2>
<p>Asi nejlepší českou knihou o PHP je dosud Jiří Kosek - <a href="http://www.grada.cz/content/katalog.php?kid=350">Tvorba
interaktivních internetových aplikací</a>. Autor má tu vzácnou
vlastnost (která se pohříchu nedostává mnoha jiným), že umí vysvětlovat
složité věci na jednoduchých příkladech a celá kniha je nesmírně čtivá.
Ačkoli neobsahuje CD, lze si uvedené příklady stáhnout z <a href="http://www.kosek.cz/php/index.html">autorova webu</a> a pak s
nimi pracovat. Kniha obsahuje mimo vysvětlení prakticky všech aspektů
PHP rovněž referenční přehled funkcí a ten je provázán s příklady.
Praktické, veskrze použitelné. I když byla tako kniha psána v době éry
PHP 3, neztratila dodnes nic ze své aktuálnosti. Abyste si udělali
přehled, co o této knize řekli/napsali jiní:<br>
</p>
<ul>
  <li><a href="http://diskuse.jakpsatweb.cz/index.php?action=vthread&amp;forum=15&amp;topic=106">Diskuse
na www.jakpsatweb.cz</a> <br>
  </li>
  <li><a href="http://hash.webjet.cz/modules.php?name=News&amp;file=article&amp;sid=28">Recenze
na hash.webjet.cz</a></li>
</ul>
<p style="font-style: italic;">Pozn.: Mnoho dalších, viceméně
pochvalných komentářů je roztroušeno po celém českém webu.<br>
</p>
<p>S oblibou používám rovněž publikaci <a href="http://knihy.cpress.cz/pocitac/Book.asp?ID=224">PHP -
programujeme profesionálně</a> od pětice zahraničních autoru (Computer
Press). Kniha není sice psána tak čtivě jako ta Koskova,&nbsp; ale
zabývá se do hloubky některými tématy, kterých se pan Kosek dotýká jen
zběžně. Mám na mysli například XML, regulární výrazy nebo třebas
instalace PHP. K této knize je rovněž dodáváno CD - v dnešní době bude
již poměrně zastaralé, ale najdete na něm "klasickou" výbavu typického
"Péhápisty". Od PHP počínaje, až třebas k Apache s česky komentovanými
instalačními skripty. Na CD jsou pochopitelně i příklady, v češtině.
Opět bych si dovolil něco odkazů na komentáře či recenze:<br>
</p>
<ul>
  <li><a href="http://www.softnov.cz/index.php?ID=19153">Recenze na
softwarových novinách</a></li>
  <li><a href="http://www.pcsvet.cz/art/article.php?id=2611">Recenze na
PC světě</a></li>
</ul>
<p>Ve výčtu dobrých knih o PHP bychom samozřejmě mohli pokračovat,
můžete to za mě udělat v diskusi pod článkem. Prakticky vždy platí, že
je důležité vědět, kde najít potřebné informace. Existují rovněž
publikace, zabývající se spoluprací PHP s ostatními produkty (typicky
MySQL) a mnoho tématicky zaměřených knih (PHP rychle, PHP bezpečně, PHP
modulárně ...).<br>
</p>
<p><span style="font-weight: bold;"></span></p>
<a name="000284"></a><h2>Servery</h2>
<p>Významným zdrojem informací o PHP jsou rovněž ON-LINE zdroje.
Narozdíl
od knih mohou pružně reagovat na nejnovější verze PHP, trendy v
programování a tak dále. V tabulce níže uveďme některé známější PHP
servery.<br>
</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Server<br>
      </td>
      <td style="vertical-align: top;">Co tam najdeme<br>
      </td>
    </tr>
    <tr align="center">
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span style="font-weight: bold;">Zahraniční weby</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://www.php.net/">www.php.net</a>,
      <a href="http://www.php.cz/">www.php.cz</a><br>
      </td>
      <td style="vertical-align: top;">Hlavní stana PHP (a český
mirror). Události kolem PHP, dokumentace, komentáře programátorů. Váš
startovní bod pro všechny PHP záležitosti. Rovněž jako místo, kde se
vyplatí sledovat informace o bezpečnostních updatech.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://pear.php.net/">pear.php.net</a><br>
      </td>
      <td style="vertical-align: top;">PHP Extension and Application
Repository - knihovny hotových kódů, řešící v PHP nejrůznější úlohy,
které samotný jazyk buď neumí, nebo umí nedostatečně. Velmi dobré,
pokud chcete navázat na existující práci nebo se nechat inspirovat.
Repository má vlastní standardy pro tvorbu kódu, takže se v
jednotlivých knihovnách můžete poměrně snadno vyznat (ovšem až poté, co
si na jejich standardy zvyknete)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://phpbuilder.com/">www.phpbuilder.com</a><br>
      </td>
      <td style="vertical-align: top;">Vývojářský site. Články, ukázky
kódu, tutoriály. Některé zde zveřejněné texty mají vynikající úroveň. K
zahození většinou nejsou ani komentáře, zdá se, že sem přispívají lidé,
kteří vědí, o čem je řeč.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://sourceforge.net/softwaremap/trove_list.php?form_cat=183">sourceforge.net</a><br>
      </td>
      <td style="vertical-align: top;">Známý server pro <font face="sans-serif, Verdana, Arial, Geneva" size="-1">Open&nbsp;Source&nbsp;software&nbsp;development.
Pro nás je důležité, že obsahuje rovněž několik tisíc projektů v PHP z
nichž některé (jako například <a href="http://sourceforge.net/projects/phpmyadmin/">PHPmyAdmin</a>)
jsou velmi kvalitní.<br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://www.hotscripts.com/PHP/index.html">www.hotscripts.com</a><br>
      </td>
      <td style="vertical-align: top;">Méně známý, přesto však poměrně
kvalitní web obsahující mimo jiné PHP skripty. Poměrně slušné tematické
třídění webu a možnost hodnocení článků z něj dělají místo, kde se dá
solidně vyznat. I když, web je na můj vkus trochu moc červený ;-))<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://www.planet-source-code.com/vb/default.asp?lngWId=8">planet-source-code</a><br>
      </td>
      <td style="vertical-align: top;">Nesmíme zapomínat na legendární
web se spoustou kódů pro mnoho programovacích jazyků. Občas se tam dají
najít hotové perly. A kódu je tam opravdu hodně. Samozřejmě, že jednou
ze sekcí je i PHP.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://www.tutorialized.com/tutorials/PHP/1">www.tutorialized.com</a><br>
      </td>
      <td style="vertical-align: top;">Tutoriály. Více než prosté
předložení kódu, obsahuje komentáře a některé velmi zdařilé popisy
postupů, které Vám umožní se neztratit při tvorbě PHP kódu. Jinak
stránky obsahují rovněž tutoriály pro jinaé programovací jazyky.<br>
      </td>
    </tr>
    <tr align="center">
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span style="font-weight: bold;">České weby</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://www.jakpsatweb.cz/">www.jakpsatweb.cz</a><br>
      </td>
      <td style="vertical-align: top;">Precizní a široce pojatý server
o tvorbě webu. Jsou zde i články o PHP. Například <a href="http://www.jakpsatweb.cz/php/jak-zacit.html">instalace</a> nebo <a href="http://www.jakpsatweb.cz/php/moznosti-php.html">nástin možností
jazyka</a>. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://www.kosek.cz/clanky/iweb/index.html">www.kosek.cz</a><br>
      </td>
      <td style="vertical-align: top;">Mnoho relevantních informací o
PHP. Viz sekce Knihy. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://www.zive.cz/h/Programovani/default.asp?CAI=2038">www.zive.cz</a><br>
      </td>
      <td style="vertical-align: top;">Seriál o PHP, mimo jiné. Můžete
srovnat s naším seriálem.<br>
      </td>
    </tr>
  </tbody>
</table>
<p>Jistěže existuje nespočet dalších webů zabývajících se tématikou
PHP. Pokud chcete, můžete na ně upozornit v diskusi. Uvítám ale, pokud
se tam budou objevovat odkazy na místa, která jsou pro vás <span style="font-style: italic;">zvláště užitečná</span>, nebo která <span style="font-style: italic;">navštěvujete opakovaně</span>. <br>
</p>
<a name="000285"></a><h2>Projekty</h2>
<p>Existují rovněž projekty v PHP, jejichž studiem se toho můžete hodně
naučit. Následující tabulka shrnuje pár významnějších, jejich stručný
popis a co z nich pro Vás může být užitečné (pominu-li prostý fakt, že
můžete tyto projekty využít jako celek):<br>
</p>
<table style="text-align: left; width: 90%; border-collapse: collapse;" align="center" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Projekt<br>
      </td>
      <td style="vertical-align: top;">Popis<br>
      </td>
      <td style="vertical-align: top;">Hodí se na<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://www.phpmyadmin.net/home_page/">PHPMyAdmin</a><br>
      </td>
      <td style="vertical-align: top;">V PHP napsané webové rozhraní k
MySQL<br>
      </td>
      <td style="vertical-align: top;">Databázové funkce, export a
import dat, komprese zip, lokalizace<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://www.phpnuke.org/">PHP
- NUKE</a><br>
      </td>
      <td style="vertical-align: top;">Webový portál v PHP<br>
      </td>
      <td style="vertical-align: top;">Prakticky vše - design,
internacionalizace, content management, technologie plug-inů,
modularita, CSS, standardy...<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a href="http://www.squirrelmail.org/">Squirrel mail</a><br>
      </td>
      <td style="vertical-align: top;">Webový klient v PHP<br>
      </td>
      <td style="vertical-align: top;">Síťové protokoly, IMAP, SMTP,
MIME support, adresář. Kompatibilita napříč prohlížeči.<br>
      </td>
    </tr>
  </tbody>
</table>
<p>A opět - pokud jste se něco naučili studiem dalších projektů, můžete
se s námi o to podělit v diskusi. Ocením zjeména, když uvedete, v čem
konkrétně byl pro vás daný projekt přínosem a/nebo co jste se z něj
naučili.<br>
</p>
<p>V dalším díle seriálu začneme "od nuly" stavět skutečný webový
portál v PHP. Budeme postupovat krok za krokem a bude to práce na
několik dílů. Máte se na co těšit!</p>

<a name="000286"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (68) - Stavíme portál</h2>
			<p class="perex">Téma na více dílů - stavba portálu v PHP. A s příkladem funkčního webu.
				<br>
			</p>
			<p>Počínaje tímto dílem našeho seriálu zcela opustíme poněkud nudnou
šeď teorie PHP programování, a vrhneme se na praxi. V několika
následujících dílech totiž poslepujeme úplně nový web a projdeme přitom
všechny kroky, které byste měli v takové situaci mít na paměti.
Programování v PHP je dosti svázáno s dalšími technologiemi, takže
jeden větší příklad bude lepší než několik malých fragmentů kódu.</p>
<p>Je to samozřejmě dilema - čím kratší je příklad, tím spíše se můžete
soustředit na to, co opravdu řeší - ale čím je rozsáhlejší, tím spíše
pochopíte, jak spolu jednotlivé etapy práce a části kódu souvisejí.
Budeme tedy používat nejen PHP, ale HTML a MySQL (možná trochu i
styly). Navíc, budu se snažit představit vám jednotlivé kroky stavby
webu tak, jak v praxi opravdu probíhají. Tím by čtenář (zejména pokud s
webovou tvorbou začíná) měl získat alespoň základní představu o tom, <span style="font-style: italic;">co</span> a <span style="font-style: italic;">kdy</span> se má dělat.<br>
</p>
<a name="000287"></a><h2>Nebude to internetový obchod</h2>
<p>Ne! Internetové obchody dělá jako příklad na PHP každý. Navíc mi
(pokud se implementuje přihlašování i nakupování) přijdou pro
začátečníka poněkud obtížné na pochopení. Namísto toho zkusíme
naprogramovat web o nějaké vymyšlené hudební skupině. Bude to
prinicpiálně velmi jednoduché a nebudou v tom žádné záludnosti (účetní
věci, DPH apod.), které by internetový obchod zcela jistě provázely.<br>
</p>
<p>Jak jen to půjde, nebudeme se zabývat žádnými záležitostmi, které
přímo nesouvisejí s PHP. Naše "stránky" tedy nebudou mít žádnou nebo
téměř žádnou grafiku, abychom se soustředili na to, co nás opravdu
zajímá. Velmi málo (pokud vůbec) se budeme zabývat věcmi jako je
klientské skriptování nebo DHTML.<br>
</p>
<a name="000288"></a><h2>Zadání</h2>
<p>První věc, kterou byste si měli při návrhu webu ujasnit, je zadání.
My budeme tvořit web propagující smyšlenou hudební skupinu. Součástí
stránek bude následující funkcionalita:<br>
</p>
<ul>
  <li>rozhraní pro zadávání koncertů (datum, čas, místo konání) s tím,
že se budou ukládat v databázi a zobrazovat na webu</li>
  <li>diskografie - názvy alb a seznam písní na těchto albech<br>
  </li>
  <li>správu uživatelů (přihlašování, odhlašování, sekce "jen pro
členy"...)</li>
  <li>nějaký mechanismus pro zveřejňovaní textů písní, aby si je
později mohla kapela sama publikovat</li>
  <li>přihlášení členové si budou moci stahovat texty písní a dema <br>
  </li>
  <li>budeme počítat s tím, že si náš virtuální zadavatel může ještě na
něco vzpomenout a pokusíme se na to myslet <br>
  </li>
</ul>
<p>Jednotlivé body budeme chtít samozřejmě rozpitvat. Taktická -
poznámka: pokud by se jednalo o komerční věc, tohle je nejlepší udělat
spolu se zákazníkem. Tak tedy, rozhraní pro zadávání koncertů by mělo
umět následující věci:<br>
</p>
<ul>
  <li>Zadávat koncerty bude smět pouze uživatel s oprávněními
administrátora<br>
  </li>
  <li>Z formuláře se zadá datum, čas a místo koncertu, to bude uloženo
v databázi</li>
  <li>Na webu se budou zobrazovat pouze koncerty v budoucnosti (ne ty,
co už byly)</li>
  <li>Aplikační logika by neměla povolit zadat více než jeden koncert
denně</li>
</ul>
<p>Podsekce diskografie by měla mít následující funkce<br>
</p>
<ul>
  <li>Názvy alb a písní by se měly zadat do databáze</li>
  <li>Půjdou zobrazit buď jen alba, nebo alba a písně</li>
  <li>Vyhledávání - podle názvu písně najít album nebo alba, na nichž
byla uvedena<br>
  </li>
  <li>Jedna píseň bude moci být na více albech</li>
</ul>
<p>Správa uživatelů by měla mít následující funkce:<br>
</p>
<ul>
  <li>Uživatel se bude moci zaregistrovat pomocí přezdívky, e-mailu a
hesla</li>
  <li>Heslo by mělo mít minimálně 4 znaky</li>
  <li>Aplikační logika by měla povolit pouze jednoho uživatele na jeden
e-mail</li>
  <li>Aplikace by měla umět odeslat zapomenuté heslo (max. 1x denně),
změnit heslo a zrušit registraci</li>
</ul>
<p>Zveřejňování textů písní by mělo mít následující vlastnosti:<br>
</p>
<ul>
  <li>Půjde zveřejnit jen text k písni, která již je v databázi</li>
  <li>Bude to moci dělat jen administrátor</li>
  <li>Text písně se bude dát exportovat do textového souboru</li>
  <li>Texty písní budou k dispozici jen pro registrované uživatele</li>
</ul>
<p>Trochu jsem to rozepsal - zejména abych předvedl, jak je důležité
mít "cílový koncept". Asi si umíte představit, že kdybyste tento seznam
tvořili se zákazníkem, mohl by být daleko rozsáhlejší. A taky si asi už
v téhle chvíli umíte představit, co by se stalo, kdybyste začali
pracovat bez ujasnění těchto základních pravidel hry.<br>
</p>
<p style="font-style: italic;">Pozn.: Pokud se jedná o komerční
záležitost, jen naprostý sebevrah by byl schopen zkalkulovat cenu
předtím, než udělá nějaký podobný cílový koncept. Profík si naopak
vyhradí, že s každou změnou funkcionality se znovu probere otázka
financí.<br>
</p>
<a name="000289"></a><h2>Technický rozbor</h2>
<p>Teď není chvíle, kdy bychom měli "přijít od zákazníka, sednout a
psát", nýbrž chvíle pro nějakou tu technologickou poradu. Samozřejmě,
že aplikace bude vyžadovat skriptování na straně serveru - jasně volíme
PHP. Bude potřeba databáze (minimálně na uložení alb, písní, textů a
uživatelů). Zvolíme tedy (například) MySQL. Možná budeme potřebovat
poshánět nějaký ten software - už jsme o tom <a href="#000009">psali</a>. <a href="#000252">Další věci
ke zvážení</a>.<br>
</p>
<p>Teď něco z HTML. Budeme potřebovat stanovit, jaký typ dokumentu
vlastně vyvíjíme - zda HTML, XHTML a jakou verzí specifikace se přitom
budeme chtít řídit. To je nesmírně důležité, protože náš kód by měl být
vždy validní (<a href="http://www.linuxsoft.cz/article.php?id_article=450">psal</a> o
tom <a href="http://www.linuxsoft.cz/user_page.php?user_id=936">Luboš
Turek</a>). Dobrý rozbor této problematiky najdete <a href="http://wellstyled.com/html-doctype-and-browser-mode.html">zde</a>.
<br>
</p>
<p>Aplikace by měla už od prvopočátku mít nějakou koncepci rozvržení,
tzv. layoutu. V zásadě se na každý složitější site použije některá ze
tří následujících technologií:<br>
</p>
<ul>
  <li>Organizace pomocí rámů</li>
  <li>Layout pomocí tabulek</li>
  <li>Formátování pomocí <a href="http://www.linuxsoft.cz/article_list.php?id_kategory=201">kaskádových
stylů</a></li>
</ul>
<p>Každý z těchto způsobů má své zastánce, pěkně to shrnuje <a href="http://www.linuxsoft.cz/article.php?id_article=424">článek</a>
Pavla Káchy. Formálně je nejsprávnější použít technologii kaskádových
stylů, protože právě za tímto účelem byla vyvinuta. My použijeme
tabulky, protože to bude pro výklad některých pasáží názornější než CSS.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Pokud to s tvorbou webu
myslíte vážně, rozhodně uvažujte o kaskádových stylech. Je to
budoucnost webdesignu. Jednou větou - styly nejlépe umožňují oddělit
obsah stránek od formy.<br>
</span></p>
<p>V dalším díle seriálu si poslepujeme "kostru" našeho webu a ujasníme
si, jak vyřešíme navigaci mezi jednotlivými částmi stránek.</p>

<a name="000290"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (69) - Stavíme portál 2.</h2>
			<p class="perex">Dnes budeme pokračovat v programování našeho virtuálního hudebního portálu.
				<br>
			</p>
			<p>V minulém díle jsme načali tvorbu portálu pro virtuální hudební
skupinu. Dnes si ukážeme, jak na takovém portálu realizovat navigaci
mezi jednotlivými částmi webu. Uvidíme rovněž, že již v této fázi
návrhu se dají použít některé "osvědčené triky" ostřílených
webdesignérů.<br>
</p>
<a name="000291"></a><h2>Kódování a typ dokumentu</h2>
<p>V navázání na předchozí díl se (například) rozhodneme, že budeme
používat kódování utf-8. Tím bychom se měli zcela vyhnout problémům s
češtinou. Jiná dobrá volba je iso-8859-2. Pokud máte pocit, že byste
své stránky chtěli kódovat v čemkoli jiném, zvažte to. Většinou pro to
není důvod. Rovněž se rozhodneme použít (například) typ dokumentu HTML
4.0 Transitional. Odpovídající DOCTYPE a meta-tag můžeme do dokumentu
hned zapsat. Informace můžete čerpat ze seriálu Pavla Káchy <a href="http://www.linuxsoft.cz/article.php?id_article=185">zde na
Linuxsoftu</a>.<br>
</p>
<p></p>
<a name="000292"></a><h2>Rozvržení stránky</h2>
<p>Minule jsem slíbil, že náš portál bude mít tabulkový layout. Ten
navrhneme z výukových důvodů co možná nejjednodušší. Stránka tedy bude
tvořena tabulkou, která bude centrovaná a bude mít jednu širokou buňku
v prvním řádku jako záhlaví a dvě užší buňky ve druhém řádku jako tělo
(viz obrázek).<br>
</p>
<p style="text-align: center;"><img style="width: 150px; height: 150px;" alt="layout" src="img/table_design.jpg"><br>
</p>
<p>V levé buňce budeme mít seznam odkazů a v pravé buňce budeme
zobrazovat vlastní obsah webu. Takže, například po kliknutí na odkaz
Diskografie se nám v buňce vpravo otevře příslušný text s alby a
písněmi. Startovací soubor webu index.php bude tedy obsahovat tabulku:</p>
<!-- Zaza PHP kod BEGIN -->
<div class="codes"><code><font color="#000000">&lt;!DOCTYPE HTML PUBLIC
"-//W3C//DTD HTML 4.0 Transitional//EN"&gt;<br>
&lt;html&gt;<br>
&nbsp;&nbsp;&lt;head&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Web virtuální kapely<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/title&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;meta http-equiv="Content-Type"
content="text/html; charset=utf-8"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;style type="text/css"
title="text/css"&gt;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt;<br>
&nbsp;&nbsp;&lt;/head&gt;<br>
&nbsp;&nbsp;<font color="#0000bb">&lt;?</font><font color="#007700">require
</font><font color="#dd0000">"./func.php"</font><font color="#007700">;</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&lt;body&gt;<br>
&nbsp;&nbsp;&lt;div align="center"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;table width="760" cellpadding="0"
cellspacing="0" border="1"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td width="760"
height="120" colspan="2"&gt;&lt;img src="./images/top.jpg" width="760"
height="120"&gt;&lt;/td&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td width="160"
valign="top"&gt;<font color="#0000bb">&lt;?</font><font color="#007700">require
</font><font color="#dd0000">"./navigace.php"</font><font color="#0000bb">?&gt;</font>&lt;/td&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td width="600"
valign="top"&gt;<font color="#0000bb">&lt;?ukazclanek</font><font color="#007700">()</font><font color="#0000bb">?&gt;</font>&lt;/td&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/table&gt;<br>
&nbsp;&nbsp;&lt;/div&gt;<br>
&nbsp;&nbsp;&lt;/body&gt;<br>
&lt;/html&gt;<br>
<br>
</font></code></div>
<!-- Zaza PHP kod END -->
<p>Cílem tohoto přístupu je udržet skript index.php co nejmenší,
protože bude obsahovat <span style="font-style: italic;">pouze </span>rozvržení.
Všimněte si, že vkládáme soubor
s funkcemi <a href="./examples/musicweb/1/func.html">func.php</a>
a soubor s navigací <a href="./examples/musicweb/1/navigace.html">navigace.php</a>.
V souboru s func.php je funkce ukazclanek(), která zahrnuje určitou
aplikační logiku:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">ukazclanek
</font><font color="#007700">()<br>
{ <br>
&nbsp;&nbsp;if ((string)</font><font color="#0000bb">$_REQUEST</font><font color="#007700">[</font><font color="#dd0000">"clanek"</font><font color="#007700">]&lt;&gt;</font><font color="#dd0000">''</font><font color="#007700">) </font><font color="#0000bb">$mujclanek</font><font color="#007700">=</font><font color="#0000bb">$_REQUEST</font><font color="#007700">[</font><font color="#dd0000">"clanek"</font><font color="#007700">]; else </font><font color="#0000bb">$mujclanek</font><font color="#007700">=</font><font color="#dd0000">"uvod"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">is_file</font><font color="#007700">(</font><font color="#dd0000">"./"</font><font color="#007700">.</font><font color="#0000bb">$mujclanek</font><font color="#007700">.</font><font color="#dd0000">".htm"</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><font color="#0000bb">$nazevclanku</font><font color="#007700">=</font><font color="#0000bb">$mujclanek</font><font color="#007700">.</font><font color="#dd0000">".htm"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; require </font><font color="#0000bb">$nazevclanku</font><font color="#007700">;<br>
&nbsp; &nbsp; elseif (</font><font color="#0000bb">is_file</font><font color="#007700">(</font><font color="#dd0000">"./"</font><font color="#007700">.</font><font color="#0000bb">$mujclanek</font><font color="#007700">.</font><font color="#dd0000">".php"</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$nazevclanku</font><font color="#007700">=</font><font color="#0000bb">$mujclanek</font><font color="#007700">.</font><font color="#dd0000">".php"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; require </font><font color="#0000bb">$nazevclanku</font><font color="#007700">;<br>
&nbsp; &nbsp; else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$nazevclanku</font><font color="#007700">=</font><font color="#0000bb">$mujclanek</font><font color="#007700">.</font><font color="#dd0000">".htm"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; require </font><font color="#dd0000">"notfound.php"</font><font color="#007700">;<br>
&nbsp;&nbsp;endif;<br>
}<br>
</font><font color="#0000bb">?&gt;<br>
</font><br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Cílem je, aby odkaz ve stylu <span style="font-style: italic;">index.php?clanek=uvod</span>
našel nejprve soubor <span style="font-style: italic;">uvod.htm</span>,
neexistuje-li pak <span style="font-style: italic;">uvod.php</span> a
nakonec (není-li k dispozici ani ten) soubor s chybovým hlášením (my
jsme jej nazvali notfound.php). A teď to nejlepší - pomocí funkce
require umístíme soubor uvod.htm (nebo výstup skriptu uvod.php) do naší
buňky v pravé části tabulky a základní navigace je hotova.</p>
<p><span style="font-style: italic;">Pozn.: Ještě detail. Jestliže se
skript index.php zavolá bez argumentů, bude funkce ukazclanek
automaticky předpokládat, že chceme zobrazit úvodní stranu celé
aplikace.<br>
</span></p>
<p>Soubor navigace.php si asi již umíte představit. Obsahuje odkazy ve
stylu index.php?clanek=[název článku] a díky navigační logice je již
zajištěno, že se požadované informace objeví v pravé části tabulky. Ve
skutečnosti toho jde dělat daleko víc - jiná navigace může být
zobrazena, pokud je přihlášen nějaký uživatel, pro administrátora může
být načten jiný layout a podobně.<br>
</p>
<a name="000293"></a><h2>Pár tipů k rozložení</h2>
<ul>
<li>Pokud má být někde obrázek, osvědčilo se mi vyrobit dočasný
obrázek spíše, než nechat místo prázdné. Dříve a snáze tak totiž
odhalíte případné chyby v rozvržení stránky (nebo spíše chyby v
interpretci norem u některých prohlížečů).</li>
<li>Pokud používáte tabulkový layout, nechte po dobu vývoje nastavené
zobrazování okrajů tabulky (border). Budete tak mít představu o tom, co
je kde umístěno.</li>
<li>Nikdy nedělejte zároveň práce na PHP - aplikační logice a zároveň
na layoutu. Většinou to skončí výrobou "omalovánky", která se následně
zahodí.</li>
</ul>
<p>V dalším díle se podrobně podíváme na známý problém "jak určit, čím
začít" a napíšeme první "velké" skripty na tomto webu. Návrh v
podobě, jak jsme jej dnes přednesli si můžete <a href="./examples/1.zip">stáhnout</a>.
</p>
<a name="000294"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (70) - Registrace uživatelů na portálu</h2>
			<p class="perex">Dnes si ukážeme, jak by se dala na portálu pomocí PHP provádět registrace uživatelů.
				<br>
			</p>
			<p>Poté, co jsme vyřešili základní navigaci, budeme dnes pokračovat v
našem hudebním portálu věcmi, které zajistí jeho funkcionalitu. Pojďme
si nejprve projít zadání a rozhodnout se, čím začít.<br>
</p>
<a name="000295"></a><h2>Čím začít<br>
</h2>
<p>V předminulém díle seriálu jsme si stanovili jakýsi cílový koncept
celé aplikace. Když si jej pořádně <a href="#000286">přečtete</a>,
zjistíte, že se skládá ze čtyř hlavních věcí - koncerty, diskografie,
texty písní a uživatelé. Texty písní mají být k dispozici pouze
registrovaným uživatelům, zadávat koncerty smí jen uživatel -
administrátor. Z toho vyplývá, že by bylo praktické začít nějakými
skripty pro uložení uživatelů, abychom na to později mohli navázat.<br>
</p>
<p>Připomeňme, že s uživatelem by portál měl být schopen provádět
následující kousky:<br>
</p>
<ul>
<li>registrace (přezdívka, mail, heslo)<br>
</li>
<li>změna hesla</li>
<li>odeslání zapomenutého hesla</li>
<li>zrušení registrace</li>
</ul>
<p>Budeme postupovat tak, že každou z akcí bude realizovat nějaký PHP
skript. Celkem budeme tedy mít 4 skripty, které se budou jmenovat
registrace.php, zmenahesla.php, zapomenuteheslo.php a
zruseniregistrace.php.<br>
</p>
<p style="font-style: italic;">Pozn.: V praxi byste možná zvolili
kratší názvy souborů. Někdo se rovněž rozhodne používat anglické názvy
ve stylu useradd, userdel a podobně. My to uděláme takto z výukových
důvodů.<br>
</p>
<a name="000296"></a><h2>Databáze</h2>
<p>Je jasné, že na uložení informací o uživatelích bude sloužit jedna
tabulka v databázi mysql. Když se nad tím zamyslíte, bude potřeba
ukládat následující věci:</p>
<ul>
<li>přezdívku uživatele</li>
<li>jeho e-mail</li>
<li>jeho heslo</li>
</ul>
<p>Nicméně, pokud se nad tím zamyslíte trochu hlouběji, zjistíte
rovněž, že přímo do této tabulky bychom mohli ukládat informaci o tom,
zda je daný uživatel administrátorem (můžete mít více administrátorů).
Stejně tak z potřeby na odeslání zapomenutého hesla maximálně 1x denně
vyplývá, že bude užitečné sledovat datum a čas, kdy se naposledy
odesílalo zapomenuté heslo, a patří to logicky do téže tabulky. <br>
</p>
<p>Nebudeme chtít, aby se uživatelé přihlašovali pod falešným e-mailem,
takže instrukce pro dokončení registrace budou zaslány na uvedený
e-mail a my budeme považovat registraci za úspěšnu pouze v případě, kdy
uživatel splní instrukce z e-mailu. Pro databázi to znamená, že
zavedeme pole registracedokoncena, které nastavíme až v případě, že si
uživatel přečte instrukce z mailu, který při registraci uvedl a provede
je. Rovněž teprve poté budeme považovat registraci za dokončenou.</p>
<p>V praxi
ještě bývá zvykem mít možnost dočasně znemožnit uživateli přihlášení
pomocí nějakého příznaku u jeho záznamu v databázi, například pokud
uživatel příliš obtěžuje v diskusích. Z důvodů souvisejících z databází
bude rovněž užitečné jednotlivé řádky číslovat pomocí sloupce s
automatickým přírůstkem. Celkem shrnuto budeme mít tedy 8 polí a SQL
příkaz pro návrh tabulky by potom mohl vypadat následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">CREATE TABLE `uzivatele`
(<br>
`id` INT NOT NULL AUTO_INCREMENT ,<br>
`prezdivka` VARCHAR( 50 ) NOT NULL ,<br>
`email` VARCHAR( 50 ) NOT NULL ,<br>
`heslo` VARCHAR( 10 ) NOT NULL ,<br>
`jeadmin` TINYINT DEFAULT '0' NOT NULL ,<br>
`pripomenuto` DATETIME NULL ,<br>
</font></code><code><font color="#000000">`registracedokoncena` TINYINT
DEFAULT '0' NOT NULL ,</font></code><br>
<code><font color="#000000">`jeblokovan` TINYINT DEFAULT '0' NOT NULL ,<br>
PRIMARY KEY ( `id` )<br>
);</font>
</code></div>
<!-- Zaza PHP kód END -->
<p><span style="color: rgb(255, 0, 0);">Asi jste si všimli, že v
databázi ukládáme heslo tak, jak jej uživatel zadal. To je z principu
dost nebezpečné. Návod, jak to udělat lépe, byl v seriálu již </span><a style="color: rgb(255, 0, 0);" href="#000191">popsán</a><span style="color: rgb(255, 0, 0);">. Dělám to kvůli jednoduchosti.</span><br>
</p>
<a name="000297"></a><h2>Registrační skript</h2>
<p>Registrační skript registrace.php by měl obsahovat především
formulář pro zadání přezdívky, jména a hesla. To se následně
odkontroluje a uloží do databáze. Na e-mail uvedený v registraci bude
zaslána zpráva obsahující url, které musí uživatel navštívit, aby byla
jeho registrace dokončena. Jakmile toto url uživatel navštíví, v
databázi nastavíme příznak 'registracedokoncena' na jedničku a uživatel
se bude moci přihlásit.<br>
</p>
<p>Při tvorbě formuláře si vypůjčím informace z <a href="#000105">25. dílu
našeho seriálu</a> (o zpracování formulářů), takže pokud jste jej
nečetli, možná je ten správný čas udělat to nyní. Při odeslání
formuláře budeme provádět následujících 5 kontrol, než jej prohlásíme
za správně vyplněný:<br>
</p>
<ul>
<li>zda zadaný údaj e-mail obsahuje platný formát e-mailu<br>
</li>
<li>zda tam již e-mail není</li>
<li>zda tam již přezdívka není</li>
<li>zda je přezdívka mezi 3 a 50 znaky délky</li>
<li>zda je heslo 3 až 50 znaků dlouhé</li>
</ul>
<p>Skript
trochu jej okomentuji. Vlastní formulář je zabalen do tabulky, aby byl
na stránce alespoň trochu zarovnán. Jakmile uživatel vyplní požadovné
údaje, provede se několik věcí:<br>
</p>
<ol>
<li>Nejprve se zadané údaje zkontrolují. Všimněte si, že na kontrolu
toho, zda zadaná přezdívka či e-mail již nejsou v databázi obsaženy
jsem sestavil dvě samostatné funkce emailvdb a prezdivkavdb. <br>
</li>
<li>Pokud kontrolou projdeme, především uživateli poděkujeme za jeho
snahu a řekneme mu, že zbytek informací má v e-mailu.</li>
<li>Následně vložíme e-mail, přezdívku a heslo do databáze. V tabulce
uzivatele vznikne nový řádek. Pole jeadmin, registracedokoncena a
jeblokovan se přitom nastaví na nulu, protože to je jejich výchozí
hodnota (a žádné konkrétnější zadání jsme neupřesnili). Pole id se
nastaví na nejnižší nepoužité id v tabulce (o tyto "drobnosti" se stará
mysql).</li>
<li>Pomocí funkce mysql_insert_id si zjistíme id posledně vloženého
řádku</li>
<li>Sestavíme e-mail obsahující instrukci, že k dokončení registrace
uživatel musí navštívit danou stránku a tento e-mail odešleme</li>
<li>Skript <a href="./examples/musicweb/2/registracedokoncena.html">registracedokoncene.php</a>
se postará o to, že daný uživatel bude mít v databázi příznak
registracedokoncena nastaven na jedničku, protože je jasné, že četl
zaslaný e-mail a tudíž jeho e-mailová adresa je platná a funkční.</li>
</ol>
<p>Projekt v současném stavu si můžete <a href="./examples/2.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span></p>
<a name="000298"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (71) - Přihlašování uživatelů na portál</h2>
			<p class="perex">Tož, uživatele již máme. Pojďme je tedy přihlásit (a odhlásit) z našeho výcvikového portálu.
				<br>
			</p>
			<p>Dnes na náš portál doplníme funkci pro přihlašování a odhlašování
uživatelů, které jsme si v předchozím díle seriálu vytvořili. Uvidíte,
že to nemusí být až tak jednoduché, jak to na první pohled může vypadat.<br>
</p>
<p>Pozn.: Množí se dotazy, zda demoverze portálu bude umět všechny
popisované funkce - ano, bude. Takže si skutečně můžete založit "účet"
a testovat to s námi. Jak budou v jednotlivých dílech přibývat funkce,
tak bude příklad upravován, aby vždy fungoval tak, jak je v článku
vysvětleno.</p>
<p></p>
<a name="000299"></a><h2>Rozbor<br>
</h2>
<p>Jednoduše - v odkazech v levé části stránky je položka Přihlásit. Ta
povede na skript, který bude zajišťovat přihlašování uživatelů.
Jestliže bude uživatel již přihlášen, změní se text odkazu z
"Přihlásit" na "Odhlásit" a odkaz povede na skript pro odhlášení. Časem
možná budeme chtít někde vypsat, kdo je aktuálně přihlášen (alespoň
přezdívku), takže bychom na to již v této fázi měli myslet na o
přihlášeném uživateli bychom si měli uložit na dobře dostupné místo
nějaké informace.</p>
<a name="000300"></a><h2>Přihlašování uživatelů</h2>
<p>Teď napíšu něco triviálního - pro přihlášení bude muset uživatel
znát přezdívku a heslo. Takže přihlašovací skript (nazveme si jej třeba
prihlaseni.php) bude pochopitelně obsahovat formulář pro zadání
přezdívky a hesla a při ověřování je musí porovnat s údaji v databázi.
Podstatnou část formuláře přitom můžeme opsat z minulého dílu - z
formuláře pro registraci.<br>
</p>
<p>Co je nové a co se musí nějak rozhodnout je následující věc: co
udělat s uživatelem, jehož přihlašovací údaje souhlasí? Tento údaj je
od nynějška nutné vést v patrnosti, a to tak dlouho, dokud se uživatel
neodhlásí. Navíc, je tuto skutečnost nutné nějak sdělit všem
následujícím stránkám, které uživatel před svým odhlášením navštíví.
Takové věci se dají udělat například pomocí cookies nebo pomocí
sessions. <a href="#000222">Jedno</a>
i <a href="#000228">druhé</a>
jsme již v seriálu rozebírali. <br>
</p>
<p>Zvolíme například sessions. Jako praktické se mi ukázalo nejen
evidovat <span style="font-style: italic;">zda </span>je nějaký
uživatel přihlášen, ale rovněž <span style="font-style: italic;">jaký </span>to
je uživatel. Pravděpodobně si vzpomínáte, že v minulém díle jsme v
tabulce uživatelů definovali pole ID, které se automaticky zvyšuje o
jedničku s každým novým uživatelem. Právě toto pole pro daného
uživatele budeme ukládat do session proměnné $_SESSION["id"] a tak
budeme mít uživatele jednoznačně určeného.<br>
</p>
<p>Neboli, po úspěšném přihlášení se skript postará o to, aby v
proměnné $_SESSION["id"] byl identifikátor aktuálního uživatele.
Ověřovací část skriptu prihlaseni.php potom může vypadat nějak takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">function </font><font color="#0000bb">iduzivatele
</font><font color="#007700">(</font><font color="#0000bb">$prezdivka</font><font color="#007700">, </font><font color="#0000bb">$heslo</font><font color="#007700">, </font><font color="#0000bb">$link</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select id from
uzivatele where prezdivka='"</font><font color="#007700">.</font><font color="#0000bb">$prezdivka</font><font color="#007700">.</font><font color="#dd0000">"' and heslo='"</font><font color="#007700">.</font><font color="#0000bb">$heslo</font><font color="#007700">.</font><font color="#dd0000">"'"</font><font color="#007700">, </font><font color="#0000bb">$link</font><font color="#007700">);<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)==</font><font color="#0000bb">0</font><font color="#007700">) <br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">false</font><font color="#007700">; <br>
&nbsp;&nbsp;else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$radek </font><font color="#007700">= </font><font color="#0000bb">mysql_fetch_array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">$radek</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">];<br>
&nbsp;&nbsp;}<br>
}&nbsp;&nbsp;<br>
</font><font color="#ff8000">// tělo skriptu - nejprve si vytvoříme
odkaz na databázi<br>
</font><font color="#0000bb">$link</font><font color="#007700">=</font><font color="#0000bb">mysql_connect</font><font color="#007700">(</font><font color="#0000bb">SQL_HOST</font><font color="#007700">, </font><font color="#0000bb">SQL_USERNAME</font><font color="#007700">, </font><font color="#0000bb">SQL_PASSWORD</font><font color="#007700">);<br>
</font><font color="#0000bb">mysql_select_db</font><font color="#007700">(</font><font color="#0000bb">SQL_DBNAME</font><font color="#007700">);<br>
<br>
</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">true</font><font color="#007700">;<br>
if (!empty(</font><font color="#0000bb">$_POST</font><font color="#007700">)) </font><font color="#ff8000">// už se odeslalo<br>
</font><font color="#007700">{<br>
&nbsp;&nbsp;</font><font color="#0000bb">$id </font><font color="#007700">=</font><font color="#0000bb">iduzivatele</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"prezdivka"</font><font color="#007700">], </font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"heslo"</font><font color="#007700">], </font><font color="#0000bb">$link</font><font color="#007700">);<br>
&nbsp;&nbsp;if (!</font><font color="#0000bb">$id</font><font color="#007700">) echo </font><font color="#dd0000">"Uživatelské
jméno a/nebo heslo nesouhlasí"</font><font color="#007700">;<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">]= </font><font color="#0000bb">$id</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
}<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Bude tento přístup fungovat? Sám o sobě jistě fungovat bude. Problém
je, že údaj o tom, že se přihlášení zdařilo budeme mít k dispozici až v
okamžiku vyhodnocení funkce iduzivatele(). Pečlivý čtenář si jistě
všimne, že tato funkce je až ve skriptu prihlaseni.php. To může vadit a
nemusí. Kdybychom například ihned po přihlášení chtěli v souboru
navigace.php změnit příkaz "Přihlásit" na "Odhlásit" a zapsat něco ve
smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?</font><font color="#007700">if (isset(</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])):</font><font color="#0000bb">?&gt;<br>
</font>&lt;p&gt;&lt;a
href="index.php?clanek=odhlaseni"&gt;Odhlásit&lt;/a&gt;&lt;/p&gt;<br>
<font color="#0000bb">&lt;?</font><font color="#007700">else:</font><font color="#0000bb">?&gt;<br>
</font>&lt;p&gt;&lt;a
href="index.php?clanek=prihlaseni"&gt;Přihlásit&lt;/a&gt;&lt;/p&gt;<br>
<font color="#0000bb">&lt;?</font><font color="#007700">endif</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>tak to NEBUDE fungovat podle očekávání. Důvod je prostý - soubor
navigace.php se totiž do výsledné stránky vkládá dřív než soubor
prihlaseni.php a chudák navigace.php nemá ani ponětí, že budeme
nastavovat nějakou session proměnnou, tatož aby věděl, jaká bude její
hodnota. Takže kdybyste upravili soubor navigace.php podle receptu
uvedeného výše, bude to fungovat až po opětovném načtení stránky.<br>
</p>
<p>Jelikož to vypadá neprofesionálně, zkusíme to trochu vylepšit. Trik
spočívá v tom, že když se budeme přihlašovat (a následně rovněž
odhlašovat), provede se nastavení (nebo zrušení) proměnné
$_SESSION["id"] jako úplně první věc ve skriptu, ještě <span style="font-style: italic;">předtím</span>, než se začne zpracovávat
soubor navigace.php. My to ve výukovém příkladu celé umístíme rovnou do
souboru index.php, dalo by se to však i včlenit jako samostatný soubor.
<a href="./examples/musicweb/3/index.html">Podívejte se</a>,
jak nyní vypadá soubor index.php.<br>
</p>
<a name="000301"></a><h2>Odhlašování</h2>
<p>Uvědomme si, že "přihlášení" znamenalo pro náš skript dvě věci:</p>
<ul>
  <li>Odkontrolovalo se, zda údaje souhlasí s databází</li>
  <li>Pokud ano, nastavila se session proměnná $_SESSION["id"]</li>
</ul>
<p>Proto je proces "odhlašování" velmi jednoduchý. Nic se kontrolovat
nemusí, a opravdu tedy stačí zrušit nastavení proměnné $_SESSION["id"].
Což uděláme rovněž ve skriptu index.php. V tu chvíli již zbytek stránky
bude vědět o tom, že jsme se odhlásili.<br>
</p>
<a name="000302"></a><h2>Změny na portálu</h2>
<p>Přijde mi praktické okomentovat nějak všechny změněné soubory, takže
se o to počínaje tímto dílem pokusím:<br>
</p>
<p>Nové soubory: <br>
</p>
<ul>
  <li><a href="./examples/musicweb/3/odhlaseni.html">odhlaseni.php</a>
  </li>
  <li><a href="./examples/musicweb/3/prihlaseni.html">prihlaseni.php</a></li>
</ul>
<p>Změněné soubory:<br>
</p>
<ul>
  <li><a href="./examples/musicweb/3/index.html">index.php</a>
- nastartování session, aplikační logika pro přihlašování a odhlašování
a přesunutí vloženého souboru výše v těle skriptu<br>
  </li>
  <li><a href="./examples/musicweb/3/navigace.html">navigace.php</a>
- viz článek<br>
  </li>
  <li><a href="./examples/musicweb/3/func.html">func.php</a>
- přidána funkce iduzivatele pro zjištění, zda má správné heslo</li>
</ul>
<p>Projekt v současném stavu si můžete <a href="./examples/3.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span>
</p>
<a name="000303"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (72) - Hrátky s uživateli</h2>
			<p class="perex">Dnes se na našem výcvikovém portále naučíme odesílat zapomenutá hesla, měnit hesla a rušit uživatelské registrace.
				<br>
			</p>
			<p>Na našem výukovém hudebním portále již umíme uživatele
zaregistrovat, přihlásit jej a odhlásit. Dnes dokončíme práci na správě
uživatelů tím, že se zamyslíme nad odesíláním zapomenutého hesla,
změnou hesla a nad zrušením registrace.
</p>
<a name="000304"></a><h2>Zapomenuté heslo</h2>
<p>
U zapomenutého hesla bude nejlepší, když se pokusíme
uvažovat jako uživatel. Kdy vlastně bude chtít uživatel odeslat
zapomenuté heslo? Bude to pochopitelně v momentě, kdy není přihlášen, a
pečlivým rozborem zjistíme, že to může nastat minimálně ve dvou
případech:
</p>
<ul>
<li>když se uživatel pokusí přihlásit pod správným jménem, ale
špatným heslem</li>
<li>když se uživatel pokusí znovu se registrovat na již existující
e-mail</li>
</ul>
<p>
Jak mu heslo připomeneme? Heslo je v databázi uloženo v tabulce
uzivatele společně s přezdívkou a
e-mailem, přičemž přezdívka i e-mail musejí být v rámci tabulky
uživatelů jednoznačné.
To hlídá již skript registrace.php. Takže k připomenutí hesla nám stačí
znát přezdívku <span style="font-style: italic;">nebo</span> e-mail a
můžeme zapomětlivému uživateli jeho heslo poslat. </p>
<p>Uvědomme si, že aby byl celý skript trochu uživatelsky přítulný,
neměl by požadovat vyplnění většího množství informací, než je nutné. V
praxi nám postačí sestavit formulář s jedním polem, a programátorsky z
něj pak zjistit, zda obsahuje přezdívku nebo zda jde o e-mail.
Použijeme přitom
následující úvahu:
Pokud v předaném řetězci není zavináč, nemůže to být e-mail (protože to
jsme již kontrolovali při založení účtu) a budeme tudíž prohledávat
přezdívky. Na druhou stranu, pokud předaný řetězec bude obsahovat
zavináč, může to být jak e-mail, tak i přezdívka. Prohledáme nejprve
e-maily, a když nic nenajdeme podíváme se v druhém kole na přezdívky. V
každém případě vrátíme buď ID nalezeného uživatele, nebo hodnotu false
pokud se nic nenašlo.
</p>
<p style="font-style: italic;">Pozn.: Vracení ID nebo hodnoty false si
klidně můžeme dovolit, neb bezpečně víme, že žádný uživatel nemůže
mít ID rovnající se nule (což by s hodnotou false kolidovalo). Víme to
proto, že jsme v definici tabulky uživatelů nastavili automatické
číslování, a to začíná ve výchozím stavu od jedničky.<br>
</p>
<p>
Celý skript si můžete prohlédnout <a href="./examples/musicweb/4/zapomenuteheslo.html">zde</a>.
Mohla by Vás tam překvapit funkce pripomenutozid, která z databáze
zjišťuje údaj o tom, zda a kdy jsme uživateli naposledy odesílali
zapomenuté heslo. My to chceme dělat maximálně jednou denně. Jak můžete
vidět, je při odeslání hesla údaj o čase do databáze ukládán jako
výsledek
funkce <a href="http://dev.mysql.com/doc/mysql/en/Date_and_time_functions.html">now()</a>.
Ta není tak dobrá, jak bychom potřebvali, protože ukládá datumy de
facto jako čísla
reprezentující řetězec. Jejich rozdíl vracíme pomocí mysql funkce
unix_timestamp, která je převede na vzájemně porovnatelná čísla. <br>
</p>
<p style="font-style: italic;">Pozn.: Další dobré řešení je ukládat
rovnou datumy jako unixová časová razítka. Asi se ptáte, proč jsem to
neudělal. Ono to má zase nevýhodu - na první juknutí nelze tento údaj
přepočítat na datum, takže funkce se dost špatně ladí.
</p>
<p>Navíc
může nastat situace, kdy se heslo nepřipomínalo ještě <span style="font-style: italic;">nikdy</span> a údaj pripomenuto z tabulky
uživatelů vrátí hodnotu NULL. Hodnota NULL bude v databázi z toho
prostého důvodu, že to je výchozí hodnota a žádnou hodnotu jsme při
registraci uživatele nespecifikovali. V takovém případě samozřejmě
<span style="font-style: italic;">chceme
</span>zapomenuté heslo odeslat.
</p>
<p style="font-style: italic;">Pozn.: Hodnota NULL se rozšiřuje skrze
výrazy. Proto si můžeme dovolit předpokládat, že rozdíl číslo-NULL =
NULL a na to náš skript spoléhá.
</p>
<p>Zbývá jediné - vložit odkaz pro skript na ta "správná" místa. To
bude jednak při špatném přihlášení ve skriptu prihlaseni.php, kam
přidáme jeden řádek kódu:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">//...<br>
&nbsp;&nbsp;</font><font color="#007700">if (!isset(</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])) <br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Uživatelské
jméno a/nebo heslo nesouhlasí "</font><font color="#007700">;<br>
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;echo </span></font><font style="font-weight: bold;" color="#dd0000">"(&lt;a
href=\"index.php?clanek=zapomenuteheslo\"&gt;připomenout
heslo&lt;/a&gt;)"</font><font color="#007700"><span style="font-weight: bold;">;</span><br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else <br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Přihlášen "</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"prezdivka"</font><font color="#007700">];<br>
&nbsp;&nbsp;}&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#ff8000">// atd...<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>A jednak při pokusu použít existující login pro novou registraci. To
bude v souboru registrace.php v části, v níž kontrolujeme jednoznačnost
přezdívky:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#ff8000">//...<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">elseif (</font><font color="#0000bb">prezdivkavdb </font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"prezdivka"</font><font color="#007700">], </font><font color="#0000bb">$link</font><font color="#007700">)) <br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Uvedená
přezdívka je již registrována "</font><font color="#007700">;<br>
<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo
</span></font><font style="font-weight: bold;" color="#dd0000">"(&lt;a
href=\"index.php?clanek=zapomenuteheslo\"&gt;připomenout
heslo&lt;/a&gt;)"</font><font color="#007700"><span style="font-weight: bold;">;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;</font><font color="#ff8000">// atd...<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<a name="000305"></a><h2>Změna hesla</h2>
<p>
Tuto část portálu nebudeme nijak komplikovat; postačí nám, když
uživatel zadá nové heslo a odešle formulář - to provede aktualizační
skript v databázi a je to. V praxi bývá zvykem připojit ještě dvě
vychytávky, a to:
</p>
<ol>
<li>Nové heslo se musí zadat dvakrát a skript kontroluje, zda to
souhlasí. Což je ochrana proti překlepu.</li>
<li>Před zadáním nového hesla se ještě musí zadat to původní, aby se
náhodou nestalo, že přihlášený uživatel odběhne od svého stroje a
škodolibý kolega mu mezitím heslo změní. <br>
</li>
</ol>
<p>
My se spokojíme s jednoduchým formulářem, který bude uložen a
zpracováván ve skriptu <a href="./examples/musicweb/4/zmenahesla.html">zmenahesla.php</a>.
Jediný problém je, kam odkaz na změnu hesla na stránce umístit -
prozatím jej dáme například před odkaz Odhlášení a budeme jej
zobrazovat JEN PRO PŘIHLÁŠENÉ uživatele. Změna se tedy týká souboru
<a href="./examples/musicweb/4/navigace.html">navigace.php</a>.
</p>
<p>
Mohlo by se zdát, že postačí mít "výkonný" příkaz skriptu
zmenahesla.php ve tvaru:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">mysql_query
</font><font color="#007700">(</font><font color="#dd0000">"update
uzivatele set heslo = '"</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"heslo"</font><font color="#007700">].</font><font color="#dd0000">"' where id="</font><font color="#007700">.</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">].</font><font color="#dd0000">";"</font><font color="#007700">, </font><font color="#0000bb">$link</font><font color="#007700">);</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a spoléhat na to, že pokud nebude bude proměnná $_SESSION["id"]
nastavena, zaktualizuje databáze nulový počet řádků. Je však lepší
"hrát na jistotu" a pojistit se podmínkou:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">if
(isset(</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])) </font><font color="#0000bb">mysql_query </font><font color="#007700">(</font><font color="#dd0000">"update uzivatele set
heslo = '"</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"heslo"</font><font color="#007700">].</font><font color="#dd0000">"' where id="</font><font color="#007700">.</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">].</font><font color="#dd0000">";"</font><font color="#007700">, </font><font color="#0000bb">$link</font><font color="#007700">);</font></font><br>
</code></div>
<!-- Zaza PHP kód END -->
<p>protože nikdy nevíme, jak se v tomto ohledu budou chovat nově vydané
verze databází.
</p>
<a name="000306"></a><h2>Zrušení registrace</h2>
<p>
Rovněž zrušení registrace uděláme jednoduché. Prostě smažeme z
databáze řádek s údaji o daném uživateli, takže se následně nebude moci
přihlásit. Musíme přitom ale dát pozor na jednu věc - uživatele musíme
rovněž odhlásit a uzavřít jeho session. Jinak by se aplikace mohla
chovat nevypočitatelně.
</p>
<p>
Celé se to provede hned ve skriptu index.php, takže zbytek stránky
již bude vědět, že uživatel není přihlášen. Ovšem odpovídající odkaz v
souboru navigace.php nepovede na zrušení registrace rovnou, nejprve
bude uživatel nasměrován na stránku, kde se ho zeptáme, zda to opravdu
myslí vážně. Pokud ano, poskytneme mu teprve odkaz na zrušení
registrace.
</p>
<p><span style="font-style: italic;">Pozn.: Ve firemní praxi by se
zcela určitě záznam nemazal. Namísto toho by se mu dal nějaký příznak
(např. pole DELETED), který by představoval informaci o tom, že
uživatel se odregistroval, ale záznam v databázi by se uschoval. Důvodů
je více - napadá mě statistika, bezpečnost nebo návaznost na jiná data
v systému. My si však nebudeme komplikovat život a řádek odstraníme.<br>
</span>
</p>
<a name="000307"></a><h2>Změny na portálu</h2>
<p>
Nové soubory:
</p>
<ul>
<li><a href="./examples/musicweb/4/zapomenuteheslo.html">zapomenuteheslo.php</a></li>
<li><a href="./examples/musicweb/4/zmenahesla.html">zmenahesla.php</a></li>
<li><a href="./examples/musicweb/4/zruseniregistracedotaz.html">zruseniregistracedotaz.php</a></li>
<li><a href="./examples/musicweb/4/zruseniregistrace.html">zruseniregistrace.php</a></li>
</ul>
<p>Změněné soubory:</p>
<ul>
<li><a href="./examples/musicweb/4/index.html">index.php</a>
- logika odregistrování</li>
<li><a href="./examples/musicweb/4/navigace.html">navigace.php</a>
- odkaz na změnu hesla a zrušení registrace</li>
<li><a href="./examples/musicweb/4/prihlaseni.html">prihlaseni.php</a>
- odkaz na připomenutí hesla</li>
<li><a href="./examples/musicweb/4/registrace.html">registrace.php</a>
- odkaz na připomenutí hesla</li>
</ul>
<p>
Projekt v současném stavu si můžete <a href="./examples/4.zip">stáhnout</a>. </p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span>
</p>
<a name="000308"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (73) - Frontend a backend</h2>
			<p class="perex">Další díl seriálu o portálu v PHP. Frontend, backend, bezpečnost
				<br>
			</p>
			<p>Náš "hudební portál" má teď všechny náležitosti stran správy
uživatelů vyřešené. Takže se směle můžeme pustit do opravdového
programování obsahu tohoto webu. Ještě než k tomu přistoupíme, ujasněme
si ale něco málo názvosloví a zorganizujem si práci.<span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000309"></a><h2>Frontend a backend<br>
</h2>
<p>Stojí za zmínku, že skoro všechny poloprofesionální až profesionální
weby s dynamickým obsahem skončí u koncepce "frontend-backend". To
jednoduše znamená, že existují stránky pro uživatele portálu (tedy
frontend), na nichž je zobrazeno to, co potřebuje návštěvník webu
vidět, a stránky pro administrátora, kde je zase naopak to, co
potřebuje ke vkládání dat (backend). Někde "mezi" tím vším jsou data k
zobrazení, převážně uložená v databázi. Celou situaci ilustruje
následující obrázek:<br>
</p>
<p style="text-align: center;"><img style="width: 414px; height: 51px;" alt="" src="img/portal.gif"></p>
<p>Mluvím o tom proto, že převážná většina naší další práce bude
střídavě práce na zobrazování položek na webu a střídavě práce na
administrační části. V našem případě to bude velmi jednoduché na
rozlišení - pokud bude přihlášený uživatel administrátorem, bude mít k
dispozici další nabídky pro zadávání informací do databáze.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Musíte si uvědomit jedno -
v závislosti na zadání práce může a nemusí být jedno, jak administrační
část vypadá. Takže někdy je možné ušetřit čas a prostředky tím, že
administrační část webu bude obsahovat pouze to nejnutnější a hlavní
úsilí se vloží do práce na webu.<br>
</span></p>
<a name="000310"></a><h2>Zadávání koncertů</h2>
<p>Nejprve si připomeňme, co jsme si vytýčili jako požadavky pro
zadávání koncertů:</p>
<ul>
  <li>Zadávat koncerty bude smět pouze uživatel s oprávněními
administrátora<br>
  </li>
  <li>Z formuláře se zadá datum, čas a místo koncertu, to bude uloženo
v databázi </li>
  <li>Na webu se budou zobrazovat pouze koncerty v budoucnosti (ne ty,
co už byly) </li>
  <li>Aplikační logika by neměla povolit zadat více než jeden koncert
denně </li>
</ul>
<p>... a začneme definicí tabulky databáze.Tabulka se bude jmenovat
koncerty, bude obsahovat automaticky číslované pole jako klíč, a pole
pro datum, čas a místo. Jelikož budeme chtít ukládat datum a čas do
dvou nesuvisejících sloupců, použijeme na jejich uložení v tabulce
sloupce typu <a href="http://dev.mysql.com/doc/mysql/en/DATETIME.html">date</a>
a <a href="http://dev.mysql.com/doc/mysql/en/TIME.html">time</a>.
Definiční příkaz pro tvorbu tabulky tedy bude vypadat následovně:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">CREATE TABLE `koncerty` (<br>
`id` INT NOT NULL AUTO_INCREMENT ,<br>
`datum` DATE NOT NULL ,<br>
`cas` TIME NOT NULL ,<br>
`misto` VARCHAR( 50 ) NOT NULL ,<br>
PRIMARY KEY ( `id` )<br>
);</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Práci na zadávání koncertů musíme chtě nechtě začít tím, že na webu
zajistíme zobrazení speciálních nabídek pro případ, že je přihlášen
administrátor. Takže, postup bude následující:<br>
</p>
<ul>
  <li>Do databáze založíme uživatele a přidělíme mu oprávnění
administárora (asi ručně)<br>
  </li>
  <li>Vytvoříme funkci, která pozná, že je přihlášen administrátor a
zobrazí "jeho" menu</li>
  <li>Následně do menu administrátora přidáme položku pro zadávání
koncertů</li>
  <li>Naprogramujeme skript zadejkoncert.php a odzkoušíme ho</li>
</ul>
<a name="000311"></a><h2>Detekce administrátora</h2>
<p>Ještě jedna důležitá věc. Je potřeba správně ošetřit, kam má přijít
funkce pro zjišťování, zda je daný uživatel administrátorem. Dejme
tomu, že napíšeme funkci jeadmin(), která vrátí TRUE v případě, že je
přihlášen uživatel a je to administrátor. Jedno řešení pak spočívá v
tom, že všechny administrátorské nabídky soustředíme do nějakého
skriptu (třeba admin.php) a někam do souboru index.php přidáme
následující řádek:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#007700">if (</font><font color="#0000bb">jeadmin</font><font color="#007700">()) require </font><font color="#dd0000">"admin.php"</font><font color="#007700">;</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>To by však byla vážná bezpečnostní chyba! Proč? Protože kromě toho,
že by uživatel mohl nasměrovat prohlížeč na soubor index.php, mohl by
jej nasměrovat i na soubor admin.php (!). Tento problém jsme již v jiné
souvislosti řešili v díle o <a href="#000083">vkládání
souborů</a>. Správná úvaha tedy je - nevzrušeně soubor admin.php do
skriptu index.php vložit a na začátek souboru admin.php napsat:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#007700">if (!</font><font color="#0000bb">jeadmin</font><font color="#007700">()) return;</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Tím je zajištěno, že zbytek skriptu se provede pouze v případě, že
je přihlášen administrátor a nikdy jindy. Tok programu nadále pokračuje
dalšími instrukcemi, protože příkaz return narozdíl od die neukončuje
celý php stroj. <br>
</p>
<p style="font-style: italic;">Pozn.: S trochou zdravého rozumu se na
to dá přijít, divili byste se však, kolik stránek obsahuje i takovouto
základní bezpečnostní chybu.<br>
</p>
<p>Funkci jeadmin() umístíme do souboru func.php, protože se zdá, že ji
budeme používat opakovaně. <br>
</p>
<a name="000312"></a><h2>Ověřování času</h2>
<p>Když už jsme probrali tolik teoretických otázek, tak si dovolím na
závěr ještě jednu. Jak víte, data z formulářů by se měla <a href="#000105">ověřovat</a>,
než se použijí. V souvislosti s tím nám vzniká zajímavý problém - jak
ověřit datum a čas, které budou uživatelé vkládat do databáze? Existuje
několik řešení, z nichž většina má výhody a nevýhody:<br>
</p>
<ul>
  <li>Nechat databázi, ať se s tím popere. Nevýhoda je ta, že bychom
museli zachytávat chyby, vzniklé uložením dat do databáze, což není moc
dobré řešení</li>
  <li>Pokusit se testovat, zda předaná hodnota může reprezentovat
platné datum, a podle toho se zařídit.</li>
  <li>Striktně omezit formát zadávaného data a času a pak to stejně
striktně
kontrolovat. Nevýhoda je, že tím nutíme uživatele, aby se přizpůsobil
programátorovi</li>
</ul>
<p>Podle všeho se zdá, že budeme muset použít tu poslední možnost,
protože ověřit, zda daný řetězec představuje platné české datum může
být pro PHP skutečný problém. Nicméně nám přijde vhod, že PHP obsahuje
funkci <a href="http://cz.php.net/manual/cs/function.checkdate.php">checkdate</a>,
která převezme rok, měsíc a den a otestuje, zda to může představovat
existující datum v kalendáři.</p>
<a name="000313"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (74) - Administrátorské rozhraní portálu</h2>
			<p class="perex">Dnes se při stavbě portálu zakousneme do tvorby administrátorského rozhraní.
				<br>
			</p>
			<p>V minulém díle jsme teoreticky rozebrali úskalí, která nás mohou
potkat při sestavování administrační sekce portálu. Dnes si pojďme
ukázat, jak takovou věc v praxi dovést do zdárného konce.<span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000314"></a><h2>Administrační sekce portálu<br>
</h2>
<p>Jak bude vypadat funkce pro ověřování, zda je přihlášený uživatel
administrátorem už asi tušíte. Její jádro bude spočívat v tom, že v
prvé řadě otetuje, zda je vůbec někdo přihlášen, a pokud ano, zda má v
databázi nastaveno, že je to administrátor. Můžeme tedy směle napsat
něco jako:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">function
</font><font color="#0000bb">jeadmin </font><font color="#007700">(</font><font color="#0000bb">$link</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;if (!isset(</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])) return </font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select id from
uzivatele where id="</font><font color="#007700">.</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">].</font><font color="#dd0000">" and jeadmin=1"</font><font color="#007700">, </font><font color="#0000bb">$link</font><font color="#007700">);<br>
&nbsp;&nbsp;return (boolean) </font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
} </font><br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Všimněte si, že funkci se nemusí předávat jako parametr ID
přihlášeného uživatele, protože proměnné $_SESSION jsou naštěstí v těle
funkcí k dispozici. Jestliže přihlášený uživatel bude administrátorem,
můžeme někam umístit jeho osobní menu. Já jsem to (například) umístil
do souboru index.php takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">...atd...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/table&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?</font><font color="#007700">require </font><font color="#dd0000">"admin.php"</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&lt;/div&gt;<br>
&nbsp;&nbsp;&lt;/body&gt;<br>
&lt;/html&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Připomínám (byla o tom řeč <a href="#000308">minule</a>),
že každý skript přístupný pouze administrátorovi by měl začínat řádkem:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#007700">if (!</font><font color="#0000bb">jeadmin</font><font color="#007700">()) return;</font><font color="#0000bb"><br>
</font></font></code></div>
<p>jinak totiž napsáním šikovného url ve stylu
index.php?clanek=NecoCoMelVidetPouzeAdmin uzří i nepovolané oko to, co
mělo zůstat skryto.<br>
</p>
<a name="000315"></a><h2>Rozhraní pro zadávání koncertů</h2>
<p>Skritp zadejkoncert.php nejprve otestuje, zda je přihlášen
administrátor. Pokud je, zobrazí formulář pro zadání data, času a místa
konání koncertu. Celý skript je poměrně přímočarý, až na patálie
způsobené zpracováním údajů o čase.<br>
Minule jsme zdůvodnili, že nejschůdnější varianta bude spočívat v tom,
když administrátorovi zkrátka striktně nařídíme určitý formát zadávání
data a času. Když říkám nařídíme, mám tím na mysli dvě věci:<br>
</p>
<ol>
  <li>Administrátor musí ze stránky poznat, jak má údaje zadat, tzn.
měli bychom to nějak popsat</li>
  <li>Skript bude muset provést kontrolu toho, zda to uživatel dodržel.</li>
</ol>
<p>Skript pro kontrolu formátu data a času využívá funkci <a href="http://cz2.php.net/manual/en/function.explode.php">explode</a>,
která rozdělí "řetězec řetězcem". (Je to jako vytloukání klínu klínem
;-)))). Měly by vzniknout tři řetězce v případě datumu (dělíme tečkou)
a dva řetězce v případě času (dělíme dvojtečkou). To lze testovat
pomocí funkce <a href="http://cz2.php.net/manual/en/function.count.php">count</a>.
Dál je to již snadné - u času lze testovat, zda je hodina v intervalu
0-23 a minuta 0-59, u datumů lze použít funkci checkdate. Takže celá
funkce pro datum vypadá následovně:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#007700">function </font><font color="#0000bb">jedatum</font><font color="#007700">(</font><font color="#0000bb">$datum</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$test</font><font color="#007700">=</font><font color="#0000bb">explode</font><font color="#007700">(</font><font color="#dd0000">"."</font><font color="#007700">,</font><font color="#0000bb">$datum</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(!(</font><font color="#0000bb">count</font><font color="#007700">(</font><font color="#0000bb">$test</font><font color="#007700">))==</font><font color="#0000bb">3</font><font color="#007700">) return </font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">checkdate</font><font color="#007700">(</font><font color="#0000bb">$test</font><font color="#007700">[</font><font color="#0000bb">1</font><font color="#007700">],</font><font color="#0000bb">$test</font><font color="#007700">[</font><font color="#0000bb">0</font><font color="#007700">],</font><font color="#0000bb">$test</font><font color="#007700">[</font><font color="#0000bb">2</font><font color="#007700">]);<br>
&nbsp;&nbsp;}</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-style: italic;">Pozn.: Tady vidíme, že nařídit
uživatelům vstupní formát zadávání informací může programátorovi značně
ulehčit práci. Ovšem, takový program se pak lehce může stát
"user-unfriendly".</span><br>
</p>
<p>Ještě to není všechno. Další problém nastane, když naše přepečlivě
ošetřené datumy budeme chtít uložit do databáze. MySQL sice umí
pochopit různé formáty data a času, ale české datum mezi nimi není. S
časem problém nebude, ale na datum bude ještě nutné dopsat nějakou
konverzní funkci. Vyjdeme z toho, že datum je již otestované, a tak
lehce překlopíme datum z formátu d.m.yyyy třeba do formátu yyyy-mm-dd,
kterému již MySQL bez problému porozumí. Celý skript zadejkoncert.php
si můžete <a href="./examples/musicweb/5/zadejkoncert.html">zobrazit</a>.<br>
</p>
<a name="000316"></a><h2>Zjednodušení odkazu na databáze</h2>
<p>Pravděpodobně jste si všimli toho, že prakticky každá funkce, která
se dotazovala databáze, přebírala dosud jako vstupní parametr odkaz na
databázi (proměnná $link). <a href="http://www.linuxsoft.cz/user_page.php?user_id=3188">Lukáš Kokoška</a>
v diskusi <a href="#000298">k
článku o přihlašování uživatelů</a> navrhoval použít následující
konstrukci:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">function
</font><font color="#0000bb">iduzivatele </font><font color="#007700">(</font><font color="#0000bb">$prezdivka</font><font color="#007700">, </font><font color="#0000bb">$heslo</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;global </font><font color="#0000bb">$link</font><font color="#007700">;<br>
&nbsp;&nbsp;...&nbsp;&nbsp;<br>
}</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Takové vylepšení je samozřejmě žádoucí, neboť snižuje počet
předávaných parametrů a tím zvyšuje čitelnost kódu. Nicméně, stále je v
těle funkcí třeba uvádět klíčové slovo global a je jen otázka času, kdy
se na to zapomene.<br>
</p>
<p>Inspirován Lukášovým příspěvkem jsem zavedl jen jednu globální
proměnnou $GLOBALS["link"], která již je přístupná i ve funkcích a celé
připojování k databázi jsem umístil do jednoho skriptu. Takže teď
funcke vypadají ve stylu:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb"></font><font color="#007700">function </font><font color="#0000bb">iduzivatele
</font><font color="#007700">(</font><font color="#0000bb">$prezdivka</font><font color="#007700">, </font><font color="#0000bb">$heslo</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql</font><font color="#007700">(</font><font color="#dd0000">"select..."</font><font color="#007700">,</font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
}</font><br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Bude to jednak čitelnější a jednak jednodušší na správu.</p>
<a name="000317"></a><h2>Změny na portálu</h2>
<p>Nové soubory:</p>
<ul>
  <li><a href="./examples/musicweb/5/zadejkoncert.html">zadejkoncert.php</a></li>
</ul>
<p>Změněné soubory:</p>
<p>Většina souborů. Je to kvůli redesignu připojení k databázi
popsanému výše.</p>
<p>Projekt v současném stavu si můžete <a href="./examples/5.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span></p>

<a name="000318"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (75) - Pokračujeme na portále</h2>
			<p class="perex">Co hrozí a na co dávat pozor při administraci portálu v PHP?
				<br>
			</p>
			<p>V pátek jsme sestavili administrátorovi rozhraní pro zadávání
koncertů. Pokud jste si to doma zkusili, pravděpodobně jste zjistili,
že tomu k dokonalosti ještě něco chybí. Pojďme to tedy dnes trochu
vylepšit.<span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000319"></a><h2>Vylepšujeme administrační část<br>
</h2>
<p>Především, je tu jeden nedodělek ze zadání. Mezi podmínkami totiž
bylo to, že aplikační logika by neměla povolit zadat více než jeden
koncert denně, což nám současná verze povolí. Problém lze řešit různě.
Jedna možnost je, že před uložením otestujeme, zda dané datum v
databázi již není. Něco podobného jsme již dělali v případě přezdívek a
mailů při registraci. Tehdy jsme použili dotaz, který zjistil, zda se v
databázi zadaný údaj již nevyskytuje a zachová se podle toho.<br>
</p>
<p>Jiné dobré řešení je nechat pracovat databázi. Pokud to databázový
stroj umožňuje, lze na určitém sloupci definovat tzv. <a href="http://dev.mysql.com/doc/mysql/en/constraint_primary_key.html">unikátní
index</a>. V
praxi to znamená, že hodnoty v daném sloupci musejí být navzájem
odlišné, jinak databáze nepovolí uložení nebo úpravu záznamu. MySQL
tohle umí a příslušný unikátní index přidáte k poli následujícím
způsobem:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">ALTER TABLE `koncerty`
ADD UNIQUE `datum` ( `datum` ) </font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V praxi se přitom musí dát pozor na dvě věci. Za prvé, databáze
nepovolí vytvoření unikátního indexu v případě, kdy již ve sloupci
duplicitní hodnoty existují. Na to pozor, potom by to vůbec
nefungovalo. Za druhé, pokud sloupec může obsahovat hodnotu NULL,
zvažte, zda index dělá to, co zamýšlíte. Výchozí (a správné) chování
MySQL (a většiny jiných databází) je to, že řádků s hodnotou NULL ve
sloupci s unikátním idexem může být více než jeden. To je logické,
pokud si uvědomíte, že jedna hodnota NULL se nikdy nerovná jiné hodnotě
NULL. Nás uvedené problémy trápit nemusejí, protože naše tabulka
koncertů
je zatím prázdná a
pole datum je definováno tak, že nesmí obsahovat hodnoty NULL.<br>
</p>
<p>Zpracování pak obecně vypadá následovně:<br>
</p>
<ol>
  <li>Aplikace (v našem případě PHP) sestaví dotaz a pokusí se jej
provést "duplicita neduplicita"</li>
  <li>Databáze si to přebere a buď záznam(y) uloží nebo neuloží</li>
  <li>Volající aplikace by měla být schopna zachytit a zpracovat
případnou chybu z MySQL</li>
</ol>
<p>Na první pohled může vypadat tohle "spoléhání na databázi" složité,
ale má to jednu podstatnou výhodu: Pokud byste do tabulky přidávali
řádky z více skriptů (nebo prostě z více programů), nemusíte již
pokaždé na omezující pravidla myslet. I když bezpochyby bude v každém
programu třeba ošetřit případné chyby, do databáze se vám nikdy
nedostanou nežádoucí údaje.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Přenášení částí aplikační
logiky na databázi je oblíbené zejména u rozsáhlejších systémů. Vždy to
závisí na schopnostech databáze. PostgreSQL je v tomto ohledu mnohem
lépe vybavena než naše MySQL.<br>
</span></p>
<p>Skript zadejkoncert.php teď upravíme do podoby, v níž bude schopen
zachytit případnou chybu z MySQL. Samozřejmě, že nám nic nebrání v
případě výskytu chyby znovu zobrazit formulář. Celé to může vypadat
nějak takto:
<!-- Zaza PHP kód BEGIN --><br>
</p>
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#ff8000">// ...<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_query </font><font color="#007700">(</font><font color="#dd0000">"insert into koncerty
(datum, cas, misto) values ('"</font><font color="#007700">.</font><font color="#0000bb">sqldatum</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"datum"</font><font color="#007700">]).</font><font color="#dd0000">"', '"</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">].</font><font color="#dd0000">"', '"</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"misto"</font><font color="#007700">].</font><font color="#dd0000">"');"</font><font color="#007700">, </font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$chyba </font><font color="#007700">= </font><font color="#0000bb">mysql_error</font><font color="#007700">(</font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$chyba</font><font color="#007700">===</font><font color="#dd0000">''</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Koncert byl
přidán"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Koncert
NEBYL přidán. Databáze vrátila chybu&lt;BR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#0000bb">$chyba</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;</font><font color="#ff8000">// atd.</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p style="font-style: italic;">Pozn.: Ještě jedna záludnost: Popsané
řešení dobře funguje u pokusu vložit nebo upravit jeden řádek. Pokud
byste ale chtěli podobným způsobem provést v databázi změnu více řádků,
bude se MySQL chovat různě podle toho, zda používá nebo nepoužívá
úložiště podporující transsakce.<br>
</p>
<ul style="font-style: italic;">
  <li>Pokud jsou transsakce podporovány a narazí se při vkládání nebo
při aktualizaci na problém s unikátním indexem, je celé vkládání nebo
aktualizace vráceno</li>
  <li>Pokud transsakce nesou podporovány, provedou se všechny
aktualizace až do řádku s chybou (ten a všechny následující se již
neprovedou)</li>
</ul>
<p><span style="font-style: italic;">Toto chování je sice dobře
zdokumentováno, ale není příliš intuitivní, takže na to pozor.</span></p>
<p><span style="font-style: italic;"></span></p>
<a name="000320"></a><h2>Zpětná vazba</h2>
<p>Další možnost, jak vylepšit administrační rozhraní spočívá v tom, že
se po úspěšném vložení řádku přesuneme na jinou stránku. Tuto techniku
jsme již v seriálu <a href="#000167">probírali</a>,
takže jen připomenu, proč je to nutné: pokud bychom zůstali na současné
stránce a uživatel by si znovu natáhl stránku do prohlížeče, hrozí
opětovné vložení záznamu a v databázi bychom pak měli stejný záznam
dvakrát.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Vnímavý čtenář namítne, že
to není pravda. Podruhé se záznam nevloží, protože v našem případě
selže vkládání kvůli tomu, že v poli datum nastane duplicita a databáze
to nepovolí. To je pravda, nicméně měli bychom si osvojit správné
návyky při vkládání záznamů bez ohledu na to, zda opakované vložení
hrozí či nikoli.</span><br>
</p>
<p>Další důvod pro přesunutí na jinou stránku je psychologický. Namísto
lakonické hlášky "koncert byl vložen" je přece mnohem lepší zobrazit
stránku s koncerty, aby administrátor na vlastní oči viděl, zda se mu
vložení povedlo či nikoli. Tím jsme vlastně odpověděli i na otázku kam
by měl být uživatel přesměrován po dokončení akce vkládání řádku. Mělo
by to být na stránku se seznamem koncertů.&nbsp; Odpovídající kód tedy
bude:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#ff8000">// ...<br>
&nbsp;&nbsp;</font><font color="#007700">if (</font><font color="#0000bb">$chyba</font><font color="#007700">===</font><font color="#dd0000">''</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$BudemeZobrazovat</font><font color="#007700">=</font><font color="#0000bb">false</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$path</font><font color="#007700">=</font><font color="#0000bb">SubStr</font><font color="#007700">(</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SCRIPT_NAME"</font><font color="#007700">], </font><font color="#0000bb">0</font><font color="#007700">, </font><font color="#0000bb">StrRPos</font><font color="#007700">(</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SCRIPT_NAME"</font><font color="#007700">],</font><font color="#dd0000">"/"</font><font color="#007700">)).</font><font color="#dd0000">"/index.php?clanek=koncerty"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">Header</font><font color="#007700">(</font><font color="#dd0000">"Location: http://"</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SERVER_NAME"</font><font color="#007700">].</font><font color="#dd0000">":"</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SERVER_PORT"</font><font color="#007700">].</font><font color="#0000bb">$path</font><font color="#007700">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"Koncert
NEBYL přidán. Databáze vrátila chybu&lt;BR&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#0000bb">$chyba</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;</font><font color="#ff8000">// atd.</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jára Cimrman by prhlásil: "Nápad jistě dobrý, výsledky nebyly
dobré". Problémem tohoto kódu je, že nebude fungovat. Důvod je prostý -
někde v polovině skriptu jsme se pokusili odeslat hlavičku pomocí
funkce Header, což zákonitě musí skončit chybou "Cannot add header
information - headers already sent". To jsme již v seriálu <a href="#000140">rozebírali</a>.
Co s tím?<br>
</p>
<p>Možností je několik: Můžeme izolovat skript pro zadávání koncertů
tak, aby se neprováděl jako vložený v souboru index.php, tím si však
zcela rozházíme koncepci stránek. Můžeme vložit skript koncerty.php
ihned poté, co úspěšně zapíšeme data do databáze, ale tím zase
nezbavíme uživatele možnosti pokusit se znovu vložit data refreshováním
stránky v prohlížeči!<br>
</p>
<p>Řešením jsou tzv. funkce pro řízení výstupu, jejichž význam a
použití si probereme příště. Příště rovněž dokončíme skript
koncerty.php.</p>
<a name="000321"></a><h2>Změny na portálu</h2>
<p>Nové soubory:</p>
<ul>
  <li><a href="./examples/musicweb/6/koncerty.html">koncerty.php</a>
(nový
soubor, zatím "slepý")</li>
</ul>
<p>Změněné soubory:</p>
<ul>
  <li><a href="./examples/musicweb/6/zadejkoncert.html">zadejkoncert.php</a>
(upravené ukládání)</li>
</ul>
<p>Projekt v současném stavu si můžete <a href="./examples/6.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span><br>
</p>
<a name="000322"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (76) - Zobrazujeme data na portále</h2>
			<p class="perex">Kterak použít funkce pro bufferování výstupu při zobrazení dat na PHP portále.
				<br>
			</p>
			<p>Náš portál jsme minule zanechali ve stavu, kdy nešluo uspokojivě
vyřešit zadání koncertu a přesun na stránku se seznamem koncertů kvůli
problémům s hlavičkami. Naznačil jsem, že řešením bude zapnout
bufferování výstupu. Pojďme to trochu rozebrat.<span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000323"></a><h2>Funkce pro řízení výstupu<br>
</h2>
<p>Normálně PHP funguje tak, že při zpracování skriptu, zjednodušeně
řečeno:<br>
</p>
<ul>
  <li>Pošle hlavičky</li>
  <li>Pošle html bloky kódu (v pořadí, jak jsou uvedeny)<br>
  </li>
  <li>Pošle výstupy funkce print a echo (v pořadí, jak jsou uvedeny)<br>
  </li>
  <li>Skončí</li>
</ul>
<p>Toto chování lze změnit pomocí tzv. <a href="http://cz.php.net/manual/cs/ref.outcontrol.php">funkcí pro
řízení výstupu</a>. Mezi nejvýznamější patří funkce <a href="http://cz.php.net/manual/cs/function.ob-start.php">ob_start</a>
a <a href="http://cz.php.net/manual/cs/function.ob-end-flush.php">ob_end_flush</a>.
Ob_start zapíná bufferování výstupu, ob_end_flush bufferování vypíná a
odesílá nasyslený buffer prohlížeči. Pokud zavoláte funkci ob_start, je
kód normálně prováděn, ale s následujícími změnami:</p>
<ul>
  <li>Jakékoli hlavičky jsou na serveru ukládány do bufferu</li>
  <li>Jakýkoli výstup je ukládán do bufferu</li>
  <li>Jakmile skript skončí, jsou odeslány nejprve všechny hlavičky, a
potom všechen obsah</li>
</ul>
<p>To má dvě výhody, obě poměrně podstatné. Jelikož mohou být
jednotlivá volání funkcí print a echo celkem náročná na čas, vede
obvykle bufferování výstupu ke zrychlení celé aplikace. A navíc, což je
podstatné pro nás, bufferování výstupu rovněž umožní odeslat hlavičky
nebo nastavit cookie proměnné i v případě, kdy už byl do bufferu
odeslán nějaký výstup. Můžeme tedy směle veprostřed skriptu zavolat
hlavičku s požadavkem na přesměrování na jinou stránku, a ono to bude
fungovat! Nic nám tedy nebrání zabalit celý výstup do bufferování
například hned úpravou souboru index.php:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?
<span style="font-weight: bold;">ob_start</span></font><font color="#007700"><span style="font-weight: bold;">();</span><br>
&nbsp;&nbsp;</font><font color="#0000bb">session_start</font><font color="#007700">();<br>
&nbsp;&nbsp;require </font><font color="#dd0000">"./func.php"</font><font color="#007700">; </font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&lt;HTML&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;... atd<br>
&nbsp;&nbsp;&lt;/HTML&gt;<br>
<font color="#0000bb">&lt;?<span style="font-weight: bold;">ob_end_flush</span></font><font style="font-weight: bold;" color="#007700">();</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-style: italic;">Pozn.: Konkrétně odeslání hlavičky
Location samozřejmě znamená, že je předchozí obsah bufferu bez použití
zahozen, protože nová stránka je někde úplně jinde, ale v našem
příkladu je to přesně to, co chceme. Uvědomme si, že je sice zahozen
výstup, který by normálně dorazil do prohlížeče, ale programový kód ve
skriptu se klasicky provedl. Provedlo se tedy i vložení řádku do
databáze.</span><br>
</p>
<p>Z bufferováním výstupu se dají provádět kouzla - například lze
nastavit, aby se před výstupem bufferu provedla nějaká funkce, buffer
lze zahodit, upravit, prohlédnout, konvertovat mezi znakovými sadami a
podobně. Jeho nejdůležitější
použití však spočívá v tom, že se nemusíme úzkostlivě starat o
odesílání hlaviček. Prohlédněte si celý&nbsp; upravený soubor <a href="./examples/musicweb/7/index.html">index.php</a>.<br>
</p>
<a name="000324"></a><h2>Zobrazení koncertů</h2>
<p>Vyřešili jsme přesměrování na stránku se seznamem koncertů. Pojďme
tedy teď koncerty zobrazit. To je činnost, při níž se toho nenaučíme
moc nového - probíralo se to v díle o <a href="#000164">zobrazení
dat z databáze</a>. Jediný zádrhel bude spočívat v tom, že musíme nějak
elegantně vyřešit zobrazování českého data, koncerty seřadit (asi
vzestupně) a zajistit jen zobrazení těch, které jsou v budoucnu.<br>
</p>
<p>Řazení zajistí klauzule ORDER BY v dotazu pro databázi. Zobrazení
jen koncertů, které nastanou v budoucnosti zajistí rovněž dotaz,
protože jazyk MySQL zná funkce pro&nbsp; <a href="http://dev.mysql.com/doc/mysql/en/Date_and_time_functions.html">manipulaci
s daty</a>, které umí vrátit aktuální datum. Musíme však dát pozor na
jednu věc - MySQL funkce NOW() vrací nejen datum, ale rovněž čas. To je
pro naše účely poměrně nešikovné, protože ve sloupci datum máme uložen
pouze údaj o datumové části dne, nikoli čas. Rovněž musíme dát pozor na
to, že koncert konající se <span style="font-style: italic;">dnes </span>by
měl být na webu také zobrazen. Správný dotaz tedy bude využívat jinou
funkci, a sice curdate():</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">select * from koncerty
where datum &gt;= curdate() order by datum</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Při zobrazování česky formátovaného datumu máme na výběr z několika
možností. Jeden způsob je využít formátovacích funkcí mysql, konkrétně
funkce DATE_FORMAT. Tahle funkce se ale několikrát měnila, takže nikdo
z hlavy neví, jak bude na té které verzi databáze fungovat. Proto
využijeme druhou možnost, a to je zformátování data přímo pomocí PHP
funkce <a href="http://cz.php.net/manual/cs/function.date.php">date</a>,
resp. <a href="http://cz.php.net/manual/cs/function.strftime.php">strftime</a>.
Rozdíl mezi nimi je ten, že strftime bere ohledy na národní prostředí.
Se zobrazováním datumů je vůbec legrace, protože MySQL nám nevrátí
číslo, ale řetězec. Z řetězce tedy nejprve musíme vyvěštit datum a to
následně převést. Já používám následující funkci:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">function
</font><font color="#0000bb">ceskedatum </font><font color="#007700">(</font><font color="#0000bb">$datum</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$datum </font><font color="#007700">==</font><font color="#dd0000">""</font><font color="#007700">) return </font><font color="#dd0000">""</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">strftime</font><font color="#007700">(</font><font color="#dd0000">"%d.%m.%Y"</font><font color="#007700">,</font><font color="#0000bb">strtotime</font><font color="#007700">(</font><font color="#0000bb">$datum</font><font color="#007700">));<br>
}</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Ani čas se nám asi nebude líbit zobrazený s přesností na vteřiny,
naštěstí tady je pomoc snadná. Protože délka řetězce reprezentující čas
je konstantní, stačí prostě zobrazit jen určitý počet znaků zleva a je
to.<br>
</p>
<a name="000325"></a><h2>Myslet jako uživatel</h2>
<p>Ještě jeden detail. Může se stát, že v databázi nebudu zadány žádné
koncerty, nebo nebudou žádné koncerty v budoucnosti. Stránka by se v
takovém případě zobrazila prázdná. To je formálně správně, jenomže by
to mohlo uživatele mást. Nevěděl by, zda nejsou koncerty zadané, nebo
zda je nějaká chyba na webu. Upravíme tedy skript tak, aby nám v
takovém případě řekl, že dotaz sice proběhl, ale nevrátil žádné
výsledky.</p>
<p>Postačí volat funkci <a href="http://cz.php.net/manual/cs/function.mysql-num-rows.php">mysql_num_rows()</a>
bezprostředně po volání výběrového dotazu. Jen pozor - je třeba
pamatovat na to, že celá tabulka s výsledky se bude kreslit pouze v
případě, že nějaké výsledky byly vráceny. Tudíž, i její záhlaví se musí
konstruovat až v případě, kdy existuje nenulový počet výsledků, jinak
vznikne nevalidní stránka. Kód stránky zobrazkoncert teď může vypadat
nějak takto:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from koncerty
where datum &gt;= curdate() order by datum"</font><font color="#007700">,</font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
if (</font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)==</font><font color="#0000bb">0</font><font color="#007700">)<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"--&nbsp;&nbsp;Není
naplánován žádný koncert --"</font><font color="#007700">;<br>
else<br>
{<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TABLE&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&lt;TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">ceskedatum</font><font color="#007700">(</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"datum"</font><font color="#007700">])</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">substr</font><font color="#007700">(</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">],</font><font color="#0000bb">0</font><font color="#007700">,</font><font color="#0000bb">strlen</font><font color="#007700">(</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"cas"</font><font color="#007700">])-</font><font color="#0000bb">3</font><font color="#007700">)</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"misto"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">endwhile;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/TABLE&gt;"</font><font color="#007700">;<br>
}</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<a name="000326"></a><h2>Změny na portálu</h2>
<ul>
  <li>Změněný soubor <a href="./examples/musicweb/7/func.html">func.php</a> -
funkce pro zobrazení českého data</li>
  <li>Změněný soubor <a href="./examples/musicweb/7/index.html">index.php</a> -
bufferování výstupu</li>
  <li>Změněný soubor <a href="./examples/musicweb/7/koncerty.html">koncerty.php</a>
- dodělaný skript</li>
</ul>
<p>Projekt v současném stavu si můžete <a href="./examples/7.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span></p>

<a name="000327"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (77) - Portál, databáze a relace</h2>
			<p class="perex">Dnes navrhneme na našem "PHP hudebním portálu" databázové struktury pro alba a písně.
				<br>
			</p>
			<p>Dosti bylo na našem portálu koncertů. Dejme tomu, že toto téma máme
již uspokojivě vyřešeno, a pojďme se věnovat dalším věcem. Bude to
ztvárnění diskografie.</p>
<a name="000328"></a><h2>Alba a písně<br>
</h2>
<p>Připomeňme, že portál by měl být schopen následujících věcí:<br>
</p>
<ul>
  <li>Názvy alb a písní by se měly zadat do databáze </li>
  <li>Půjdou zobrazit buď jen alba, nebo alba a písně </li>
  <li>Vyhledávání - podle názvu písně najít album nebo alba, na nichž
byla uvedena<br>
  </li>
  <li>Jedna píseň bude moci být na více albech </li>
</ul>
<p>To nás vede k závěru, že budeme muset přidat další tabulky do
databáze (zatím tam máme jen tabulku pro uživatele a tabulku pro
koncerty). Kromě toho, že budeme muset přidat tabulky, musíme si
rozmyslet jaké a jak na sebe budou navazovat. Tabulka uživatelů a
tabulka koncertů totiž byly na svém okolí relativně nezávislé, zatímco
tabulky s alby, písněmi a také s texty písní budou vzájemně záviset.
Již jsme o tom mluvili v díle o <a href="#000148">uložení dat
v databázi</a>. Na
takovou situaci platí staré české přísloví:<br>
</p>
<a name="000329"></a><h2>Dvakrát měř, jednou řež</h2>
<p>Uvědomme si, že špatně navržená databáze obyčejně aplikaci pohřbí.
Začátečník by mohl například uvažvat takto: Máme alba, na každém albu
budou nějaké písně. Založíme tedy tabulku alb a tabulku písní, a u
každé písně bude odkaz na album, na němž je uvedena. Dalo by se to
graficky znázornit takto:<br>
</p>
<div style="text-align: center;"><img style="width: 300px; height: 136px;" alt="" src="img/albapisne.gif"><br>
</div>
<p>A zhruba tomu odpovídající definice tabulek by mohla být:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">CREATE TABLE alba (<br>
&nbsp;&nbsp;id int NOT NULL auto_increment,<br>
&nbsp;&nbsp;nazev varchar(50) NOT NULL default '',<br>
&nbsp;&nbsp;PRIMARY KEY&nbsp;&nbsp;(id)<br>
); <br>
<br>
CREATE TABLE pisne (<br>
&nbsp;&nbsp;id int NOT NULL auto_increment,<br>
&nbsp;&nbsp;album int NOT NULL default 0,<br>
&nbsp;&nbsp;nazev varchar(50) NOT NULL default '',<br>
&nbsp;&nbsp;PRIMARY KEY&nbsp;&nbsp;(id)<br>
);</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Na první pohled to vypadá dobře. Co se však stane, jestliže bude
jedna píseň na více albech? V tom případě naše koncepce selže, protože
nebudeme vědět, co napsat do sloupce album. Jistě, dalo by se pro
stejnou píseň přidat více řádků, ale to má několik nevýhod - duplikují
se data v tabulce a nastane problém s přidáváním textů písní.<br>
</p>
<p>Musíme tedy na celou věc jinak. Jelikož může být více písní na
jednom albu a zároveň jedna píseň na více albech, bude potřeba
sestrojit třetí tabulku, která tuto situaci postihne. Můžeme ji nazvat
třeba "obsahyalb" a schéma pak bude následující:<br>
</p>
<div style="text-align: center;"><img style="width: 487px; height: 136px;" alt="" src="img/albapisne2.gif"><br>
</div>
<p>A tomu odpovídající definice tabulek bude tato:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">CREATE TABLE alba (<br>
&nbsp;&nbsp;id int NOT NULL auto_increment,<br>
&nbsp;&nbsp;nazev varchar(50) NOT NULL default '',<br>
&nbsp;&nbsp;PRIMARY KEY&nbsp;&nbsp;(id)<br>
);<br>
<br>
CREATE TABLE obsahyalb (<br>
&nbsp;&nbsp;id int NOT NULL auto_increment,<br>
&nbsp;&nbsp;album int NOT NULL default 0,<br>
&nbsp;&nbsp;pisen int NOT NULL default 0,<br>
&nbsp;&nbsp;PRIMARY KEY&nbsp;&nbsp;(id)<br>
);<br>
<br>
CREATE TABLE pisne (<br>
&nbsp;&nbsp;id int NOT NULL auto_increment,<br>
&nbsp;&nbsp;nazev varchar(50) NOT NULL default '',<br>
&nbsp;&nbsp;PRIMARY KEY&nbsp;&nbsp;(id)<br>
);</font>
</code></div>
<!-- Zaza PHP kód END -->
<a name="000330"></a><h2>Něco názvosloví</h2>
<p>Kdybyste se chtěli zabývat světem databází trochu do hloubky, možná
se Vám bude následujících pár řádků. To, co jsme demonstrovali na
albech a písních se vznešeně nazývá "<span style="font-style: italic;">návrh
struktury databáze</span>". Vztahům mezi alby a písněmi se odborně říká
<span style="font-style: italic;">relace </span>(odtud relační
databáze). V našem prvním příkladu se jednalo o tzv. <span style="font-style: italic;">relaci 1:N</span>, neboli "jeden k mnoha".
Popisuje to situaci, kdy jednomu "rodičovskému" záznamu odpovídá
teoreticky neomezený počet "dceřinných" záznamů. Tato situace je celkem
běžná - jedna faktura může více položek, jeden tým může sehrát více
zápasů, v jednom bytě může bydlet více lidí.<br>
</p>
<p>Ve druhém případě se jednalo o tzv. <span style="font-style: italic;">relaci N:N</span> (mnoho k mnoha). Tato
relace se obvykle vyjadřuje vloženou tabulkou, tak jak jsme to udělali
v našem případě. I ta je v reálném svěce celkem běžná: Více písní na
více albech, můžete montovat různá auta ze stejných součástek (tedy
jedna součástka ve více autech a zároveň více součástek v jednom autě)
a tak dále. <br>
</p>
<p>Někomu by se mohlo zdát, že vložení té "prostřední" tabulky celou
databázi zpomalí. Většinou to tak není, protože databázový software
bývá na podobné zpracování (které nazýváme <span style="font-style: italic;">tvorba spojení</span>) vysoce
optimalizován. Rovněž odstraňování záznamů je v takovém případě výrazně
zjednodušeno.<br>
</p>
<p><span style="font-style: italic;">Pozn.: U alb a písní to není moc
dobrý příklad, ale třeba u těch aut a součástek ano. Pokud byste totiž
z nějakých důvodů přestali do daného auta montovat danou součástku
(protože byla dejme tomu zbytečná), stačí odstranit záznam z té
"prostřední" tabulky a je to!<br>
</span></p>
<p>V dalším díle se zaměříme zpátky na náš portál a uplatníme relace v
praxi</p>
<a name="000331"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (78) - Informační obsah portálu</h2>
			<p class="perex">Kterak je důležité míti Filipa...a testovací data pro vývoj webu v PHP.
				<br>
			</p>
			<p>Minule jsme rozebrali databázový návrh uspořádání alb a písní na
našem hudebním webu. Dnes je tedy čas něco pořádného s tím udělat
prakticky. Půjde o to, jak to celé zorganizovat a dovést ke zdárnému
konci. <span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000332"></a><h2>Ještě lehká úvaha<br>
</h2>
<p>Ačkoli jsme úvahou strávili celý minulý díl, ještě jednu věc bychom
si měli rozmyslet. Při zadávání a zobrazování koncertů jsme nejprve
vyřešili zadávání dat a potom jejich zobrazování na webu. V případě
diskografie to ale zkusíme opačně. Důvody jsou dva:</p>
<ol>
  <li>Abych Vám ukázal, že to jde, jak se to od opačného postupu liší a
na co dávat pozor</li>
  <li>Protože diskografie zpracovává tři tabulky najednou a zobrazení
dat bude neskonale jednodušší než jejich zadávání</li>
</ol>
<p>Tak či tak, pokud budeme chtít nejprve řešit zobrazování alb a
písní, měli bychom si nachystat nějaký vzorek dat. Takže vymyslíme
testovací data, naplníme je do databáze a pokusíme se je zobrazit. <br>
</p>
<p>Tvorba testovacích dat může být náročný oříšek, pokud nevíte, jak na
to. Tady je několik podnětů:<br>
</p>
<ul>
  <li>Testovací data by měla být alespoň trochu podobná datům skutečným
(objem, rozsahy, hodnoty)</li>
  <li>Všechny nestadndardní situace by měly být zastoupeny (například,
jedna píseň na více albech)</li>
  <li>Do vzorku dat se rovněž můžete pokusit zanést chyby a sledovat,
zda a jak na to aplikace bude reagovat.</li>
</ul>
<p>My budeme brýt v úvahu především první dvě hlediska problému - a
pořídíme si testovací data s několika alby a opakujícími se písněmi.
Pokud byste to doma chtěli testovat na stejných datech jako já, <a href="./examples/musicweb/8/albapisne.sql">zde</a>
najdete odpovídající příkaz pro MySQL pro tvorbu tabulek a dat.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Člověk je tvor líný a
vymýšlet se mi to nechtělo. Půjčil jsem
si tedy z </span><a style="font-style: italic;" href="http://music.clnet.cz/zalman/diskografie.htm">http://music.clnet.cz/zalman/diskografie.htm</a><span style="font-style: italic;"> diskografii existující skupiny.<br>
</span></p>
<p>Při přípravě testovacích dat obyčejně přijdete na nějaké věci, které
by se měly v návrhu databáze upravit. Tak například já jsem přišel na
to, že by bylo dobrá kontrolovat, zda jedna píseň není v tabulce písní
zbytečně dvakrát, a pořídil jsem pro sloupec nazev v tabulce písní
unikátní index.<br>
</p>
<a name="000333"></a><h2>Zobrazujeme diskografii</h2>
<p>Při zobrazení diskografie bychom měli mít na paměti, že by měla jít
zobrazit</p>
<ul>
  <li>buď alba, tedy jejich názvy, nebo</li>
  <li>alba a na každém albu písně</li>
</ul>
<p>Pokusíme se tedy diskografii podle toho navrhnout. Pokud by soubor
diskografie.php zobrazoval pouze alba, mohl by fungovat nějak takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select nazev from alba"</font><font color="#007700">,</font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)==</font><font color="#0000bb">0</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"--&nbsp;&nbsp;Není
vydáno žádné album --"</font><font color="#007700">;<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TABLE&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"nazev"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">endwhile;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/TABLE&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
</font></font></code></div>
<p>Pokud by měl obsahovat alba a písně, můžeme to provést například
tak, že vnoříme smyčku pro průchod písněmi do smyčky pro průchod alby.
Celá taškařice pak může vypadat nějak takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select id, nazev from
alba"</font><font color="#007700">,</font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)==</font><font color="#0000bb">0</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"--&nbsp;&nbsp;Není
vydáno žádné album --"</font><font color="#007700">;<br>
&nbsp;&nbsp;else<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;TABLE&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$album</font><font color="#007700">=</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;&lt;B&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"nazev"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/B&gt;&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vysledek2</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select nazev from pisne
join obsahyalb on pisne.id = obsahyalb.pisen where obsahyalb.album="</font><font color="#007700">.</font><font color="#0000bb">$album</font><font color="#007700">,</font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek2</font><font color="#007700">)==</font><font color="#0000bb">0</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"--&nbsp;&nbsp;Nejsou k dispozici písně na tomto albu
--"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam2</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek2</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TD&gt;<font color="#0000bb">&lt;?</font><font color="#007700">echo </font><font color="#0000bb">$zaznam2</font><font color="#007700">[</font><font color="#dd0000">"nazev"</font><font color="#007700">]</font><font color="#0000bb">?&gt;</font>&lt;/TD&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/TR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">endwhile;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#007700">endwhile;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;/TABLE&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
</font></font></code></div>
<p style="font-style: italic;">Pozn.: Kdybych byl v zanořování kódu
důsledný, vložím do jedné tabulky (s alby) jinou tabulku (s písněmi).
Protože ale vnořené tabulky nemám rád, raději jsem pokračoval v kódu
přidáním dalšího řádku do již existující tabulky. Pochopitelně,
fantazii se meze nekladou.</p>
<p>Všimněte si toho vnořeného databázového dotazu. Je to poprvé, co
jsme v seriálu použili dotaz obsahující klauzuli join, takže si to
pojďme vysvětlit. Dotaz nyní vybírá data ze dvou tabulek (pisne a
obsahyalb), přičemž tyto tabulky spojuje. To je v pořádku, protože nás
nezajímají názvy všech písní, ale jen názvy písní z určitého alba.
Tabulka písní však nemá o uspořádání alb ani ponětí, to znamená, že se
musí spojit s tabulkou obsahyalb a danou informaci dohledat. <br>
</p>
<p>Napsat</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">select nazev from pisne
join obsahyalb on pisne.id = obsahyalb.pisen where obsahyalb.album=1</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>je tedy úplně stejné jako napsat:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">select nazev from pisne,
obsahyalb where pisne.id=obsahyalb.pisen and obsahyalb.album=1</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Spojení jsou ve světě relačních databází na denním pořádku, proto
byste jim měli věnovat pozornost a dobře se je naučit, zejména pokud to
s prací s daty myslíte vážně.<br>
</p>
<p>V dalším díle seriálu se zamyslíme na tím, jak elegantně ošetřit
volbu zobrazení a budeme pokračovat dalšími úkoly.</p>
<a name="000334"></a><h2>Změny na portálu</h2>
<ul>
  <li>Nový soubor <a href="./examples/musicweb/8/diskografie.html">diskografie.php</a>
-
zatím nedokončený soubor pro zobrazení diskografie</li>
  <li>Nový soubor <a href="./examples/musicweb/8/albapisne.sql">albapisne.sql</a>
-
testovací data</li>
</ul>
<p>Projekt v současném stavu si můžete <a href="./examples/8.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span><br>
</p>
<a name="000335"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (79) - Triky s formuláři a ergonomie webu</h2>
			<p class="perex">Kterak si pomoci méně známými triky s formuláři při vývoji portálu? A což to vlastně je ergonomie webu?
				<br>
			</p>
			<p>Předchozí díl jsme zakončili smutným konstatováním, že soubor
diskografie.php nedělá to, co by měl. Jeho úkolem totiž bylo zobrazovat
názvy alb, nebo alb a zároveň písní. Dnes se podíváme, jak to dořešit.<span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000336"></a><h2>Triky s formuláři<br>
</h2>
<p>V díle, v němž se představovaly formuláře, jsem <a href="#000100">uvedl</a>,
že "klasický
formulář obsahuje nějaké prvky pro uživatelský vstup (třebas textová
pole) a nějaké prvky pro jeho odeslání". Rovněž Pavel Kácha v
sesterském <a href="http://www.linuxsoft.cz/article.php?id_article=355">seriálu
o HTML</a> prohlásil, že "webový formulář je část stránky složená z
různých tlačítek, vstupních
polí a přepínačů, která slouží pro získání nějakých dat od uživatele".
Ono to není úplně přesné. Může totiž existovat formulář, který bude
obsahovat pouze odesílací tlačítko!</p>
<p>V našem případě takové tlačítko může být "dvoustavové" a může
obsahovat pokyn pro zobrazení vydaných alb nebo pokyn pro zobrazení dat
a zároveň písní. Celý trik přitom může spočívat v tom, že provedená
akce se vyhodnotí podle toho, jaká byla hodnota value (a tedy i
popisek) na tlačítku. Můžeme tedy zobrazit formulář pomocí finty:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;input
name="zobrazeni" type="Submit" Value="<font color="#0000bb">&lt;?</font><font color="#007700">echo (</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"zobrazeni"</font><font color="#007700">]===</font><font color="#dd0000">"Zobrazit i písně"</font><font color="#007700">)? </font><font color="#dd0000">"Zobrazit jen alba"</font><font color="#007700">:</font><font color="#dd0000">"Zobrazit i písně"</font><font color="#0000bb">?&gt;</font>"&gt;</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a následně v kódu testovat zaslanou hodnotu nějak takto:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">if
(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"zobrazeni"</font><font color="#007700">]===</font><font color="#dd0000">"Zobrazit i písně"</font><font color="#007700">):<br>
</font><font color="#ff8000">// atd...<br>
</font><font color="#007700">endif;</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Mnoho dalších problémů s formuláři může vyřešit následující trik: Na
<span style="font-style: italic;">jedné </span>stránce můžete mít <span style="font-style: italic;">více </span>různých formulářů, z nichž <span style="font-style: italic;">dva či více</span> mohou provádět <span style="font-style: italic;">stejnou </span>akci! Například bychom
mohli chtít, aby se tlačítko pro modifikaci zobrazení objevilo nejen v
úvodu stránky, ale rovněž v její patě. Není nic jednoduššího než
vykopírovat definici formuláře na správné místo v dokumentu... a ono to
bude fungovat!<br>
</p>
<p>Při zobrazování více formulářů na jedné stránce můžeme samozřejmě
rovněž zapojit nějakou aplikační logiku. Tak třeba si budete přát, aby
se v zápatí objevilo tlačítko pouze v případě, kdy je zobrazen výpis
jak alb, tak písní. V tom případě můžete naprogramovat něco jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?</font><font color="#007700">if (</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"zobrazeni"</font><font color="#007700">]===</font><font color="#dd0000">"Zobrazit i písně"</font><font color="#007700">):</font><font color="#0000bb">?&gt;<br>
</font>&lt;form method="post" action="index.php?clanek=diskografie"&gt;<br>
&nbsp;&nbsp;&lt;input name="zobrazeni" type="Submit" Value="<font color="#0000bb">&lt;?</font><font color="#007700">echo (</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"zobrazeni"</font><font color="#007700">]===</font><font color="#dd0000">"Zobrazit i písně"</font><font color="#007700">)? </font><font color="#dd0000">"Zobrazit jen alba"</font><font color="#007700">:</font><font color="#dd0000">"Zobrazit i písně"</font><font color="#0000bb">?&gt;</font>"&gt;<br>
&lt;/form&gt;<br>
<font color="#0000bb">&lt;?</font><font color="#007700">endif;</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Metoda zobrazování formulářů obsahujících pouze tlačítka má
nespornou výhodu v tom, že nezatěžuje uživatele mnoha
ovládacími prvky a je nesmírně kompaktní. Jediným kliknutím na
odesílací tlačítko tak můžete například přepínat mezi "krátkým" a
"dlouhým"
zobrazením, jako je tomu u nás. <br>
</p>
<a name="000337"></a><h2>Pohodlné listování</h2>
<p>Pokud si budete se sezbnamem alb a písní chvíli hrát, zjistíte, že
je poměrně dlouhý. To má značnou nevýhodu - pokud budete v seznamu
někde nízko, bude návrat nahoru znamenat velké rolování. Což
představuje problém, protože všechny odkazy jsou v horní části webu.
Řešit se to dá různě - například použitím prvku IFRAME. To by ale
docela rozházelo náš celý návrh, takže se musíme porozhlédnout po něčem
jiném.<br>
</p>
<p>To "něco" jsou záložky. V záhlaví stránky může být definována
záložka, například pomocí kódu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;a
name="nahore"&gt;&lt;/a&gt;</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>A ve vhodné části stránky se pak na záložku můžeme přemístit:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"&lt;tr&gt;&lt;td&gt;&lt;a
href=\"#nahore\"&gt;Nahoru&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Záložky popisuje ve svém seriálu o HTML Pavel Kácha, takže se můžete
podívat, <a href="http://www.linuxsoft.cz/article.php?id_article=239">jak
to s nimi je</a>.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Pokud tomu, co Pavel
vysvětluje nebudete rozumět, pak vězte, že nejste sami. Pavel totiž
anglický výraz pro záložky, "bookmarks" překládá jako "návěští",
přestože to je nestandardní. Navíc, Pavel mixuje výklad o záložkách s
výkladem o odkazech, což jsou dvě různé věci. Jiný odkaz pro vysvětlení
záložek můžete najít třeba </span><a style="font-style: italic;" href="http://www.jakpsatweb.cz/zalozky.htm">zde</a><span style="font-style: italic;">.<br>
</span></p>
<a name="000338"></a><h2>Ergonomie webu</h2>
<p>Úvahám o snadnosti ovládání a přístupnosti navigace se souhrnně říká
<span style="font-style: italic;">ergonomie webu</span>. Obecný návod,
jak udělat ergonomický web neexistuje, takže Vám mohu nabídnout jen
několik osvědčených pravd, mezi nimiž musíte balancovat sami:</p>
<ul>
  <li>Obecně platí, že validní weby mají tendenci být ergonomické. Není
na tom nic divného, když si uvědomíte, že webové standardy jsou tu
hlavně proto, aby nám život s webem usnadnily. Bráno pochopitelně z
pohledu uživatele; co se týče vývojáře je to někdy spíše naopak</li>
  <li>Obecně platí, že krátké stránky mají tendenci být ergonomické.
Logicky - čím méně dat najednou uživateli nabídnete, tím spíše se v
nich neztratí.</li>
  <li>Stránky s chytře vymyšlenými kaskádovými styly mají rovnež
tendenci být ergonomické. Vždyť styly slouží k oddělení obsahu webu od
formy.</li>
</ul>
<p>Pokud si nejste jisti, zda je web dostatečně ergonomický, můžete
zkusit následující podněty:<br>
</p>
<ul>
  <li>Zkuste se na něm chvíli pohybovat a myslet přitom jako uživatel.
Pokud Vám něco bude připadat složité, asi to tak je.</li>
  <li>Posaďte k webu uživatele a sledujte jeho chování (třeba pohyby
myši). Pokud je zmatený, asi web příliš ergonomický nebude.</li>
</ul>
<p>K ergonomii webu v našem příkladu bychom mohli přispět, pokud bychom
kromě uvedených věcí ještě zvážili následující záležitosti:<br>
</p>
<ul>
  <li>Řazení záznamů pomocí klauzule ORDER BY v dotazech <a href="http://dev.mysql.com/doc/mysql/en/SELECT.html">SELECT</a> pro
MySQL databázi</li>
  <li>Stránkováním výpisů - což už v seriálu <a href="#000164">bylo</a>.</li>
</ul>
<a name="000339"></a><h2>Změny na portálu</h2>
<ul>
  <li>Změněný soubor <a href="./examples/musicweb/9/diskografie.html">diskografie.php</a>
- tentokrát jsme jej dokončili</li>
</ul>
<p>Projekt v současném stavu si můžete <a href="./examples/9.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span><br>
</p>
<a name="000340"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (80) - Administrace diskografie hudebního portálu</h2>
			<p class="perex">Někdy se může zadávání dat do databáze docela zesložitit. Uvidíme, jak se to dá zvládnout pomocí promyšlených formulářů.
				<br>
			</p>
			<p>Pojďme dnes začít řešit poměrně náročné téma - rozhraní pro
sestavování diskografie. Uvidíme, že to není jednoduché a že celá věc
má mnoho slepých uliček a zákoutí.<span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000341"></a><h2>Žonglování se třemi míčky<br>
</h2>
<p>Připomeňme, že datová struktura pro uchování informací o albech a
písních má tři tabulky - pisne, alba a obsahyalb. Do těchto tabulek
vlastě mudeme chtít zadávat data "najednou", což je docela problém.
Ukážeme si, jak by se na to například dalo jít.<br>
</p>
<p>Celý problém spočívá v tom, že chceme-li zadat píseň do alba, musíme
udělat dvě věci:<br>
</p>
<ul>
  <li>Založit píseň do tabulky písní (pokud tam ještě není)</li>
  <li>"Přiřadit" ji do alba</li>
</ul>
<p>Obdobě bychom při zakládání úplně nového alba nejprve museli album
vložit do tabulky a následně mu přidat obsah, tedy písně. Na webu se
nám problém může roztáhnout do mnoha jednotlivých skriptů, které se
budou vzájemně doplňovat a bude obtížné je spravovat. My se ale
pokusíme všechny operace vměstnat do jediného skriptu. Uvidíte, že při
troše pozornosti to není zas až tak složité.<br>
</p>
<a name="000342"></a><h2>Formuláře, kam se podíváš</h2>
<p>Jak jsme již uvedli <a href="#000335">minule</a>,
může jedna stránka obsahovat více shodných formulářů. Z nich se pak
zpracovává ten, který byl odeslán. Stejně tak je ale možné mít na
stránce několik různých formulářů. Ty mohou, ale nemusejí směřovat na
stejný zpracovávající skript (naše budou). Pokud vedou na stejný
skript, zajistí se zpracování podle toho, jakým tlačítkem byl skript
odeslán. Takže můžete mít tři formuláře s třemi ovládacími prvky typu
submit:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;input type="Submit"
name="odesli" value="aaa"&gt;<br>
&lt;input type="Submit" name="odesli" value="bbb"&gt;<br>
&lt;input type="Submit" name="odesli" value="ccc"&gt;<br>
<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Které pak zpracujete pomocí kódu ve smyslu:
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">if (</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"odesli"</font><font color="#007700">]==</font><font color="#dd0000">"aaa"</font><font color="#007700">) </font><font color="#ff8000">//atd..<br>
</font><font color="#007700">elseif (</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"odesli"</font><font color="#007700">]==</font><font color="#dd0000">"bbb"</font><font color="#007700">) </font><font color="#ff8000">//atd..<br>
</font><font color="#007700">elseif (</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"odesli"</font><font color="#007700">]==</font><font color="#dd0000">"ccc"</font><font color="#007700">) </font><font color="#ff8000">//atd..<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Navíc samozřejmě můžete mít jeden formulář s dvěma odesílacícmi
tlačítky a akci řídít podle toho, na které z nich se při odesílání
kleplo. Všechno tohle ve skutečnosti použijeme, a sestavíme stránku se
třemi formuláři:<br>
</p>
<ul>
  <li>První pro přidání písně do tabulky písní</li>
  <li>Druhý pro přidání alba do tabulky alb</li>
  <li>Třetí, který bude umět buď přidat (existující) píseň na
(existující) album nebo naopak píseň z alba odebrat</li>
</ul>
<p style="font-style: italic;">Pozn.: Protože administraci portálu si
můžete vyzkoušet pouze sami a ne tady na LinuxSoftu, ukážu to raději na
obrázku:<br>
</p>
<div style="text-align: center;"><img style="width: 559px; height: 233px;" alt="" src="img/formular_alba.jpg"></div>
<a name="000343"></a><h2>Potíže s MySQL<br>
</h2>
<p>Jedna otázka, na kterou v této fázi pravděpodobně narazíme je tato:
"Může být jedna píseň na jednom albu vícekrát?" Není to zase až takový
nesmysl, jak by se mohlo zdát, protože píseň může být například v jiné
úpravě na začátku alba a v jiné na jeho konci. To je přesně ten detail,
který byste asi v praxi řešili se zákazníkem. Alespoň uvidí, že to
promýslíte do sebemenšího detailu. My prohlásíme, že jedna píseň smí
být na jednom albu pouze jednou, a zajistíme to pomocí uníkátního
indexu na tabulce obsahyalb:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">ALTER TABLE `obsahyalb`
ADD UNIQUE (`album`,`pisen`)<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Když potom <a href="#000318">ošetříme
případnou chybu</a> vrácenou z MySQL, bude to stačit. Jak je z příkladu
vidět, MySQL umožňuje vytvořit unikátní index na dvou sloupcích,
samozřejmě pouze za předpokladu, že existující data nekolidují s nově
vytvářeným indexem.<br>
</p>
<p>Druhý problém, na nějž narazíte už při prohlížení rozevíracího
sesznamu písní je ten, že MySQL neumí česky řadit! Jak u mě doma, tak
na serveru Linuxsoft, tak i všude jinde, kde by to mohlo fungovat mi to
nefunguje. Pokud někdo máte fungující způsob, jak přinutit MySQL česky
řadit, sem s ním. Relevantní informace k českému řazení najdete
například <a href="http://www.fi.muni.cz/%7Eadelton/l10n/">zde</a>. <br>
</p>
<p style="font-style: italic;">Pozn.: České řazení je vůbec specifická
věc. Určuje jej <span id="_ctl0_MainContent_PostFlatView"><span id="_ctl0_MainContent_PostFlatView__ctl0_PostSubject" class="forumName">ČSN
97 6030 a odborníci se shodují na tom, že to ne norma obtížně
převeditelná do "počítačovštiny". Věřím tomu, a to nejen proto, že "ch"
je mezi "h" a "i".<br>
</span></span></p>
<p><span id="_ctl0_MainContent_PostFlatView"><span id="_ctl0_MainContent_PostFlatView__ctl0_PostSubject" class="forumName">My
problém s řazenímu budeme ignorovat. Pokud ale někdo máte uspokojivé
řešení, šup s ním do diskuse.<br>
</span></span></p>
<a name="000344"></a><h2><span id="_ctl0_MainContent_PostFlatView"><span id="_ctl0_MainContent_PostFlatView__ctl0_PostSubject" class="forumName">Podpůrné
funkce</span></span></h2>
<p>Dnes je to poprvé, co ve formulářích používáme rozevírací seznamy.
Ty mají dvě zvláštnosti - jednak nezačínají tagem &lt;input&gt; a
jednak může být jedna položka označena jako zvolená pomocí volby
selected. Protože rozevírací seznamy bývají plněny z databáze, sestavil
jsem si na to funkci:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#007700">function </font><font color="#0000bb">naplnseznam
</font><font color="#007700">(</font><font color="#0000bb">$albapisne</font><font color="#007700">, </font><font color="#0000bb">$zvoleno</font><font color="#007700">=</font><font color="#0000bb">0</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$options</font><font color="#007700">=</font><font color="#dd0000">""</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select id, nazev from
$albapisne order by nazev"</font><font color="#007700">,</font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;while (</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">]==</font><font color="#0000bb">$zvoleno</font><font color="#007700">)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$options</font><font color="#007700">.=</font><font color="#dd0000">"&lt;option value=\""</font><font color="#007700">.</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">].</font><font color="#dd0000">"\" selected&gt;"</font><font color="#007700">.</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"nazev"</font><font color="#007700">].</font><font color="#dd0000">"&lt;/option&gt;\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$options</font><font color="#007700">.=</font><font color="#dd0000">"&lt;option value=\""</font><font color="#007700">.</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">].</font><font color="#dd0000">"\"&gt;"</font><font color="#007700">.</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"nazev"</font><font color="#007700">].</font><font color="#dd0000">"&lt;/option&gt;\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;endwhile;<br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">$options</font><font color="#007700">;<br>
&nbsp;&nbsp;}</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Funkce je to celkem triviální, všimnout si v ní však můžete
předávání <a href="#000060">výchozí
hodoty parametru</a>, <a href="#000069">expanze
proměnné</a> a <a href="#000034">preinkrementace</a>.<br>
<br>
</p>
<a name="000345"></a><h2>Změny na portálu</h2>
<ul>
  <li>Nový soubor <a href="./examples/musicweb/10/zadejdiskografii.html">zadejdiskografii.php</a>
- zadávání alb a písní</li>
</ul>
<p>Projekt v současném stavu si můžete <a href="./examples/10.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span><br>
</p>
<a name="000346"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (81) - Uživatel versus programátor</h2>
			<p class="perex">Při
programování (nejen) v PHP by měl být na prvním místě VŽDY uživatel.
Dnešní díl seriálu o tvorbě hudebního portálu je krásným příkladem. <br>
			</p>
			<p>V předchozím díle jsme sestavili rozhraní pro zadávání alb a písní
do databáze. Zkusme dnes toto rozhraní ještě nějak vylepšit.<span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000347"></a><h2>Vylepšujeme rozhraní pro alba a písně<br>
</h2>
<p>Naše "diskografické" rozhraní je již docela schopné. Připomeňme si,
že pomocí šikovně rozstrkaných formulářů už umíme:</p>
<ul>
  <li>přidat píseň do seznamu písní<br>
  </li>
  <li>přidat album do seznamu alb</li>
  <li>přidat píseň do alba</li>
  <li>odebrat píseň z alba</li>
</ul>
<p>Člověku by se mohlo zdát, že je prostředí téměř dokonalé. Zkusme ale
chvíli uvažovat jako uživatel: Co bude pro administrátora webu zdaleka
nejčastější důvod k návštěvě stránky zadejdiskografii.php? Bude to
situace, kdy kapela vydá nové CD. Má v takovém případě nebohý
administrátor snadný život? Vlastně moc ne. Takový člověk totiž musí k
zadání dejme tomu deseti písní udělat následující věci:<br>
</p>
<ul>
  <li>Zadat album do seznamu alb</li>
  <li>Zadat píseň č.1 do seznamu písní</li>
  <li>... atd až do písně č. 10</li>
  <li>Přiřadit píseň č. 1 na album</li>
  <li>... atd až do písně č. 10</li>
</ul>
<p>Bystrý počtář sečte, že administrátor musí odklepat 21 formulářů! A
člověk ani nemusí být bystrý počtář, aby mu došlo, že administrátor
takového webu bude už u několikátého formuláře programátora proklínat.<br>
</p>
<p>Tento rozbor měl objasnit jednu věc: To, že jsme splnili nějaký úkol
ještě neznamená, že jsme jej splnili dobře! Pojďme se nyní podívat, jak
to s pomocí pár triků celé zajistíme jedním (!) jediným formulářem. Ten
formulář bude vypadat nějak takto:</p>
<p style="text-align: center;"><img style="width: 559px; height: 255px;" alt="" src="img/formular_alba2.jpg"><br>
</p>
<p>Asi každému je jasné, že práci s jedním formulářem uvítá každý
administrátor mnohem raději, než práci s jedenadvaceti formuláři. Jak
ale celý výstup formuláře ošetřit skriptem? Skript bude
muset provést následující věci:<br>
</p>
<ul>
  <li>Zjistit, zda album s daným názvem již neexistuje, pokud ano,
upozornit na to.</li>
  <li>Zadat album, zjistit si, jaké mu databáze přidělila číslo řádku v
tabulce alb</li>
  <li>Rozsekat seznam písní na jednotlivé písně</li>
  <li>Zjistit, zda tyto písně v databázi již jsou nebo ne; pokud nejsou
zapsat</li>
  <li>Přiřadit písně na album</li>
</ul>
<a name="000348"></a><h2>Realizace</h2>
<p>Skript zadejdiskografii.php tedy dozná mohutných změn. Bude
obsahovat čtvrtý formulář s jedním textovým polem pro zadání alba a s
dalším, víceřádkovým textovým polem pro zadání seznamu písní oddělených
koncem řádku. Rovněž část pro zpracování formuláře se nám poněkud
zvětší. Bude obsahovat především příkaz pro rozdělení jednotlivých
řádků do pole:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$pisne</font><font color="#007700">=</font><font color="#0000bb">explode</font><font color="#007700">(</font><font color="#dd0000">"\r\n"</font><font color="#007700">,</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">]);</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a rovněž funkci pro kontrolu každé jedné písně na délku:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">function
</font><font color="#0000bb">pisneok </font><font color="#007700">(</font><font color="#0000bb">$pisne</font><font color="#007700">)<br>
{<br>
&nbsp; </font><font color="#0000bb">$problem</font><font color="#007700">=</font><font color="#dd0000">""</font><font color="#007700">;<br>
&nbsp; foreach (</font><font color="#0000bb">$pisne </font><font color="#007700">as </font><font color="#0000bb">$pisen</font><font color="#007700">)<br>
&nbsp; {<br>
&nbsp;&nbsp;&nbsp; if ((</font><font color="#0000bb">strlen </font><font color="#007700">(</font><font color="#0000bb">$pisen</font><font color="#007700">)&gt;</font><font color="#0000bb">50</font><font color="#007700">) | </font><font color="#0000bb">strlen </font><font color="#007700">(</font><font color="#0000bb">$pisen</font><font color="#007700">)&lt;</font><font color="#0000bb">3</font><font color="#007700">) </font><font color="#0000bb">$problem</font><font color="#007700">.=</font><font color="#dd0000">"Název písně musí mít
3-50 znaků ($pisen)&lt;BR&gt;</font><font color="#007700">\n</font><font color="#dd0000">"</font><font color="#007700">;<br>
&nbsp; }<br>
&nbsp; echo </font><font color="#0000bb">$problem</font><font color="#007700">;<br>
&nbsp; return (boolean)(</font><font color="#0000bb">$problem</font><font color="#007700">===</font><font color="#dd0000">""</font><font color="#007700">);<br>
}</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Všimněte si, že tato funkce jednak vrací hodnotu TRUE nebo FALSE a
jednak vypisuje hlášení. Někteří programátoři razí teorii, že funkce by
měly pouze vracet hodnoty, zatímco příkazy echo by měly být umístěny
spíše v těle skriptu. Něco na tom je, ale pro nás by to znamenalo
vadnou píseň vypsat pomocí další funkce, což by bylo poměrně složité.
Název "vadné" písně bychom ale přece jen vypisovat měli, protože jinak
mezi několika či několika desítkami "dobrých" písní uživatel tu
"špatnou" bude obtížně hledat.<br>
</p>
<p>Skript dále obsahuje kontrolu toho, zda jsme vůbec zadali nějaké
písně, a to pomocí následujícího příkazu:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">elseif
(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">]==</font><font color="#dd0000">""</font><font color="#007700">) echo </font><font color="#dd0000">"Musíte zadat nějaké písně"</font><font color="#007700">;</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Někoho by mohlo napadnout kontrolovat počet prvků pomocí funkce
count() pole $pisne, ale to by nefungovalo. Důvodem je fakt, že funkce
explode vrátí v případě, kdy "dělící" řetězec nebyl nalezen celý
původní "dělený" řetězec. To platí i pro prázdný řetězec a počet prvků
pole $pisne tak vždy bude nejméně jeden! <br>
</p>
<p>V další části skriptu se program pokusí přidat do databáze album
(což může selhat) a pokud to neselže, zapamatuje si číslo alba pomocí
funkce mysql_insert_id. </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;mysql_query </font><font color="#007700">(</font><font color="#dd0000">"insert into alba (nazev) values ('"</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazevnovehoalba"</font><font color="#007700">].</font><font color="#dd0000">"');"</font><font color="#007700">, </font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$chyba </font><font color="#007700">= </font><font color="#0000bb">mysql_error</font><font color="#007700">(</font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$chyba</font><font color="#007700">===</font><font color="#dd0000">''</font><font color="#007700">) </font><font color="#0000bb">$albumid</font><font color="#007700">=</font><font color="#0000bb">mysql_insert_id</font><font color="#007700">();<br>
&nbsp;&nbsp;else echo </font><font color="#dd0000">"Album NEBYLO
přidáno. Databáze vrátila chybu $chyba &lt;BR&gt;</font><font color="#007700">\n</font><font color="#dd0000">"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Když i to skončí bez chyb, pustí se skript směle do zadávání písní.
U každé písně může nastat jedna ze dvou situací:<br>
</p>
<ol>
  <li>Píseň v databázi ještě není, a program ji tedy zadá a zjistí její
číslo v tabulce písní</li>
  <li>Píseň v databázi již je, a program tedy zjistí její číslo v
tabulce písní</li>
</ol>
<p>A konečně, pomocí čísla alba a čísla písně se již může založit řádek
v tabulce obsahyalb.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">foreach
(</font><font color="#0000bb">$pisne </font><font color="#007700">as </font><font color="#0000bb">$pisen</font><font color="#007700">)<br>
{<br>
&nbsp;&nbsp;</font><font color="#0000bb">$pisenid</font><font color="#007700">=</font><font color="#0000bb">pisenid</font><font color="#007700">(</font><font color="#0000bb">$pisen</font><font color="#007700">);<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$pisenid</font><font color="#007700">==</font><font color="#0000bb">0</font><font color="#007700">) <br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">mysql_query </font><font color="#007700">(</font><font color="#dd0000">"insert into pisne
(nazev) values ('"</font><font color="#007700">.</font><font color="#0000bb">$pisen</font><font color="#007700">.</font><font color="#dd0000">"');"</font><font color="#007700">, </font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$pisenid</font><font color="#007700">=</font><font color="#0000bb">mysql_insert_id</font><font color="#007700">();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;</font><font color="#0000bb">mysql_query </font><font color="#007700">(</font><font color="#dd0000">"insert into obsahyalb
(album, pisen) values ("</font><font color="#007700">.</font><font color="#0000bb">$albumid</font><font color="#007700">.</font><font color="#dd0000">","</font><font color="#007700">.</font><font color="#0000bb">$pisenid</font><font color="#007700">.</font><font color="#dd0000">");"</font><font color="#007700">, </font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
}</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<a name="000349"></a><h2>Závěr</h2>
<p>Vidíme, že uvažovat jako uživatel někdy znamená, že si programátor
pořádně znepříjemní život. Nicméně, uživateli se taková aplikace bude
lépe ovládat a proto si bude programátora považovat. Rovněž jsme
viděli, že zadávat data do více tabulek znamená důsledněji kontrolovat
mezivýsledky.<br>
</p>
<p>Náš skript zapisoval do více tabulek najednou. To je přesně akce,
kdy bychom potřebovali jeden z následujících mechanizmů:<br>
</p>
<ul>
  <li>aby databáze uměla převzít název alba a názvy písní, celé si to
odkontrolovat sama a uložit, co je potřeba</li>
  <li>aby databáze měla možnost BUĎ to celé provést NEBO to celé
neprovést, ale nic mezi tím</li>
</ul>
<p>Tomu prvnímu se říká uložená procedura a MySQL je zatím bohužel
neumí. Tomu druhému se říká transsakce a MySQL je bohužel opět neumí. V
tomto bodě musíme dát za pravdu tvrzení, že například taková PostgreSQL
by se s uvedenou úlohou vypořádala mnohem snadněji. O <a href="http://www.linuxsoft.cz/article_list.php?id_kategory=222">PostgreSQL</a>
píše na našem serveru <a href="http://www.linuxsoft.cz/user_page.php?user_id=1804">MaReK
Olšavský</a>, takže se o tom můžete něco dozvědět.<br>
</p>
<p>Příště se dozvíme něco o tom, jak tento skript ještě lépe vylepšit a
zabezpečit.</p>
<a name="000350"></a><h2>Změny na portálu</h2>
<ul>
  <li>Změněný soubor <a href="./examples/musicweb/11/zadejdiskografii.html">zadejdiskografii.php</a>
- zadávání alb a písní najednou</li>
</ul>
<p>Projekt v nynějším stavu si můžete <a href="./examples/11.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span><br>
</p>
<a name="000351"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (82) - zabezpečení vstupů formulářů</h2>
			<p class="perex">Formuláře se musí zabezpečit. O prvku TEXTAREA, jak uvidíme, to platí dvojnásob, protože je specifický.
				<br>
			</p>
			<p>Jak začít... co třeba citací slov Honzy Houšťka, který v diskusi pod
jedním článkem našeho seriálu&nbsp; napsal: "Spoléhat se na nějakou
vlastnost PHP je cesta do pekel". Bylo to v diskusi kolem zabezpečení
uživatelských vstupů. Což se svým podstatným způsobem týká
formulářového prvku TEXTAREA, který jsme minule použili pro zadávání
písní.<br>
</p>
<p>Tento prvek bývá v PHP mnohdy často špatně zabezpečen. Pojďme se
tedy
podívat na dva možné obecné zdroje problémů s tímto prvkem a na
jeden&nbsp; specifický problém, týkající se způsobu, jak je použit v
naší aplikaci. <span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000352"></a><h2>Velikost prvku TEXTAREA</h2>
<p>V předchozím díle jsme nijak neomezili množství dat, která uživatel
může zadat do pole TEXTAREA. Respektive kontrolujeme pouze, zda je
vůbec v tomto poli po odeslání něco vyplněno. Takže uživatel by mohl do
pole nacpat vědomně či nevědomně příliš mnoho dat a naši aplikaci tak
zahltit. To je samozřejmě stav, který nemůžeme strpět. V samotném
formuláři sice nastavit maximální počet znaků jednoduše nemůžeme,
můžeme ale kontrolovat velikost proměnné po odeslání na server.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Napsat, že nemůžeme omezit
maximální počet znaků je nepřesné. Ve skutečnosti to můžeme udělat
pomocí skriptů běžících na straně prohlížeče, jako je třeba JavaScript.
Jednak je to ale mimo rámec našeho seriálu a jednak je to nespolehlivé,
protože JavaScript může být v prohlížeči vypnut, nebo jej prohlížeč
vůbec nemusí podporovat.<br>
</span></p>
<p>Můžeme ale udělat ještě víc. Nejen, že můžeme kontrolovat
celkovou délku zaslaných dat, můžeme kontrolovat rovněž do kolika řádků
(tedy, v našem případě písní) se bude pole dělit. Prohlašme například,
že album může mít maximálně 30 písní a že celková délka dat z pole
textarea bude 1500 znaků. V takovém případě bychom mohli naše testy
rozšířit následovně:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">elseif
(</font><font color="#0000bb">strlen </font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">])&gt;</font><font color="#0000bb">1500</font><font color="#007700">) echo </font><font color="#dd0000">"Máte zadáno příliš mnoho písní"</font><font color="#007700">;<br>
elseif (</font><font color="#0000bb">count</font><font color="#007700">(</font><font color="#0000bb">$pisne</font><font color="#007700">)&gt;</font><font color="#0000bb">30</font><font color="#007700">) echo </font><font color="#dd0000">"Máte zadáno příliš mnoho písní"</font><font color="#007700">;</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Tím bude zajištěno, že při překročení tohoto limitu se vůbec
nedostaneme k databázovým dotazům.<br>
</p>
<p style="font-style: italic;">Pozn.: Pro zvídavé - maximální velikost
dat formuláře, který PHP vůbec odešle není pochopitelně neomezená.
Nastavuje se pomocí volby post_max_size v konfiguračním souboru
php.ini. Teoreticky by se tato volba dala i nastavovat pomocí funkce
ini_set(), v praxi to však povětšinou bývá zakázáno.<br>
</p>
<a name="000353"></a><h2>TEXTAREA a HTML</h2>
<p>Další moc špatná věc je ta, že TEXTAREA je párový prvek a hodnota
uvnitř prvku se nezapisuje jako parametr dovnitř tagu, ale normálně do
stránky jako text. Porovnejte, prosím, dva následující zápisy prvků s
předdefinovaným textem "abc", jednu TEXTAREU a jeden text:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">&lt;textarea rows="1"
cols="20"&gt;abc&lt;/textarea&gt;<br>
&lt;input type="text" value = "abc"&gt;<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Pravděpodobně si dokážete představit, jak by to dopadlo, kdyby někdo
místo <span style="font-style: italic;">abc </span>zadal jiné znaky,
třeba <span style="font-style: italic;">&lt;/textarea&gt;</span>. To
by mohlo naši aplikaci přinejmenším rozhodit, přinejhorším dokonce
poškodit. Řešení je několik; víceméně se liší tím, zda nám při
nesprávně vyplněném formuláři vrátí opravdu původní nebo již upravené
hodnoty. Podle mě nemají HTML tagy v názvech písní co dělat, a mohu
proto hned na úvod zpracování příslušného skriptu napsat:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">]=</font><font color="#0000bb">strip_tags</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">]);</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a všechny tagy zkrátka vymazat. Pokud by se uživatel musel k
vyplňování vrátit, už je tam neuvidí. Jiný dobrý způsob spočívá v
použití funkce <a href="http://cz.php.net/manual/cs/function.htmlspecialchars.php">htmlspecialchars</a>,
která
převede zvláštní znaky (jako jsou třeba "&lt;" a "&gt;") na html entity:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">]=</font><font color="#0000bb">htmlspecialchars</font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">]);</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Co konkrétního použitete, záleží pochopitelně na vás. Platí tady to,
že jakékoli ošetření vstupního pole je zcela určitě lepší než žádné a
na potíže při použití prvku textarea by se rozhodně mělo myslet.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Někteří programátoři tvrdí,
že přímá modifikace proměnné $_POST["cosi"] ztěžuje čitelnost kódu. Je
to však věc pohledu; z hlediska PHP je to jen obyčejná proměnná a v
našem případě je její modifikace to nejjednodušší, co můžeme udělat.
Pokud by to nevyhovovalo vašim nebo firemním standardům, můžete to
objít třebas uložením výsledku do jiné proměnné. </span><br>
</p>
<a name="000354"></a><h2>TEXTAREA a náš formulář</h2>
<p>V programu máme ještě jedno slabé místo, které sice souvisí s prvkem
TEXTAREA, ale nesouvisí přímo se zabezpečením. Jde o to, že chování
rozdělování řádků je uživatelsky neintuitivní. Nejdřív na to narazí
ten, kdo se pokusí odřádkovat i za poslední písní - obdrží varovnou
hlášku. Program to myslí dobře - zdá se mu, že uživatel zadal píseň s
nulovým počtem znaků. To ale bude uživatele mást.<br>
</p>
<p>Zase je více správných řešení. Mohli bychom například závěrečný
konec řádku odmazat. To ale neřeší problém, kdy uživatel odřádkuje
vícekrát. Rovněž to neřeší problém dvou či více následujících konců
řádku uvnitř textu! To je případ, kdy s výhodou můžeme použít sílu
<a href="#000090">regulárních
výrazů</a>. Mě se osvědčilo řešení ve stylu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">]=</font><font color="#0000bb">ereg_replace</font><font color="#007700">(</font><font color="#dd0000">"(\r\n)+"</font><font color="#007700">, </font><font color="#dd0000">"\r\n"</font><font color="#007700">, </font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">]);<br>
</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">]=</font><font color="#0000bb">ereg_replace</font><font color="#007700">(</font><font color="#dd0000">"(</font><font color="#007700">\r\n</font><font color="#dd0000">)</font><font color="#007700">$</font><font color="#dd0000">"</font><font color="#007700">, </font><font color="#dd0000">""</font><font color="#007700">, </font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"nazvynovychpisni"</font><font color="#007700">]);</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Což přeloženo do češtiny znamená: Najdi všechny výskyty minimálně
jednou se opakujícího konce řádku a nahraď to právě jedním koncem
řádku. Tím nám zmizí všechna vícenásobná odřádkování, ale ne to
poslední. K čemuž je tu ten druhý řádek, který by se dal převyprávět
jako: Pokud řetězec končí koncem řádku, ten konec řádku umaž.<br>
</p>
<p>Jiné dobré řešení může spočívat v použití funkce <a href="http://cz.php.net/manual/cs/function.split.php">split</a>
namísto explode pro získání pole s písněmi. Zatímco totiž explode dělí
řetězec řetězcem, dělí split řetězec regulárním výrazem. Je to ale jen
pro silné nátury ovládající "regulární výrazivo".<br>
</p>
<a name="000355"></a><h2>Závěr</h2>
<p>Vidíme tedy, že trochu zabezpečit prvek textarea není sice složité,
ale že si to musíme trochu promyslet. Obecně platí, že když použijete
"uživatelsky" jednodušší rozhraní, přiděláte tím práci programátorovi
při ověřování vstupu. V případech, jako je tento, to ale má své
opodstatnění.</p>
<a name="000356"></a><h2>Změny na portálu</h2>
<ul>
  <li>Změněný soubor <a href="./examples/musicweb/12/zadejdiskografii.html">zadejdiskografii.php</a>
- zabezpečení prvku textarea</li>
</ul>
<p>Projekt v nynějším stavu si můžete <a href="./examples/12.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span><br>
</p>

<a name="000357"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (83) - Ukládání textů písní na hudebním portále</h2>
			<p class="perex">Dnes sa podíváme na způsoby, jakými lze uložit na portále obsáhlá data a vybereme si metodu, která se nám nejlépe hodí.
				<br>
			</p>
			<p>Opusťme teď na portále správu alb a písní a věnujme se pár dílů
práci s texty písní. Uvidíte, že i tady je co promyslet a také co
zkazit. Ukládání textů písní je totiž práce s podstatně obsáhlejšími
informacemi než například ukládání jejich názvů.<br>
</p>
<a name="000358"></a><h2>Texty písní</h2>
<p>Připomeňme si, že portál by měl umět v oblasti textů písní
následující funkce:</p>
<ul>
  <li>Půjde zveřejnit jen text k písni, která již je v databázi </li>
  <li>Bude to moci dělat jen administrátor </li>
  <li>Text písně se bude dát exportovat do textového souboru </li>
  <li>Texty písní budou k dispozici jen pro registrované uživatele </li>
</ul>
<p>Nejprve tedy zanalyzujme ukládání textů písní. Asi každému je jasné,
že pro zadání textu písně lze použít přinejmenším dvou metod:</p>
<ol>
  <li>Formulář s prvkem TEXTAREA, do něhož se text písně napíše, nebo</li>
  <li>Formulář odesílající připravený text jako soubor z klienta na
server.</li>
</ol>
<p>Obojí má samozřejmě svoje výhody a nevýhody. Výhodou odesílání
textového souboru může být to, že si jej správce v klidu připraví na
svém počítači. Má to ale i nevýhody - tak například nebude jednoduché
zjistit, v jaké znakové sadě dodaný soubor vůbec je. Při zadávání textů
do prvku TEXTAREA můžeme spoustu věcí <a href="#000351">ovlivnit</a>,
ale není to zase až tak pohodlné. My se rozhodneme pro druhou variantu,
a to zejména z výukových důvodů. Práce s prvkem TEXTAREA už tu na
portále totiž byla, kdežto nahrávání souborů zatím v seriálu bylo pouze
<a href="#000133">teoreticky</a>.<br>
</p>
<p>Rovněž ukládání textů písní na serveru lze vyřešit dvojím způsobem:<br>
</p>
<ol>
  <li>Ukládáním do databází</li>
  <li>Ukládáním do souboru na disku (resp. webu)</li>
</ol>
<p>Opět platí, že každé řešení má své pro a proti. Ukládání do suboru
na disku je podstatně jednodušší na naprogramování, ale bývá obtížné
zajistit, aby se k souboru dostal pouze ten, kdo k němu smí mít
přístup. Naopak v případě
uložení textů do databáze platí, že je to složitější na napsání, ale
bezpečnější. Jelikož máme požadavk ukazovat texty pouze přihlášeným
uživatelům, sáhneme k databázovému řešení a budeme texty ukládat do
MySQL.</p>
<p><span style="font-style: italic;">Pozn.: Další výhoda souborů
spočívá v tom, že narozdíl od databází je práce s nimi rychlejší. V
našem případě bude ale rozdíl zanedbatelný, protože zpracováváme
relativně krátká data.<br>
</span></p>
<a name="000359"></a><h2>Databáze</h2>
<p>Mezi písněmi a texty má být vztah - má jít zveřejnit pouze text
písně, která již je v databázi. To znamená, že buď:</p>
<ol>
  <li>Bude existovat další pole v tabulce písní, do něhož budeme
ukládat text písně, nebo</li>
  <li>Bude existovat samostatná tabulka, obsahující pouze texty, a
součástí tabulky bude sloupec s číslem písně.</li>
</ol>
<p>Ačkoli obě řešení se bez problémů dají použít, má i toto rozhodnutí
svá úskalí. Pokud bychom definovali další sloupec na tabulce pisne,
může se nám struktura tabulky zvětšit a práce s tabulkou zpomalit. To
bude platit tím více, čím více písní v tabulce bude. Naproti tomu při
použití externí tabulky vzroste režie pro výpočet spojení před
zobrazením. Tady je těžké radit, v praxi se používá obojí.<br style="font-style: italic;">
</p>
<p style="font-style: italic;">Pozn.:Kdybyste to potřebovali, tady je
hrubý návod, jak se v praxi rozhodnout správně:<br>
</p>
<ol>
  <li style="font-style: italic;">Do tabulky vložte 2x tolik dat, než
tam bude v reále.</li>
  <li style="font-style: italic;">Změřte časovou náročnost obou variant</li>
  <li><span style="font-style: italic;">Rozhodněte se, které pomalé
řešení vám méně vadí a to použijte.</span></li>
</ol>
<p>V našem případě opět platí, že to nebude s časem až tak žhavé, a
zvolíme třebas tu druhou variantu, s uložením textů písní do samostatné
tabulky.<br>
</p>
<p>Další pozornost musíme věnovat volbě typu pole pro uložení dat textu
písně. Typy <a href="http://dev.mysql.com/doc/mysql/en/CHAR.html">char
a varchar</a> nevyhoví, protože obsáhnou pouze 255 znaků a to by na
text písně nestačilo. Musíme tedy použít sloupec typu <a href="http://dev.mysql.com/doc/mysql/en/BLOB.html">blob, resp. text</a>.
A protože tinytext má zase jen 256 znaků, bude to ve finále pole typu
text, které našemu záměru vyhoví nejlépe (má možnost uložit až 65535
znaků). Náš
příkaz pro tvorbu tabulky by tedy mohl vypadat následovně:<br>
<!-- Zaza PHP kód BEGIN -->
</p>
<div class="codes"><code><font color="#000000">CREATE TABLE `texty` (<br>
`id` INT NOT NULL AUTO_INCREMENT ,<br>
`pisen` INT NOT NULL ,<br>
`textpisne` TEXT NOT NULL ,<br>
PRIMARY KEY ( `id` )<br>
);<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Pozor, pole pro zadání textu nebudeme pojmenovávat text, ale
textpisne. Přestože je to delší, je to nutné. Text je totiž rezervované
slovo a MySQL by jej považovala za název datového typu a ne za název
sloupce. <br>
</p>
<a name="000360"></a><h2>Zabezpečení</h2>
<p>Protože správu uživatelů již máme hotovou, bude zamyšlení nad
zabezpečením skriptu vlastně jen rekapitulace. Zadávat texty bude smět
pouze administrátor. K tomu využijeme již existující funkci jeadmin a
na začátek zadávacího skriptu napíšeme:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
</font><font color="#007700">if (!</font><font color="#0000bb">jeadmin</font><font color="#007700">()) return;<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Podobnou funkci můžeme vytvořit i pro detekci, zda je vůbec nějdo
přihlášen. Protože stačí kontrolovat, zda je nastavena session proměnná
ID, bude to velmi triviální funkce:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">function
</font><font color="#0000bb">jeprihlasen </font><font color="#007700">()<br>
{<br>
&nbsp;&nbsp;if (isset(</font><font color="#0000bb">$_SESSION</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])) return </font><font color="#0000bb">true</font><font color="#007700">; else return </font><font color="#0000bb">false</font><font color="#007700">;<br>
}</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>A tu pak můžeme použít pro rozhodování, zda aktuálnímu uživateli
stránek zobrazit text písně či nikoli. V dalším díle tyto víceméně
teoretické poznatky poslepujeme do funkčního skriptu.</p>

<a name="000361"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (84) - Ještě k registraci</h2>
			<p class="perex">Chybovati je lidské, aneb proč se někteří uživatelé nemohli na náš cvičný portál registrovat.
				<br>
			</p>
			<p>Dnes budeme řešit záležitost mimo plán - i takové věci se při vývoji
software stávají. Budeme řešit reálný problém, který vznikl s
registrací na tomto cvičném portálu. Je to naléhavé, protože většina
věcí bez funkčního přihlašování nejde vyzkoušet.<br>
</p>
<a name="000362"></a><h2>Problém s přihlašováním<br>
</h2>
<p>Pravděpodobně si vzpomínáte, že registrační skript generoval e-mail,
který obsahoval instrukce k dokončení registrace. Vtip spočívá v tom,
že uživatel si musí e-mail stáhnout a zařídit se podle instrukcí v něm
obsažených. To v našem případě reprezentuje kliknutí na odkaz. A ten
vede na stránku pro dokončení registrace. Pro osvěžení kód, který mail
generuje:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
$path</font><font color="#007700">=</font><font color="#dd0000">"http://"</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SERVER_NAME"</font><font color="#007700">].</font><font color="#dd0000">":"</font><font color="#007700">.</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SERVER_PORT"</font><font color="#007700">].</font><font color="#0000bb">$_SERVER</font><font color="#007700">[</font><font color="#dd0000">"SCRIPT_NAME"</font><font color="#007700">].<br>
&nbsp;&nbsp;</font><font color="#dd0000">"?clanek=registracedokoncena&amp;amp;id="</font><font color="#007700">.</font><font color="#0000bb">$lastid</font><font color="#007700">.</font><font color="#dd0000">"&amp;amp;email="</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"email"</font><font color="#007700">];<br>
&nbsp;&nbsp;</font><font color="#0000bb">$telo </font><font color="#007700">= </font><font color="#dd0000">"Dekujeme Vam za
registraci na nasem portale [nazev hudebniho portalu]. Pro dokonceni "</font><font color="#007700">.<br>
&nbsp;&nbsp;</font><font color="#dd0000">"registrace klepnete na
nasledujici odkaz</font><font color="#007700">\n</font><font color="#dd0000">&lt;a href=</font><font color="#007700">\"</font><font color="#dd0000">$path</font><font color="#007700">\"</font><font color="#dd0000">&gt;$path&lt;/a&gt;</font><font color="#007700">\n</font><font color="#dd0000">"</font><font color="#007700">.<br>
&nbsp;&nbsp;</font><font color="#dd0000">"Pokud jste se na nasem
portale nechteli zaregistrovat, povazujte tento e-mail za
bezpredmetny.\n"</font><font color="#007700">.<br>
&nbsp;&nbsp;</font><font color="#dd0000">"Vas [nazev hudebniho portalu]
team."</font><font color="#007700">;<br>
&nbsp;&nbsp;@</font><font color="#0000bb">mail </font><font color="#007700">(</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"email"</font><font color="#007700">], </font><font color="#dd0000">"Registrace na
portalu"</font><font color="#007700">, </font><font color="#0000bb">$telo</font><font color="#007700">);</font><br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>V kódu nebylo nic závadného, a nic závadného nebylo ani v kódu,
který registraci dokončuje:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
mysql_query</font><font color="#007700">(</font><font color="#dd0000">"update
uzivatele set registracedokoncena=1 where id="</font><font color="#007700">.</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">].</font><font color="#dd0000">" and email='"</font><font color="#007700">.</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"email"</font><font color="#007700">].</font><font color="#dd0000">"';"</font><font color="#007700">,</font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"Vaše registrace byla
dokončena."</font><br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Přes to přeze všechno kód některým uživatelům nefungoval. Jak se
zdá, je to proto, že v proměnné $path je použito znaků, &amp;amp; jako
entity ampersandu. Je tomu tak proto, že to vyžaduje <a href="http://www.htmlhelp.com/tools/validator/problems.html#amp">norma</a>
a je to jistě správně. Někteří e-mailový klienti však mají se
zpracováním takto napsaných odkazů problém a hodnoty parametrů clanek,
id a email jsou předávány špatně nebo vůbec.<br>
</p>
<p>Řešení jsou v podstatě tři. Je možné:<br>
</p>
<ol>
  <li>Místo &amp;amp; psát pouze ampersand. To nechceme, není to podle
normy.<br>
  </li>
  <li>Přepsat portál tak, aby odkaz na registraci nevyžadoval. To je v
našem případě poměrně problematické, protože by to znamenalo změnit
celou logiku zpracování registrace.</li>
  <li>Přestat používat ve zprávě HTML tagy a posílat ji jako prostý text</li>
</ol>
<p>My se pustíme tím třetím směrem a přepíšeme text zprávy tak, aby
neobsahoval žádné HTML tagy. Neboli, ze zprávy ve formátu HTML uděláme
zprávu ve formátu "prostý text". Sice to znamená, že uživatel nebude
moci pohodlně dokončit registraci kliknutím na odkaz ve svém e-mailovém
klientovi, ale:</p>
<ul>
  <li>Zato to bude fungovat se všemi e-mailovými klienty včetně těch,
kteří odkazy nepodporují</li>
  <li>Většina pošťáků si stejně bude hrát na chytré a odkaz z toho
vytvoří. Doufejme, že správný.</li>
</ul>
<a name="000363"></a><h2>Chyba plodí chybu</h2>
<p>Aby toho nebylo málo, ukázalo se zároveň, že informační hláška po
dokončení registrace "Vaše registrace byla dokončena" je v případě
problémů s posíláním parametrů v odkazech v podstatě nesmyslná.
Informuje nás totiž o něčem, co není pravda. Abychom měli jistotu, že
se dotaz skutečně podařilo v databázi provést, měli bychom udělat
nějaké testy. Tak například bychom mohli testovat, zda se tím příkazem
změnil <span style="font-style: italic;">právě jeden</span> řádek v
databázi. Pokud se tak nestalo (nejspíš proto, že dotaz neaktualizoval
žádný řádek), neměli bychom tvrdit, že "registrace byla dokončena".
Úprava může spočívat v následujícím kódu:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#007700">if (</font><font color="#0000bb">mysql_affected_rows</font><font color="#007700">()==</font><font color="#0000bb">1</font><font color="#007700">) echo </font><font color="#dd0000">"Vaše registrace
byla dokončena."</font><font color="#007700">;<br>
&nbsp;&nbsp;else echo </font><font color="#dd0000">"Příkaz nebyl
proveden, zřejmě jsou nesprávné parametry nebo již registrace byla
dokončena"</font><font color="#007700">;</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Funkce <a href="http://cz.php.net/manual/en/function.mysql-affected-rows.php">mysql_affected_rows</a>
se zhruba podobná funkci <a href="http://cz.php.net/manual/en/function.mysql-num-rows.php">mysql_num_rows</a>
až na to, že se používá pro zjišťování počtu řádků ovlivněných akčními
dotazy, kdežto mysql_num_rows je pro počet řádků vrácených výběrovými
dotazy.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Akční dotazy jsou takové,
které mění stávající data. Jako například INSERT, UPDATE, DELETE a
některé další. Výběrové dotazy jsou ty, začínající slovem SELECT.<br>
</span></p>
<a name="000364"></a><h2>Je to bezpečné?</h2>
<p>Tak, chyba byla zažehnána. Když už jsme u registrace, nabízí se
ještě jedna otázka: Je posílání identifikačního čísla a e-mailu
uživatele bezpečné? Diplomatická odpověď je ta, že ne až tak úplně. Při
troše důvtipu by totiž mohl útočník vyzkoušet různé kombinace parametrů
id a při troše štěstí by se mu mohlo povést dokončit registraci i v
případě, že by daný e-mail vůbec neexistoval! Navíc by každý, kdo by se
dostal k přenášené poště mohl ze zprávy vyčíst identifikátor a
e-mailovou adresu právě přihlašovaného uživatele.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Nám by to na testovacím
portále sice zase až tak nevadilo, ale v praxi by mohlo být ověření
funkční adresy pro portál klíčové a možnost zaregistrovat se bez
uvedení platného e-mailu by mohla mít fatální důsledky. Stejně fatální
by mohlo být vyluštění citlivých informací z e-mailu.</span><br>
</p>
<p>Tak či tak, nastíníme si řešení, které má oproti našemu současnému
dvě podstatné výhody:<br>
</p>
<ol>
  <li>Namísto dvou parametrů id a email se skriptu posílá pouze jeden
parametr. Ne snad, že by to vyřešilo problémy s ampersandy ve zprávě,
ale bude to kompaktnější.</li>
  <li>Přenášený údaj bude zašifrovaný a bude mu rozumět zase jen
registrační skript</li>
</ol>
<p>Dosáhnout toho není zas až tak složité, jak by se mohlo na první
pohled zdát. Pokud využijeme poznatky z <a href="#000219">51.dílu
našeho seriálu</a> o předávání dat pomocí parametrů, máme prakticky
vystaráno. Kód by mohl vypadat nějak takto:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
$sifra</font><font color="#007700">= new </font><font color="#0000bb">Crypt_Xtea</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$citlive</font><font color="#007700">=</font><font color="#0000bb">$lastid</font><font color="#007700">.</font><font color="#dd0000">"|"</font><font color="#007700">.</font><font color="#0000bb">$_POST</font><font color="#007700">[</font><font color="#dd0000">"email"</font><font color="#007700">];<br>
&nbsp;&nbsp;</font><font color="#0000bb">$citlive</font><font color="#007700">=</font><font color="#0000bb">urlencode</font><font color="#007700">(</font><font color="#0000bb">base64_encode</font><font color="#007700">(</font><font color="#0000bb">$sifra</font><font color="#007700">-&gt;</font><font color="#0000bb">encrypt</font><font color="#007700">((string)</font><font color="#0000bb">$citlive</font><font color="#007700">, </font><font color="#dd0000">"[šifrovací klíč]"</font><font color="#007700">)));</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Telegraficky řečeno využívá se šifrování pomocí třídy Crypt_Xtea.
Parametry se spojí do jednoho a zašifrují. Použití znaku "|" jako
oddělovače je bezpečné, protože ani identifikátor ani e-mail jej
nebudou obsahovat. Skript pro dokončení registrace pak může vypadat
nějak takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">
&nbsp;&nbsp;$sifra</font><font color="#007700">= new </font><font color="#0000bb">Crypt_Xtea</font><font color="#007700">;&nbsp;&nbsp;<br>
&nbsp;&nbsp;</font><font color="#0000bb">$citlive</font><font color="#007700">=</font><font color="#0000bb">$sifra</font><font color="#007700">-&gt;</font><font color="#0000bb">decrypt</font><font color="#007700">(</font><font color="#0000bb">base64_decode</font><font color="#007700">(</font><font color="#0000bb">urldecode</font><font color="#007700">(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">])),</font><font color="#dd0000">"[šifrovací klíč]"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$udaje</font><font color="#007700">=</font><font color="#0000bb">explode</font><font color="#007700">(</font><font color="#dd0000">"|"</font><font color="#007700">,</font><font color="#0000bb">$citlive</font><font color="#007700">);<br>
</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>... a následuje zápis do databáze, jak jej známe. Přičemž klíč musí
být pochopitelně stejný jako ten, který jsme použili při šifrování.
Proč jsou tam zahrnuty funkce base64_encode, base64_decode, urlencode a
urldecode se dozvíte v 51. díle, kde je to rozebráno podrobněji.
Zkráceně řečeno je to proto, aby se řetězec bezpečně přenesl jako text,
přestože může být binární.<br>
</p>
<p>Poděkování za objev "zakopaného psa" patří Honzovi Houšťkovi, který
přišel na to, že problémy při dokončování registrace způsobují
mechanizmy, kterými někteří e-mailoví klienti zpracovávají odkazy v
HTML zprávách. <br>
</p>
<a name="000365"></a><h2>Úloha komunity</h2>
<p>V tomto bodě se hodí připomenout výhody sdílení kódu s jinými
vývojáři, snad pod nějakou svobodnou licencí. Mají-li totiž ostatní
přístup k tomu, co vyvíjíte, mohou se podobné problémy objevit a
vyřešit mnohem pravděpodobněji, než když na projektu pracuje jeden
vývojář nebo jen uzavřená skupina lidí. Proto byste při vývoji
vlastního software měli minimálně <span style="font-style: italic;">uvažovat
</span>o tom, zda a za jakých podmínek by bylo možné zpřístupnit vaši
práci ostatním vývojářům. GNU/Linux je na tomto principu založen a
funguje. Nemá to nic společného s tím, zda za svou práci budete chtít
peníze či nikoli; více se můžete dozvědět studiem příslušných licencí.
Každopádně pozitivní vliv spolupráce více lidí při tvorbě kódu je
nesporný.</p>
<a name="000366"></a><h2>Změny na portále</h2>
<p>Především, všechny nedokončené žádosti o registraci byly z databáze
odstraněny, takže se můžete znovu registrovat, pokud to předtím
nefungovalo. Byly změněny soubory <a href="./examples/musicweb/13/registrace.html">registrace.php</a>
a
<a href="./examples/musicweb/13/registracedokoncena.html">registracedokoncena.php</a>.
A byly přidány moduly pro šifrování. Portál v
současném stavu portálu si můžete <a href="./examples/13.zip">stáhnout</a> ve formátu zip.</p>
<a name="000367"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (85) - ukládání souborů do databáze na portálu</h2>
			<p class="perex">Dnes se zaměříme na práci s texty písní - a na jejich ukládání do databáze. Náš hudební portál tak získá nové funkce.
				<br>
			</p>
			<p>Třebaže minule jsme řešili naléhavé problémy s přihlašováním,
vrátíme se dnes k tématu, nadhozenému v <a href="#000357">předminulém
díle</a> seriálu. Půjde o ukládání a zobrazování textů písní na našem
hudebním webu. Rozbor situace už jsme provedli a řekli jsme si, že
budeme nahrávat texty písní ze souboru, že je budeme ukládat do
databáze a že na to použijeme samostatnou tabulku.<br>
</p>
<a name="000368"></a><h2>Index v databázi</h2>
<p>Zatm prázdná tabulka texty má jednu vadu. Tak, jak je definována,
umožňuje zadat více textů k jedné písni. Což je v našem případě logický
nesmysl. Tabulku můžeme rychle umravnit přidáním unikátního indexu k
poli pisen, což nám umožní zadat ke každé písni nejvýše jeden text.</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">ALTER TABLE `texty` ADD
UNIQUE (<br>
`pisen`<br>
)</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Ačkoli jsem se o tom příležitostně zmiňoval už jinde, tvorba
unikátních indexů má podstatný smysl, protože přenáší část aplikační
logiky na databázi. To oceníte zejména v případě, pokud bude s jednou
databází pracovat více aplikací.<br>
</p>
<a name="000369"></a><h2>Co neumím</h2>
<p>Upřímně řečeno se mi nepodařilo vyřešit problém spočívající v tom,
že nahrávaný soubor může být kódován lecjak. My budeme za "správné"
kódování považovat UTF-8, protože jak web, tak databázi máme celou v
tomto kódování. Co však, když někdo dodá soubor v jiné znakové sadě,
například ISO-8859-2? Obecně řečeno existuje možnost, jak obsah souboru
načíst do proměnné a překonvertovat pomocí <a href="http://cz.php.net/manual/en/ref.iconv.php">funkcí pro konverze
znakových sad</a>, nějak takto:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">iconv</font><font color="#007700">(</font><font color="#dd0000">"ISO-8859-2"</font><font color="#007700">, </font><font color="#dd0000">"UTF-8"</font><font color="#007700">, </font><font color="#0000bb">$textpisne</font><font color="#007700">)</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-style: italic;">Pozn.: Abyste mohli používat
funkci iconv, musí být PHP na serveru nastaveno a zkompilováno s
podporou konverzních funkcí. Na Windows bývá situace o něco složitější,
ale i tam to jde zapnout.<br>
</span></p>
<p>Co ale nevím je, JAK zjistit, v jaké znakové sadě byl soubor dodán.
Pokud někdo víte, nechám se poučit v diskusi. Kdybychom mohli nějak
jednoduše detekovat vstupní kódování, je otázka převodu do UTF-8
hračka. Takto alespoň informujeme uživatele, že chceme, aby soubor byl
v UTF-8. <span style="font-style: italic;"></span></p>
<p><span style="font-style: italic;"></span></p>
<p> </p>
<a name="000370"></a><h2>Náhrávání souborů na server<br>
</h2>
<p>Tento problém jsme již teoreticky rozebírali v díle o <a href="#000133">uploadu a
downloadu souborů</a>. Děje se to pomocí speciálního formuláře, který
umožní uživateli vybrat soubor na svém disku a odeslat jej na server.
Většina ukázek podobných formulářů neobsahuje žádné jiné ovládací
prvky, není však problém aby formulář obsahoval ještě například další
textová pole. My bychom například zároveň potřebovali zadat název
písně, která se k
textu váže. A protože to musí podle zadání být již existující píseň v
databázi, nahrajeme si seznam písní pomocí funkce do rozevíracího
seznamu. Celé to bude vypadat nějak takto (viz obrázek):<br>
</p>
<div style="text-align: center;"><img style="width: 417px; height: 150px;" alt="" src="img/formular_texty.jpg"><br>
<div style="text-align: left;">
<p>Když se nad tím zamyslíme trochu podrobněji, zjistíme, že bychom asi
v seznamu písní nechtěli mít všechny písně, ale jen ty, které ještě v
databázi nemají zadaný text. Jak to jednoduše udělat? Poradím Vám trik,
kterým to zjistíte pomocí dotazu do databáze. Může se Vám to hodit.<br>
</p>
<p>Původní, "hloupý" databázový dotaz sestavující seznam písní mohl
docela dobře být:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">select id, nazev from
pisne order by nazev</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Má však, jak již jsme uvedli tu nectnost, že vrátí i ty písně, které
už text mají. Vylepšený dotaz bude tento:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">select pisne.id,
pisne.nazev from pisne left join texty on pisne.id = texty.pisen where
texty.pisen is null order by nazev</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Pokud se zrovna denně nepohybujete v databázích, dovolím si to
trochu vysvětlit. Dotaz spojuje (join) data ze dvou tabulek (pisne a
texty), a to pomocí tzv. levého vnějšího spojení (LEFT OUTER JOIN). To
znamená, že dotaz vrátí všechny záznamy z "levé" tabulky (v našem
případě tabulky pisne), a to i v případě, že odpovídající záznam v
"pravé" tabulce (v našem případě je to tabulka texty) neexistuje. Pokud
se to stane, jsou v odpovídajících polích vráceny hodnoty NULL. Nás
však shodou okolností zajímají POUZE písně bez textů, takže tomu musíme
trochu pomoci a vybrat tyto řádky pomocí klauzule where. Česky bychom
dotaz mohli převyprávět jako:"Vyber všechny záznamy z tabulky písní,
kde odpovídající text písně nelze najít." <br>
</p>
<p>Kromě toho dotazu je funkce pro nahrání písní do rozevíracího
seznamu prakticky totožná s funkcí, pomocí níž jsme nahrávali seznam
písní do <a href="./examples/musicweb/14/zadejdiskografii.html">diskografie</a>.
Nemusíme se jí tedy příliš dopodrobna zabývat.<br>
</p>
<a name="000371"></a><h2>Uložení do databáze</h2>
<p>Tuto věc jsme řešili v díle o <a href="#000206">ukládání
binárních dat</a> do databáze. Aby uložení dat dopadlo dobře, musejí se
udělat zhruba tyto kroky:<br>
</p>
<ol>
  <li>Nejprve uklidíme (možná existující) dočasné soubory</li>
  <li>Ověříme si pomocí funkce <a href="http://cz2.php.net/move_uploaded_file">move_uploaded_file</a>,
zda se soubor podařilo nahrát a přesunout na námi zvolené místo.</li>
  <li>Pokud ano, zjistíme si jeho délku. Soubory s nulovou délkou a
příliš dlouhé soubory ze zpracování vyloučíme.</li>
  <li>Nahrajeme obsah souboru do proměnné</li>
  <li>Ošetříme tuto proměnnou pomocí <a href="http://cz2.php.net/manual/en/function.addslashes.php">addslashes</a>,
abychom ji mohli použít pro bezpečné uložení do databáze.</li>
  <li>Provedeme vlastní databázový dotaz. <br>
  </li>
  <li>Jelikož to mohlo z různých důvodů selhat, budeme testovat, zda se
povedlo řádek vložit. Pokud ne, zobrazíme chybu.</li>
  <li>Každopádně odstraníme dočasný soubor.<br>
  </li>
</ol>
<p>Celý skript je nesmírně přímočarý a jednoduchý na pochopení. Příště
si ukážeme, jak texty písní registrovaným uživatelům zpřístupnit a jak
jim je umožnit postahovat.</p>
<a name="000372"></a><h2>Změny na portálu</h2>
<ul>
  <li>Změněný soubor <a href="./examples/musicweb/14/admin.html">admin.php</a>
- odkaz na zadání textu písně</li>
  <li>Nový soubor <a href="./examples/musicweb/14/nahrajtextpisne.html">nahrajtextpisne.php</a>
- zadávání textu písně</li>
</ul>
<p>Projekt v  současném stavu si můžete <a href="./examples/14.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span><br>
<a name="000373"></a></p><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (86) - zobrazení dat a stahování soborů pro registrované</h2>
			<p class="perex">Jak zobrazovat předformátovaný text a jak na portále realizovat download souborů?
				<br>
			</p>
			<p>Náš cvičný hudební portál se pomalu blíží do finiše. Protože jsme
minule rozebírali zadávání textů písní do databáze, pojďme se dnes
podívat na to, jak texty písní umožníme registrovaným uživatelům
nejprve zobrazit a později rovněž stáhnout.<br>
</p>
<a name="000374"></a><h2>Zobrazení textů písní<br>
</h2>
<p>Protože se texty písní budou zobrazovat pouze přihlášeným
uživatelům, začneme skript pisen.php testováním, zda je někdo přihlášen
(nemusí to být administrátor). O tom jsme již <a href="#000357">mluvili</a>.
Následovat bude výpis písně pomocí dotazu na tabulku písní. Celý skript
má ale několik zádrhelů, které musíme nejprve vyřešit.<br>
</p>
<p>Především je to způsob, jak předávat skriptu číslo požadované písně.
Zvolíme například tu nejjednodušší variantu a budeme předávat číslo
písně v parametru URL. Takže stránku budeme požadovat pomocí URL ve
stylu index.php?clanek=pisen&amp;pisen=9999. S tím souvisí otázka
zabezpečení, protože parametr z URL bude předán do databázového dotazu.
Nám postačí testovat, zda bylo jako parametr pisen zadáno číslo. Takže
test může znít:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">if
(!</font><font color="#0000bb">is_numeric</font><font color="#007700">(</font><font color="#0000bb">$_REQUEST</font><font color="#007700">[</font><font color="#dd0000">"pisen"</font><font color="#007700">])) return;</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jestliže nám tedy do parametru pisen podstrčí někdo něco jiného než
číslo, skript se ukončí a vůbec nedojde na dotazování se databáze. Co
ale, když nám někdo podstrčí jako parametr sice číslo, ale bude to:<br>
</p>
<ul>
  <li>číslo písně, která neexistuje, nebo</li>
  <li>číslo písně, která sice existuje, ale není k ní zadán text?</li>
</ul>
<p>V takovém případě můžeme dotaz na databázi provést, ale musíme
testovat, zda se milé databázi podařilo text písně najít a musíme se
podle toho zařídit. Třebas takto:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$vysledek</font><font color="#007700">=</font><font color="#0000bb">mysql_query</font><font color="#007700">(</font><font color="#dd0000">"select * from texty
where pisen="</font><font color="#007700">.</font><font color="#0000bb">$_REQUEST</font><font color="#007700">[</font><font color="#dd0000">"pisen"</font><font color="#007700">],</font><font color="#0000bb">$GLOBALS</font><font color="#007700">[</font><font color="#dd0000">"link"</font><font color="#007700">]);<br>
if (</font><font color="#0000bb">mysql_num_rows</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">)==</font><font color="#0000bb">0</font><font color="#007700">) echo </font><font color="#dd0000">"Tato píseň není
v databázi, nebo k ní není zadán text"</font><font color="#007700">;</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Dále musíme nějak dořešit zobrazení písně. Pokud bychom použili
pouze příkaz echo, zobrazí se píseň bez odřádkování a nebude to hezké.
Proč se to stane? Protože pomocí echo "vypustíme" píseň do stránky tak,
jak je uložná v databázi. A zatímco v databázi je řádkována pomocí
znaků konce řádku, v HTML stránce není řádkována vůbec, protože znak
konce řádku HTML zpracovává jinak.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Jinými slovy - pokud
zobrazíte zdrojový kód stránky, bude text řádkován, v samotné stránce
však nikoli.</span><br>
</p>
<p>Naštěstí je pomoc snadná - existuje třebas PHP funkce <a href="http://cz.php.net/manual/en/function.nl2br.php">nl2br</a>, která
nahradí konce řádků značkou &lt;BR&gt;. To už si i HTML "uvědomí", že
by mělo odřádkovat a udělá to. Jiná možnost je text písně uzavřít do
HTML tagů &lt;pre&gt; a &lt;/pre&gt;, což zjednodušeně řečeno znamená,
že se použije formátování dodaného textu včetně vícenásobných mezer a
konců řádků. My použijeme dejme tomu ten druhý způsob.<br>
</p>
<p>Konečně by stránce kromě samotného textu písně jistě měl být i její
nadpis. To lze buď vyřešit dalším dotazem do databáze, nebo ten první
přepsat tak, aby vracel i název písně. To je lepší, ušetříme tím jedno
volání databáze. A ještě jedna vychytávka - tentokrát nemusíme
zpracovávat výsledky z databáze pomocí symčky while, protože pokud
vůbec bude co zpracovávat, bude to vždy právě jeden řádek. Můžeme tedy
prostě uvést:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
</font><font color="#ff8000">//atd...</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Poslední věc: Odkud by se vůbec měl uživatel na seznam písní dostat?
Asi z diskografie; a můžeme to provést tak, že pokud bude existovat
text písně, zobrazíme její název jako odkaz. Příslušně tedy upravíme
soubor diskografie.php. Jednak změníme databázový dotaz tak, aby
vracel rovněž informaci o tom, zda je k dispozici text písně a jednak,
pokud text písně k dispozici bude, jej zobrazíme jako odkaz. Podívejte
se na vylepšený soubor <a href="./examples/musicweb/15/diskografie.html">diskografie.php</a>.</p>
<p>Pokud to budete zkoušet, přijdete na jednu věc: Odkaz se zobrazí i
nepřihlášeným uživatelům. Je to správně - zejména vzhledem k tomu, že
nepřihlášení uživatelé nemohou text písně vidět? To je spíše
marketingová než programátorská otázka. Pokud by totiž bylo zájmem
portálu mít co nejvíce registrovaných uživatelů, pak by se asi provedlo
následující:<br>
</p>
<ol>
  <li>Odkazy na zobrazení textů písní by se daly všude tam, kde jen to
je možné.</li>
  <li>Stránka pro zobrazení písně by po zjištění, že uživatel není
registrován zobrazila hlášení, případně přihlašovací formulář nebo
registrační formulář.</li>
</ol>
<p>A pokud by naopak bylo přihlašování jen pro malou skupinu
vyvolených, asi by se to provedlo nějak takto:<br>
</p>
<ol>
  <li>Odkazy na zobrazení textů písní by se zobrazovaly pouze
přihlášeným uživatelům.</li>
  <li>Pokud by někdo nepřihlášený náhodou objevil na stránce pro
zobrazení textů písní, měl by být co nejjemněji poslán pryč.</li>
</ol>
<p>Asi tušíte, že takové hrátky jdou již nad rámec základních funkcí
portálu, a tak se jimi zabývat nebudeme. Nicméně, fantazii se meze
nekladou.</p>
<a name="000375"></a><h2>Stahování textů písní</h2>
<p>Připomeneme-li si zásady z dílu seriálu o <a href="#000134">stahování
souborů ze serveru</a>, bude celá záležitost triviální. Odkaz na
stažení textu písně můžeme umísti například na stránku s textem, tedy
opět do souboru pisen.php. Samotné stažení pak provede skript
stahnipisen.php, který se dotazuje databáze podobně, jako skript
pisen.php:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
header</font><font color="#007700">(</font><font color="#dd0000">"Content-Description:
File Transfer"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Type:
application/force-download"</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">header</font><font color="#007700">(</font><font color="#dd0000">"Content-Disposition:
attachment; filename=\"pisen.txt\""</font><font color="#007700">);<br>
&nbsp;&nbsp;</font><font color="#0000bb">$zaznam</font><font color="#007700">=</font><font color="#0000bb">MySQL_Fetch_Array</font><font color="#007700">(</font><font color="#0000bb">$vysledek</font><font color="#007700">);<br>
&nbsp;&nbsp;echo </font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"nazev"</font><font color="#007700">].</font><font color="#dd0000">"\n"</font><font color="#007700">.</font><font color="#0000bb">$zaznam</font><font color="#007700">[</font><font color="#dd0000">"textpisne"</font><font color="#007700">];</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jak vidíte, skutečně si můžeme díky zapnutému bufferování výstupu
dovolit odeslat hlavičky v polovině skriptu, jak jsme to již <a href="#000322">rozebírali</a>.
Pokud to ale v uvedeném znění vyzkoušíte zjistíte, že jste stáhli
nejenom text písně, ale rovněž i kus html stránky. Proč? Protože
hlavičky si sice bufferovací funkce zařadí na začátek, ale přesto
začnou nakonec odesílat všechna data skriptu, jako je třeba HTML
definice
tabulky v souboru index.php. Rovněž po odeslání textu písně bude
následovat nějaký HTML kód.<br>
</p>
<p>I tady je řešení prosté. Půjdeme na to ve dvou krocích:<br>
</p>
<ol>
  <li>Před hlavičky pro poslání souboru přidáme volání funkce <a href="http://cz.php.net/ob_end_clean">ob_end_clean</a>, která dosud
"nasyslený" buffer bez milosti zahodí, a</li>
  <li>Po příkazu echo zavoláme příkaz <a href="http://cz.php.net/manual/en/function.die.php">die</a>, který
způsobí okamžité zastavení provádění skriptu stahnipisen.php.</li>
</ol>
<p>Výsledek je ten, že se v textovém souboru objeví skutečně jen data
týkající se názvu a textu písně.<br>
</p>
<a name="000376"></a><h2>Změny na portále</h2>
<ul>
  <li>Změněný soubor <a href="./examples/musicweb/15/diskografie.html">diskografie.php</a>
(odkaz na stránku s textem písně)</li>
  <li>Nový soubor <a href="./examples/musicweb/15/pisen.html">pisen.php</a>
(zobrazuje text písně)</li>
  <li>Nový soubor <a href="./examples/musicweb/15/stahnipisen.html">stahnipisen.php</a>
(zajišťuje stažení souboru)</li>
</ul>
<p>Projekt v současném stavu si můžete <a href="./examples/15.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span></p>

<a name="000377"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (87) - finišujeme portál</h2>
			<p class="perex">Dnes uzavřeme práci na hudebním portálu. Co se musí udělat, aby byl projekt schopný uveřejnění?
				<br>
			</p>
			<p>Dnes se podíváme na některé věci, na něž byste při skutečné práci na
webech v PHP neměli zapomínat. Čímž dokončíme náš cvičný portál a i
tedy celou stať s většími příklady v PHP. Přestože to budou převážně
samozřejmosti, divili byste se, kolik lidí takové věci řeší na až
poslední chvílí, případně vůbec.<span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000378"></a><h2>Standardy<br>
</h2>
<p>Webové standardy jsou tu proto, aby se dodržovaly. K testování, zda
je stránka validní či nikoli, můžete použít celou řadu validátorů.
Velmi dobrý je ten na <a href="http://validator.w3.org/">http://validator.w3.org/</a>,
který mnoho lidí používá proto, že je k dispozici ON-LINE a proto, že
případné nedostatky dokumentu rovněž přehledně vysvětlí. Testovat
dynamický web však není tak jednoduché, jak by se na první pohled mohlo
zdát. Prozradím vám tip. Při testování platnosti nějaké dynamické
stránky (tak dejme tomu v našem případě stránky pro zobrazení
diskografie pro přihlášeného uživatele) si<br>
</p>
<ol>
  <li>Stránku nechám zobrazit v prohlížeči</li>
  <li>Nechám si zobrazit její zdrojový kód (např. ve Firefoxu pomocí
pravého tlačítka myši)</li>
  <li>Stránku si uložím na disk</li>
  <li>Na stránkách validátoru je k dispozici <a href="http://validator.w3.org/file-upload.html">rozhraní</a> pro test
souborů pomocí jejich uploadu na server - to použiju</li>
</ol>
<p>Kontrolou jsem objevil drobné prohřešky proti standardům i na tomto
testovacím portále - takže si nahrajte aktuální verzi, pokud budete
chtít s projektem dále experimentovat.<br>
</p>
<a name="000379"></a><h2>Databáze</h2>
<p>Pokud Váš projekt používá nějakou databázi, měli byste si ji v této
fázi zazálohovat. Zazálohováním myslím jak strukturu, tak i data. Při
zálohování dat ale dejte pozor na zabezpečení. Pokud databáze obsahuje
citlivé údaje, dobře zálohu zabezpečte nebo tyto údaje nezálohujte. Tak
například na našem portále bychom za citlivé mohli považovat údaje z
tabulky uzivatele a proto jsem je nezálohoval. Záloha toho zbytku je k
dispozici <a href="./examples/database.html">k
nahlédnutí</a> nebo <a href="./examples/database.zip">ke stažení</a>.<br>
</p>
<p>Zálohu můžete jednoduše vytvořit pomocí nějakého nástroje pro
administraci MySQL, třeba pomocí phpMyAdminu. Taková záloha je důležitá
nejen kvůli tomu, kdyby se databáze poškodila, ale rovněž kvůli
případným změnám. Nahlédnutím do generovaného souboru tak můžete lehce
zjistit, jakou strukturu měla databáze v době vytvoření. Kdyby bylo
potřeba později strukturu změnit, zálohujte rovněž.<br>
</p>
<a name="000380"></a><h2>Webdesign</h2>
<p>Pokud bude portál funkční, můžeme jej dozdobit pomocí kaskádových
stylů, barev, obrázků, zvuků a všemožných jiných nemožností. My se tím
v našem seriálu zabývat nebudeme, patřilo by to spíše do seriálu o HTML
nebo o kaskádových stylech. Při tvorbě designu byste však přece jen
měli mít na paměti některé zásady, přímo či nepřímo související s
programováním:<br>
</p>
<ul>
  <li>Holý web bez grafiky se může jevit jako až extrémně rychlý.
Pamatujte však na to, že zdání klame a že uživatel bude muset
postahovat i zvuky, obrázky a animace, pokud je na webu budete mít.
Mluvím o tom proto, že vina za "pomalý" web bývá někdy neprávem
svalována na PHP či na samotného programátora.</li>
  <li>Přidáním vizuálních prvků se může stránka stát zase nevalidní.
Pozor na to.</li>
  <li>Pokud jsou vizuální prvky "jen" grafickou nadstavbou, přidává je
většina programátorů a webdesignérů do projektu až v této fázi.
Jestliže ale je grafika součástí logiky webu, mělo by se s ní pracovat
již dříve.</li>
</ul>
<a name="000381"></a><h2>Záloha</h2>
<p>Pakliže jste dali na <a href="#000265">moji radu</a>,
používáte asi nějaký systém pro správu kódu, jako je například CVS nebo
Subversion. Takže zálohování je jednoduchá věc: Potvrdíte změny,
nazvete si verzi nějakým honosným označením (třeba "release 1.0",
"musicweb 2005 cheetah" a podobně), případně si zazálohujete repository
a je hotovo. Pokud však systém pro správu kódu nepoužíváte, slušelo by
projektu alespoň zabalení do archivu, vypálení na CD a uložení na
nějaké bezpečné místo.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Slyšel už jsem
argument:"Proč bych to zálohoval, mám to přece doma v PC a navíc je to
na webu." Popovídejte si o tom s někým, kdo přišel o data v počítači a
jeho web byl hacknut. Bude mít pro vás zajímavé tipy ;-)))<br>
</span></p>
<a name="000382"></a><h2>Licencování</h2>
<p>Pokud bude Váš konkrétní projekt provozován pod nějakou
definovatelnou licencí, měli byste se postarat, aby to bylo zřejmé.
Například <a href="http://www.gnu.cz/article.php?id_art=32">zde</a>
najdete překlad licence GNU a rovněž návod, jak tuto licenci použít ve
svých projektech.<br>
</p>
<p style="font-style: italic;">Pozn.: Nikdo Vás samozřejmě nenutí
používat GNU licenci. Ale může to být dobrá volba, zejména chcete-li
svůj výtvor sdílet.<br>
</p>
<p>Bude-li projekt záležitost uzavřená, mohou se sestavit licenční
ujednání jiného typu. Je rovněž možné stanovit vlastní podmínky, za
nichž má (nebo nemá) být dílo šířeno. Pracujete-li pro zaměstnavatele,
bude mít asi vlastní představu, jak s Vaším dílem naložit ;-(<br>
</p>
<p> </p>
<a name="000383"></a><h2>Testovací provoz</h2>
<p>V reále by asi web v této fázi šel do testovacího provozu. K tomu
není mnoho co dodat. Snad jen pár postřehů k testovacím postupům obecně:<br>
</p>
<ol>
  <li>Někdy se hodí být u toho, když uživatel zkouší portál ovládat.
Případné připomínky pak můžete rovnou konzultovat.</li>
  <li>Tester nebo uživatel by měl mít k dispozici nějaký jednoduchý
způsob, jakým Vám dá k dispozici své postřehy.</li>
  <li>Pakliže budete předávat svou práci někomu, kdo si rád na poslední
chvíli vymýšlí, vezměte si s sebou podklady k zadání. Zákazníky někdy
napadají neuvěřitelné věci, které by mohly znamenat celý portál
předělat - pokud ale máte dobře zadání, není většinou co řešit.</li>
  <li>Testovací prostředí by se mělo co nejméně lišil od prostředí
ostrého. U webů se někdy testovací verze portálů umisťují na provozní
servery, ale do jiných umístění. Takže máte například ostrý provoz na
www.nazevportalu.cz a testovaní na www.nazevportalu.cz/test</li>
  <li>U testovacího provozu možná budete chtít zapnout protokolování
chyb nebo nějaké jiné mechanizmy sledující chování portálu.</li>
  <li>Rovněž užitečný může být protokol o činnosti serveru; poradí Vám
například, které stránky bývají navštěvovány častěji než jiné. K témuž
slouží počitadla návštěv.</li>
</ol>
<a name="000384"></a><h2>Závěrečné poznámky</h2>
<p>Tento jak jsme jej honosně nazvali "hudební portál" není samozřejmě
skutečný a hotový webový portál. Cílem bylo pouze ukázat vám co možná
nejvíce programovacích technik jazyka PHP, a udělat to jinak než s
použitím klasického příkladu - internetového obchodu. Na portálu chybí
některé věci, jako třeba:<br>
</p>
<ul>
  <li>Některé údaje jdou jen vkládat</li>
  <li>Některé údaje jdou jen vkládat a editovat, ne odstraňovat</li>
  <li>Stránky nejsou provázány tak kvalitně, jak by mohly být.</li>
</ul>
<p>Přesto věřím, že alespoň kousek inspirace z něj budete mít. Při
vývoji vlastních prací můžete totiž narazit na spoustu úloh, kterých
jsme se tak či tak dotkli. A můžete se rozhodnout, že buď použijete
nazančená řešení, nebo sestavíte vlastní, třeba i lepší. V dalším díle
seriálu tedy tvorbu portálu opustíme, a budeme se věnovat obecnějším
tématům. Těšte se - tématem následujícího dílu bude <span style="font-style: italic;">Proč (ne)používat PHP na Windows</span>.<br>
</p>
<p>Projekt v současném stavu si můžete <a href="./examples/16.zip">stáhnout</a>. <br>
</p>
<p><span style="font-style: italic;">Pozn.: Aby Vám stažená verze
fungovala na lokálním stroji, upravte si hodnotu konstant SQL_HOST,
SQL_USERNAME, SQL_PASSWORD a SQL_DBNAME. Případně si je můžete včlenit
do konfiguračního souboru podobně, jako jsem to udělal v souboru
func.php.</span><br>
</p>
<a name="000385"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (88) - provoz ve Windows</h2>
			<p class="perex">... aneb nemůžete říct, že jsme vás nevarovali.
				<br>
			</p>
			<p>
Závěr našeho seriálu bude patřit některým obecnějším tématům
souvisejícím s PHP. Dnes se podíváme na problematiku provozu PHP na
strojích s operačními systémy Windows. To je velmi diskutované a kontroverzní téma -
a asi si říkáte, co tento článek dělá na Linuxsoftu. Přečtěte, uvidíte.<br>
</p>


<a name="000386"></a><h2><span style="font-weight: normal;">Multiplatformní PHP</span></h2>
<br>
<p>PHP bývá označován za multiplatformní záležitost. To je slovo,
kterého byste se, pokud jej uslyšíte, měli děsit. Schopnost fungovat na
více systémech totiž mnozí uživatelé zaměňují za:<br>
</p>
<ul>
  <li>schopnost fungovat na více systémech bez problémů</li>
  <li>schopnost fungovat na více systémech bez úprav</li>
</ul>
<p>Obojí je samozřejmě nesmysl. Tvrzení, že PHP bude fungovat stejně
dobře na více operačních systémech by se dalo přirovnat k tvrzení, že
existují celoroční pneumatiky. To přirovnání je velmi trefné - jednak
proto, že tomu spousta lidí věří, a jednak proto, že někteří tomu
přestanou věřit až v momentě, kdy dojde k havárii. <br>
</p>
<p>Pro účely naší úvahy budeme za "multiplatformní" považovat schopnost
PHP běžet na operačních systémech Linux a Windows. Není to tak úplně
přesné, protože PHP lze provozovat i pod MAC OS, tím se ale v naší
úvaze zabývat
nebudeme. Osobně bych za hlavní význam multiplatformních aplikací
považoval to, že nám umožňují <span style="font-style: italic;">výběr </span>operačního
systému, na němž poběží, a ne tedy to, že <span style="font-style: italic;">mohou </span>běžet na více
systémech. <br>
</p>
<p>Otázka tedy zní: Proč byste si měli vybrat pro PHP Linux - a pokud
nechcete nebo nemůžete, jaké problémy při provozování na PHP na Windows
vás
čekají?<br>
</p>
<a name="000387"></a><h2>Proč LINUX</h2>
<p>Správných odpovědí je mnoho. PHP nejlépe pracuje v kombinaci s
webovým serverem Apache, a je to zdaleka nejčastější způsob nasazení
PHP v reálné praxi. PHP může běžet jako součást, respektive modul
Apache s tím, že přebírá některé z jeho výhod - například
škálovatelnost, výkon nebo zabezpečení. Server Apache funguje velmi
dobře na Linuxu, protože pro něj byl primárně vyvinut.<br>
</p>
<p>Pak je tu samozřejmě otázka ceny. Jestliže můžete mít zdarma PHP a
zdarma webový server, komu by se potom chtělo platit za operační
systém? Dvě nejčastěji používané databáze v souvislosti s PHP (MySQL a
PostgreSQL) fungují rovněž na Linuxu velmi dobře.<br>
</p>
<p>Pokračovat bychom mohli snadnou konfigurací, možnostmi rozšiřujících
modulů, výkonem v serverovém prostředí a mnoha dalšími faktory.
Nicméně, často zkrátka nebudete mít možnost nasadit PHP na linuxový
stroj, zejména ne při vývoji. Dobrá, budetet tedy muset provozovat PHP
na Windows. Co Vás čeká?<br>
</p>
<a name="000388"></a><h2>Problémy !</h2>
<p>Budete mít potíže. Budete jich mít méně, pokud se zařídíte podle rad
v tomto článku, ale budete jich mít ještě méně, pokud přejdete na
Linux. Takže tak. Zdaleka nejčastější trable uživatelů píšících PHP
kód ve Windows vzniknou tehdy, pokud neznají Linux vůbec a nahrají
skripty fungující ve Windows na linuxový server. Jelikož je to poměrně
četná skupina uživatelů, nejprve něco postřehů k nim:<br>
</p>
<p><span style="font-weight: bold;">Lomítka<br>
</span>Ačkoliv už jsem na toto téma slyšel mnoho nepřesných údajů, ve
skriptech <span style="font-style: italic;">můžete </span>používat
zpětná i dopředná lomítka. Stylově bude určitě lepší používat vždy
lomítka normální, protože se to tak v linuxu dělá.<br>
</p>
<p><span style="font-weight: bold;">Názvy souborů</span><br>
Windows Vám nepovolí nazvat jeden soubor "include.php" a jiný
"Include.php" v jedné složce. Linux ano. Měli byste na to myslet ve
dvou případech:<br>
</p>
<ol>
  <li>Jestliže potřebujete uvést ve skriptech název souboru operačního
systému. To je poměrně častá záležitost (include, require, fopen a
podobně).</li>
  <li>Jestliže kopírujete skripty z Windows na linuxový server pomocí
nějakého FTP klienta ve Windows. Někteří klienti změní velikost písmen.
TO V LINUXU VADÍ.</li>
</ol>
<p>Neexistuje "správný" způsob, jak se s tím vyrovnat. Můžete se ale
například rozhodnout, že budete v názvech souborů používat pouze malá
písmena. Pak problému do značné míry můžete zabránit.<br>
</p>
<p><span style="font-weight: bold;">Absolutní cesty</span><br>
Ve skriptech byste se vždy měli vyvarovat používání absolutních
cest, a
používat buďto cesty relativní, nebo alespoň cesty sestavené pomocí
proměnné $_SERVER["DOCUMENT_ROOT"]. Pamatujte na to, že příkazy ve
stylu:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;</font><font color="#007700">require (</font><font color="#dd0000">"C:\slozka\soubor.php"</font><font color="#007700">);</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Vám v linuxu fungovat zkrátka nemohou, protože Linux nezná nic
takového, jako je disk C ;-)<br>
</p>
<p><span style="font-weight: bold;">Nefungující příkazy</span><br>
Pokud musíte ve vývojovém nebo dokonce produkčním prostředí používat
PHP na Windows, pamatujte rovněž na to, že se ochuzujete o některé
příkazy a funkce, které jsou v PHP pro Linux (i v samotném Linuxu)
zcela běžné a které ve Windows mohou fungovat špatně nebo vůbec. Patří
mezi ně například příkaz <a href="http://cz2.php.net/manual/en/function.chmod.php">chmod</a>.<br>
</p>
<p><span style="font-weight: bold;">Špatně fungující příkazy</span><br>
Rozhýbání jiných příkazů může být na Widnows sice docela dobře možné,
ale v praxi poměrně obtížné. Mám na mysli například funkci <a href="http://cz2.php.net/manual/en/function.mail.php">mail</a>. Upřímě
řečeno to nemá moc společného se samotným PHP, ale s tím, že pro
Windows bude potřeba nainstalovat a nastavit nějaký program pro
odesílání pošty, než to vůbec budete moci zkonfigurovat. Ono něco
podobného se musí udělat i pro Linux, ale tam je k dispozici více
možností a pravděpodobně to bude fungovat již od instalace serveru.<br>
</p>
<p style="font-weight: bold;">Nutnost doinstalace knihoven<br>
<span style="font-weight: normal;">Mnoho PHP funkcí, například <a href="http://cz2.php.net/iconv">funkce pro konverze znakových sad</a>
vyžaduje pro správný provoz ve Windows ruční kopírování knihoven,
případně jejich registraci v
systému Windows. Není to sice nic extrémně obtížného, ale může to
znepříjemnit práci.<br>
</span></p>
<p><span style="font-weight: normal;"><span style="font-weight: bold;">Vliv
prostředí<br>
</span>Práce ve Windows s sebou nese rovněž určité vlivy prostředí -
tak třeba: <br>
</span></p>
<ul>
  <li><span style="font-weight: normal;">Soubory budou ve výchozím
stavu kódovány ve znakové sadě win-1250</span></li>
  <li><span style="font-weight: normal;">Funkce pro práci s datem a
časem mohou mít někdy "vlastní hlavu" <span style="font-weight: bold;"></span></span></li>
</ul>
<p><span style="font-weight: normal;"><span style="font-weight: bold;">Odlišnosti
v systému</span><br>
Díky - jak to jen nazvat - "odlišnostem" v jednotlivých verzích
operačních systémů Windows (zejména 9x/Me oproti NT/2000/XP) vám
nastavení PHP z jednoho stroje nemusí fungovat na stroji jiném. To je
významné například v případě, kdy chcete mít doma i v práci stejné
prostředí pro vývoj.<br>
</span></p>
<p><span style="font-weight: normal;"></span></p>
<p><span style="font-weight: normal;">Existují ale i dobré zprávy.
Například v PHP 5 byly některé věci přidány přímo jako součást
samotného PHP enginu, takže se teď nemusejí doinstalovávat a mohou se
použít jak v Linuxu, tak i na Windows. <br>
</span></p>
<a name="000389"></a><h2><span style="font-weight: normal;">Webový server pro PHP na Windows</span></h2>
<a name="000390"></a><h2><span style="font-weight: normal;"></span></h2>
<p><span style="font-weight: normal;">S provozem PHP pod Windows
souvisí i jiná otázka - a tou je výběr webového serveru. Negativní
dopady použití PHP na Windows se dají trochu zmírnit použitím vhodného
serverového software. Ačkoli možností je víc, v praxi se používá buďto
Internet Information server
od Microsoftu, nebo Apache server pro Windows. Pokud použijete IIS,
musíte se smířit s tím, že PHP Vám poběží jako interpreter CGI. Vlastně
to znamená, že při každém použití PHP se musí načíst konfigurace,
spustit soubor php.exe, případně načíst knihovny a provést požadavek,
ve všemi těmi negativními dopady na výkon, které si asi umíte
představit.<br>
</span></p>
<p><span style="font-weight: normal;"><span style="font-style: italic;">Pozn.:
Celé to většinou bude probíhat v operační paměti stroje, takže to
nebude tak dramatické, ale stejně je to sosač výkonu.<br>
</span></span></p>
<p><span style="font-weight: normal;">Dále je potřeba vědět, že při
provozu PHP jakožto CGI interpreteru nemůžeme použít HTTP
autentifikaci; ta je totiž dostupná pouze tehdy, pokud PHP běží jakožto
modul Apache. <br>
</span></p>
<p><span style="font-weight: normal;">K Apache - obecně se dá říci, že
Apache
server běží na Windows NT systémech relativně bez problémů (ale to se
nedá říci o WIN 95/98). Takže, v konfiguraci Windows XP+Apache+PHP se
vyvíjet dá, zejména pokud se jedná o méně náročné věci. </span></p>
<p><span style="font-weight: normal;"></span></p>
<a name="000391"></a><h2><span style="font-weight: normal;">A co webhosting ?</span></h2>
<p>Webhosteři, a to i ti velcí, někdy nabízejí provozování PHP na
internetových serverech v konfiguraci, která je krajně diskutabilní -
právě s Internet information serverem a PHP jakožto CGI. K několika
aplikacím tohoto typu jsem se dostal a věřte - budete se, zejména při
náročnějším zpracování dat sektávat s chybami typu "CGI timeout".&nbsp;
Pokud si můžete vybrat - třeba pokud se vyvíjí webová aplikace a
zároveň se hledá webhosting - vyberte si raději linuxový hosting. <br>
</p>
<p>Přestože to u hostingu může přinášet poměrně značná omezení, má
nasazení PHP na windowsové servery svou logiku. Umožňuje Vám to přepsat
napříkad aplikace z Active server pages (asp) do PHP, aniž byste hýbali
zbytkem webu.
Věřme, že to je jeden z hlavních důvodů, proč se PHP na produkčních
serverech takto používá. V takovém případě je to jen dobře. Abych se
webhosterů zastal - většina z těch, kterí to dělají, mají i rozumnější,
linuxové servery.<br>
</p>
<a name="000392"></a><h2>Závěr</h2>
<p>Pro vývoj aplikací, zejména jednoduchých, by prostředí Windows mohlo
s jistými omezeními pro PHP dostačovat. Pro provoz webu bych ale
jednoznačně doporučoval linuxové prostředí pro jeho výkon, stabilitu a
bezpečnost. PHP bych upřednostňoval používat v režimu, kdy běží jakožto
modul serveru Apache - je to ostatně typická a léty prověřená
konfigurace.</p>
<a name="000393"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (89) - cesta do hlubin php.ini</h2>
			<p class="perex">Každý trochu složitější program má své nastavení. PHP taky, takže: kde, proč, jak byste se měli dozvědět v tomto dílu seriálu.
				<br>
			</p>
			<p>Začínající uživatelé o tom moc nevědí a ve většině seriálů o PHP se
toto
téma neprávem opomíjí. Pokud se vám stalo, že vám nějaký skript
fungoval na lokálním počítači, ale nefungoval na serveru, čtěte dál.
Pokud potřebujete vědět, jaká nastavení ovlivňují chování PHP na
serveru, čtěte rovněž. Dnes totiž bude řeč o nastavení PHP. </p>
<a name="000394"></a><h2>Jak PHP zpracovává konfiguraci</h2>
<p>Mnoho věcí v PHP závisí na konfiguraci samotného stroje. Hodnoty
nastavených voleb bývají důležité, protože na ně ve svých programech
můžete - vědomně či podvědomně - spoléhat. Ale spoléhat na nastavení
nebývá považováno za správnou programátorskou taktiku, takže se na to
pojďme podívat trochu hlouběji.<br>
</p>
<p>Jednotlivé konfigurační volby mohou být především uloženy v
samotném PHP skriptu (ne ale všechny). Nastavení voleb ve skriptu
pomocí
konfiguračních funkcí má přednost před vším ostatním a platí pouze do
ukončení běhu daného skriptu. Dále mohou být některé konfigurační volby
platné pro danou složku. Logika věci je podobné jako logika souborů pro
konfiguraci složky v Apache; volby PHP pro danou složku mohou být
dokonce umístěny přímo do souboru .htaccess, případně v konfiguraci
Apache httpd.conf.<br>
</p>
<p style="font-style: italic;">Pozn.: Nastavení pro danou složku
většinou u hostingů nastavuje administrátor webu, ne uživatel.</p>
<p>Jestliže daná volba není specifikována ani ve skriptu samotném, ani
pro danou složku, nastupuje čtení hodnot z globálního konfiguračního
souboru php.ini.</p>
<a name="000395"></a><h2><span style="font-weight: bold;">php.ini</span><br>
</h2>
<p>Do souboru php.ini jsou soustředěny veškeré možnosti nastavení.
Pakliže
provozujete PHP pod Linuxem, najdete tento soubor
nejspíš jako /etc/php.ini, jestliže běžíte pod Windows, bude asi ve
složce
windows (typicky C:\WINDOWS nebo C:\WINNT). Inicializační soubor
ovlivňuje takové "drobnosti", jako jsou například:<br>
</p>
<ul>
  <li>volby jazyka</li>
  <li>limity přidělených systémových prostředků</li>
  <li>zpracování chyb</li>
  <li>zpracování dat</li>
  <li>upload souborů</li>
  <li>nastavení session</li>
  <li>nastavení spolupráce s databázemi</li>
</ul>
<p>
Ini soubor je textový, bývá dobře dokumentován a komentáře v něm
začínají středníky. Linuxový tip: Budete-li chtít zobrazit "holý" obsah
souboru bez komentářů, můžete využít následující příkaz:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">cat /etc/php.ini | grep
^[^\;]</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Jestliže vás to zajímá - cat vypisuje obsah souboru na standardní
výstup (<a href="http://www.linuxsoft.cz/article.php?id_article=549">psali
jsme o tom</a>), a grep pak z tohoto výpisu zobrazí pouze řádky, které
začínají (<span style="font-weight: bold;">^</span>) něčím, co není
středník (<span style="font-weight: bold;">[^\;]</span>). Obdobná
alternativa pro Windows neexistuje, pokud si neseženete nějaký
widnowsovský klon grepu.<br>
</p>
<p>Jiný tip: Protože bývá užitečné vědět, co se se systémem děje,
zálohujte nejprve soubor php.ini, pokud se jej chystáte měnit. Jestliže
je potom třeba něco opravit, můžete nejenom konfiguraci vrátit zpět,
ale současný a zálohovaný soubor porovnat a tak rychle vědět, co se
měnilo:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">diff php.ini php.ini.old</font>
</code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-style: italic;">Pozn.: Ani tohle ve Windows
jednoduše neuděláte...</span><br>
</p>
<p>Některá nastavení php.ini můžete tiše ignorovat. Prakticky o nich
nebudete ani vědět, protože výchozí chování programu pro Vás bude
převážně vyhovující. Typicky se to týká nastavení spolupráce s
databázemi. U jiných voleb se však vyplatí vědět, jaký mají význam a
jak jejich nastavení či změna ovlivní chování vašich pracně napsaných
PHP skriptů. O těch
nejvýznamnějších si něco povíme. Nejprve ale pár údajů k PHP funkcím
pro
práci s konfigurací.<br>
</p>
<a name="000396"></a><h2>Konfigurační funkce PHP</h2>
<p>Zdaleka nejčastěji používanou konfigurační funkcí PHP je <a href="http://cz.php.net/phpinfo">phpinfo()</a>.
Již jsme o něm <a href="#000256">mluvili</a>.
V praxi se používá jednak proto, aby se zjistilo, zda PHP po instalaci
vůbec běží, a jednak proto, aby se zjistilo, jaké hodnoty
konfiguračních voleb či předaných proměnných jsou k dispozici. Typický
výstup z funkce phpinfo() si můžete prohlédnout <a href="./examples/phpinfo.html">zde</a>.<br>
</p>
<p style="font-style: italic;">Pozn.: Je to jen příklad. Neukazuje to
aktuální konfiguraci tohoto serveru.<br>
</p>
<p>Poměrně málo známou vlastností funkce phpinfo() je její schopnost
zobrazit jen podmnožinu z celkového kvanta informací. K tomu můžete
použít předdefinovaných konstant. Pokud byste například chtěli jen
informace o aktuální konfiguraci a načtených modulech, můžete použít
toto:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
phpinfo</font><font color="#007700">( </font><font color="#0000bb">INFO_CONFIGURATION
</font><font color="#007700">+ </font><font color="#0000bb">INFO_MODULES</font><font color="#007700">);</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Dalšími konfiguračními nástroji je dvojice funkcí <a href="http://cz.php.net/ini_set">ini_set</a> a <a href="http://cz.php.net/manual/en/function.ini-get.php">ini_get</a>.
Jak asi tušíte, první z nich bude nastavovat konfigurační volby,
zatímco druhá bude získávat aktuální nastavení. Použití je jednoduché,
musíte jen vědět, co a jak chcete změnit:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#007700">echo </font><font color="#dd0000">'Před
změnou: variables_order = ' </font><font color="#007700">. </font><font color="#0000bb">ini_get</font><font color="#007700">(</font><font color="#dd0000">'variables_order'</font><font color="#007700">) . </font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">ini_set </font><font color="#007700">(</font><font color="#dd0000">'variables_order'</font><font color="#007700">,</font><font color="#dd0000">'GPCSE'</font><font color="#007700">);<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">'Po změně:
variables_order = ' </font><font color="#007700">. </font><font color="#0000bb">ini_get</font><font color="#007700">(</font><font color="#dd0000">'variables_order'</font><font color="#007700">) . </font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V souvislosti s ini_get a ini_set byste však měli vědět
několik věcí, které vás ušetří bolení hlavy. Zejména v případě, kdy se
vám nebude
dařit tyto funkce využít ve vlastních skriptech:<br>
</p>
<ul>
  <li>Především, obě funkce mohou být na serveru zakázány nebo omezeny.</li>
  <li>Dále, to, zda se vám podaří změnit konfigurační volbu je dáno
tím, zda se to vůbec ve skriptu <span style="font-style: italic;">smí </span>udělat.
Více v dokumentaci k funcki
ini_set.</li>
  <li>Potom, funkce ini_get vrací hodnoty tak, jak jsou zapsány v
konfiguračním souboru. To znamená, že může vrátit například údaj <span style="font-style: italic;">8M </span>pro hodnotu, u níž byste
nejspíš očekávali číslelný údaj. Zpracování je pak na vás.</li>
  <li>Navíc, hodnota nemusí být v konfiguračním souboru php.ini uvedena
vůbec. Ujistěte se, že potom vaše skritpy používající ini_get mají
smysl a nehavarují.</li>
</ul>
<p>Konečně mám pro vás tip, jak rychle a bezpečně zjistit, zda je k
dispozici určitá PHP funkcionalita z modulů. Dokonce k tomu nemusíte
ani procházet php.ini - stačí využít funkce <a href="http://cz.php.net/function_exists">function_exists()</a>. Ta,
jak asi čekáte vrátí TRUE, pokud je k dispozici daná funkce
(uživatelská či vestavěná). Takže, pokud byste například toužili po
převodu znakových sad a nebyli si jisti, zda jsou k dispozici, můžete
použít něco jako:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">if
(</font><font color="#0000bb">function_exists</font><font color="#007700">(</font><font color="#dd0000">"iconv"</font><font color="#007700">)) </font><font color="#0000bb">$udaj</font><font color="#007700">=</font><font color="#0000bb">iconv</font><font color="#007700">(</font><font color="#dd0000">"ISO-8859-2"</font><font color="#007700">, </font><font color="#dd0000">"UTF-8"</font><font color="#007700">, </font><font color="#0000bb">$udaj</font><font color="#007700">);<br>
</font><font color="#ff8000">// jinak to prostě bude v ISO-8859-2</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Je to velmi rychlé, jednoduché a funguje to bez ohledu na okolní
prostředí. V dalším díle seriálu si ukážeme na některé konkrétní volby
v php.ini, které by mohly zejména nezkušeným uživatelům pěkně zamotat
hlavu.</p>
<a name="000397"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (90) - Poťouchlé konfigurační volby</h2>
			<p class="perex">Neboli proč si musíte dávat pozor na údaje v php.ini
				<br>
			</p>
			<p>
Pojďme se podívat na to, jaké nejčastější problémy související s
konfigurací PHP nás mohou potkat. Uvidíte, že to může být poměrně
zábavné a že odlišné nastavení mohlo a může způsobit zajímavé věci. Ale
popořadě.
</p>

<a name="000398"></a><h2>Register_globals</h2>

<p>
Asi nejpopulárnější volba php, nebo aspoň v minulosti
nejdiskutovanější je bezesporu register_globals. Pokud je nastavena na
ON, tedy zapnuto, jsou automaticky proměnné z polí $_GET[], $_POST[] a
$COOKIE[] k dispozici jako globální. Malá ukázka to osvětlí; dejme
tomu, že příklad níže je uložen ve skriptu test.php a volán jako
test.php&amp;id=5:
</p>

<!-- Zaza PHP kód BEGIN -->

<div class="codes"><code><font color="#000000"><font color="#007700">echo
</font><font color="#dd0000">"Register_globals je nastaveno na: "</font><font color="#007700">.</font><font color="#0000bb">ini_get</font><font color="#007700">(</font><font color="#dd0000">'register_globals'</font><font color="#007700">).</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Pomocí pole \$_GET je vždy k
dispozici: "</font><font color="#007700">.</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"id"</font><font color="#007700">].</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;<br>
echo </font><font color="#dd0000">"Jako globální proměnná: "</font><font color="#007700">.</font><font color="#0000bb">$id</font><font color="#007700">.</font><font color="#dd0000">"&lt;BR&gt;\n"</font><font color="#007700">;</font><br>
</font>
</code>
</div>

<!-- Zaza PHP kód END -->

<p>
Jestliže bude v php.ini register_globals <span style="font-weight: bold;">ZAPNUTO</span>, bude výstup tento:
</p>


<!-- Zaza PHP kód BEGIN -->

<div class="codes">
<code><font color="#000000">Register_globals je
nastaveno na: 1<br>
Pomocí pole $_GET je vždy k dispozici: 5<br>
Jako globální proměnná: 5</font>
</code>
</div>


<!-- Zaza PHP kód END -->

<p>
Jestliže však bude v php.ini register_globals <span style="font-weight: bold;">VYPNUTO</span>, bude výstup
tento:
</p>


<!-- Zaza PHP kód BEGIN -->

<div class="codes">
<code><font color="#000000">Register_globals je
nastaveno na:<br>
Pomocí pole $_GET je vždy k dispozici: 5<br>
Jako globální proměnná: </font>
</code>
</div>

<!-- Zaza PHP kód END -->

<p>
Jak tedy vidíte, je v případě zapnuté volby register_globals
proměnná $_GET["id"] k dispozici i jako $id.
</p>

<p style="font-style: italic;">Pozn.: Pokud si to chcete vyzkoušet
doma, budete mezi jednotlivými spuštěními skriptu muset upravit soubor
php.ini. Pokud vám běhá php jako modul serveru Apache, budete muset <span style="font-weight: bold;">navíc </span>ještě restartovat Apache, a
to z toho prostého důvodu, že php.ini se v takovém případě načítá pouze
při startu webového serveru.<br>
</p>
<p>Možná si kladete otázku, proč je kolem toho takový randál? Není to
snad poměrně jasné? Rámus kolem této konfigurační volby vznikl ve
třetím čtvrtletí roku 2000, kdy byla vydána verze PHP 4.2.0. Tato verze
totiž (a později každá následující) jakožto výchozí volbu po instalaci
PHP poprvé nastavila register_globals na VYPNUTO. Uživatelům, kteří
spoléhali na automatickou registraci proměnných (to je ten PRVNÍ z
případů výše), tak rázem přestaly fungovat některé skripty.<br>
</p>
<p>Byla to vzrušující doba. Jedni reagovali obviňováním autorů PHP,
jiní nahlašovali chybu do bugreportů, další požadovali ihned globální
proměnné zpět ZAPNOUT a ještě jiní uvažovali o přechodu na jiný jazyk,
protože tohle pro ně bylo prostě příliš... <br>
</p>
<p style="font-style: italic;">Pozn.: Dnes je situace taková, že na
"klasických" hostinzích budete mít nejspíš register_globals vypnuté s
tím, že na požádání vám ji zapnou. Chtít to zapnout je ale velmi špatný
nápad, viz níže.</p>
<p>Fakt je, že autoři PHP měli ke změně výchozího chování programu
poměrně pádné důvody. Ze stejných důvodů byste měli psát skripty tak,
aby fungovaly BEZ nutnosti registrace globálních proměnných. Takže, ty
důvody jsou dva:<br>
</p>
<ol>
  <li>Výkonový - Jestliže skript musel zaregistrovat proměnné jako
globální, zabralo to pochopitelně nějakou dobu, která by jinak mohla
být věnována dalšímu zpracování skriptu. Vypnutím register_globals to
už nebylo nutné a PHP tedy reaguje v takovém případě rychleji.</li>
  <li>Bezpečnostní - Se zapnutými register_globals se dá poměrně snadno
útočit na webové stránky. Jestliže například víte nebo tušíte, že
skript cosi.php používá proměnnou isadmin, a na serveru jsou zapnuty
register_globals, můžete se pokusit zaútočit pomocí url
cosi.php?isadmin=1 a doufat, že podstrčená proměnná skript zmátne. S
vypnutými register_globals to fungovat nemusí.</li>
</ol>
<p><span style="font-style: italic;">Pozn.: To neznamená, že skripty v
prostředí, kde je zapnuto register_globals jsou všechny nebezpečné.
Spíše je to tak, že se musejí přísněji kontrolovat. Rovněž to
neznamená, že po vypnutí register_globals budou vaše skripty v bezpečí.
Jen toto konkrétní riziko je menší. Na serveru PHP je o tom celém </span><a style="font-style: italic;" href="http://cz2.php.net/manual/en/security.globals.php">pěkné
pojednání</a><span style="font-style: italic;">.<br>
</span></p>
<p><span style="font-style: italic;">Pozn: Popsanými potížemi naštěstí
nejsou ovlivněny proměnné $_SESSION. Ty se totiž zpracovávají jinak.<br>
</span></p>
<p>Moje doporučení je: register_globals VYPNOUT a psát skripty tak, aby
fungovaly i bez něj i s ním.<span style="font-style: italic;"></span></p>
<p><span style="font-style: italic;"></span></p>
<a name="000399"></a><h2>variables_order</h2>
<p>To je částečně související problém s tím prvním. Jestliže byly
zapnuty register_globals a dvě proměnné by "padly" do stejné globální
proměnné (například $_GET["id"] a $_COOKIE["id"]), která to vyhraje? To
je ovlivněnou volbou variables_order v php.ini. Ta bude nejspíš
vyjádřena pětipísmennou zkratkou ve stylu "EGPCS", kde jednotlivá
písmena znamenají:<br>
</p>
<ul>
  <li>E - pole $_ENV</li>
  <li>G - pole $_GET, tedy proměnné z URL</li>
  <li>P - pole $_POST, tedy proměnné z formulářů</li>
  <li>C - pole $_COOKIE, tedy proměnné z uložených cookies</li>
  <li>S - pole $_SERVER, tedy informace o samotném serveru, který
soubor zpracovává<br>
  </li>
</ul>
<p>Znamená to, že při konfliktu globálních proměnných bude přiřazena do
globální proměnné hodnota z toho pole, které je v seznamu později, tedy
více vpravo. <br>
</p>
<p>Možná si kladete otázku: "Proč se tím zabývat - když se přece
nebudou používat globální proměnné, tak se nic nemůže stát?" Stát se
může, a to při použití pole $_REQUEST. Toto asociativní pole totiž bude
obsahovat proměnné z GET, POST i COOKIES. A pokud budou názvy
kolidovat, použije k rozřešení právě konfigurační volbu
variables_order. <br>
</p>
<p>Možností, jak to obejít je několik. Mezi nejznámější patří:<br>
</p>
<ul>
  <li>Vůbec nepoužívat pole $_REQUEST a používat namísto toho pole
$_GET, $_POST a $_COOKIE.</li>
  <li>Nastavit si chování volby variables_order podle svých potřeb v
každém skriptu pomocí ini_set. To půjde, protože variables_order patří
zrovna mezi ty volby, které můžete individuálně nastavovat.</li>
  <li>Důkladně testovat data, predaná pomocí $_REQUEST, což je ostatně
vždy žádoucí.<br>
  </li>
</ul>
<p> </p>
<p><span style="font-style: italic;">Pozn.: Opět platí, že proměnné
$_SESSION nejsou ovlivněné pořadím předávání proměnných a tudíž nemohou
být přepsány. V praxi to znamená, že jejich použití je poměrně
bezpečné. Možná právě proto jsou tak oblíbené mezi programátory PHP
stránek.</span><br>
</p>
<p>Moje doporučení je: Důkladně testovat data. Jinak se obecně použití
pole $_REQUEST nevyhýbám protože mohou existovat situace, kdy data
mohou dorazit jak pomocí metody POST, tak pomocí metody GET. Takže to v
takovém případě zjednodušuje práci. <br>
</p>
<p>Příště se podíváme na zbytek konfiguračních voleb, které Vám mohou
zatopit při tvorbě webových stránek.</p>
<a name="000400"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (91) - php.ini potřetí a naposledy</h2>
			<p class="perex">Jak se dají nastavit sessions, zobrazování chyb a upload souborů.
				<br>
			</p>
			<p>Dnes dokončíme zamyšlení nad konfiguračními volbami
v PHP. Rovněž si ukážeme, že něco málo lze dělat i v případě, kdy se
musíme spokojit s přednastavenou konfigurací.<span style="font-weight: bold;"></span></p>
<p><span style="font-weight: bold;"></span></p>
<a name="000401"></a><h2>Sessions</h2>
<p>V díle <a href="#000228">o
session proměnných</a>&nbsp; jsme si vysvětlili, že identifikátor
session může být stránce předán buď pomocí cookies, nebo pomocí
parametru v URL. Jedno i druhé má své pro a proti a obojí jde vypnout.
Abych to trochu upřesnil: použití cookies pro přenos identifikátoru
session se zapíná a vypíná konfigurační volbou <span style="font-style: italic;">session.use_cookies</span>. Pokud je to
povoleno, ukládají se identifikátory session jako cookies. Nevýhoda
tohoto přístupu k problematice spočívá v tom, že browser musí mít
povoleno přijímat cookies, jinak zkrátka nebudou session fungovat.
Výhoda je ta, že to je mnohem bezpečnější než posílat identifikátory
session v URL.<br>
</p>
<p style="font-style: italic;">Pozn.: Uvedené chování si můžete
vyzkoušet například tady na Linuxsoftu. Pokud zakážete přijímat
cookies, nebudete se moci přihlásit do svého profilu.<br>
</p>
<p>Pakliže selže uložení identifikátoru session, má server dvě možnosti:<br>
</p>
<ul>
  <li>session prostě nenastaví, nebo</li>
  <li>přiřadí identifikátor session jako parametr do url</li>
</ul>
<p>O tom, co se ve skutečnosti stane, rozhoduje nastavení konfigurační
volby <span style="font-style: italic;">session.use_only_cookies</span>.
Pokud používá server pro přenos identifikátoru session <span style="font-style: italic;">pouze </span>cookies, nastavení session
selže. Pokud ne, může nastavení jiné konfigurační volby, a sice <span style="font-style: italic;">session.use_trans_sid</span> způsobit, že
PHP přiřadí ID session do URL. Přiřazení identifikátoru session jako
parametru do URL má jednu podstatnou výhodu - bude to fungovat vždy, i
když budou cookies vypnuté. Má to taky jednu podstatnou nevýhodu - není
to vůbec bezpečné. Jestliže je totiž ID session posláno v URL, obdržíte
URL podobné tomuto:
http://www.server.cz/stranka.php?parametr=hodnota&amp;PHPSESSID=[identifikátor
session]. Tedy k session se může připojit kdokoli, kdo nějak zachytí
její identifikátor - vůbec to nemusí být ten, kdo session spustil (!)<br>
</p>
<p>Z tohoto důvodu bývá většinou posílání session v URL na serverech
zakázáno. A mimochodem, pokud musí PHP generovat URL s více než jedním
parametrem, použije k oddělení parametrů takovou sekvenci znaků, která
je nastavena v php.ini jako arg_separator.output. Pokud jste seriál
podrobně sledovali, pravděpodobně víte, že výchozí nastavení ("&amp;")
může generovat nevalidní dokumenty, a že správné nastavení je
"&amp;amp;". Pakliže tedy budete ověřovat validitu stránek používající
sessions a přenášející sessions v URL a budete mít v dokumentu chyby
"ampersands in URLs", je to pravděpodobně ten důvod.<br>
</p>
<p> </p>
<a name="000402"></a><h2>Error_reporting</h2>
<p>Následující dotaz pochází od jednoho čtenáře: Ptal se mě, proč
následující skript:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">echo
</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"cosi"</font><font color="#007700">];</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>pokud se volá bez předání proměnné "cosi" na jeho domácím počítači
skončí hláškou "Notice: Undefined index", zatímco v práci normálně
proběhne. Odpověď je prostá, závisí to na nastavení úrovně chybových
hlášení, a to se opět děje pomocí php.ini. Existují konstanty, pomocí
nichž se dá nastavit, která úroveň chyb se bude hlásit. Takže můžete
například hlásit závažné chyby, varování, poznámky, chyby kompilace a
podobně. Více se o tom dozvíte v manuálu k PHP na stránce, věnované
funkci <a href="http://cz.php.net/error_reporting">error_reporting</a>.
O typech chyb jsme rovněž mluvili v <a href="#000117">díle o
chybách</a>.<br>
</p>
<p>Příjemné je vědět, že pomocí funkce error_reporting lze v každém
skriptu zakázat či povolit zobrazování určitých chyb. Nemusíte tedy
kvůli tomu používat funkci ini_set. Ukázku by šlo přepsat tak, aby
nevracela upozornění na neinicializovanou proměnnou pomocí
následujícího kódu:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">error_reporting</font><font color="#007700">(</font><font color="#0000bb">0</font><font color="#007700">);<br>
echo </font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"cosi"</font><font color="#007700">];</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>S používáním chybových hlášení ve skriptech souvisí ještě jeden
zajímavý problém, vlastně dva:<br>
</p>
<ol>
  <li>Uživatele nebude chybová hláška zajímat, tudíž by bylo dobré mu
ji neukazovat</li>
  <li>Některé chybové hlášky bývají dost upovídané. Například prozradí
ve kterém skriptu k chybě došlo a na jakém řádku. To může být
neocenitelné při ladění; na webu to však může poněkud snižovat
bezpečnost (tak třeba jste vůbec nechtěli, aby někdo tušil, že daný
skript existuje, a ono se to provalí kvůli chybě).</li>
</ol>
<p>Převážně z těchto dvou důvodů lze vypnout zobrazování chyb pomocí
konfigurační direktivy display_errors, a zapnout naopak protokolování
chyb pomocí související direktivy log_errors.<br>
</p>
<a name="000403"></a><h2>post_max_size</h2>
<p>Konečně ještě jeden tip k přenášení dat pomocí formulářů.
Konfigurační volba post_max_size určuje, kolik se maximálně smí přenést
dat pomocí formulářů zpracovávaných metodou POST. Jelikož jsme si <a href="#000133">ukázali</a>,
že pomocí formulářů lze přenášet na server i soubory, ovlivňuje tato
volba i maximální velikost souborů, které je možné uploadovat (společně
s volbou upload_max_filesize). Znát něco takového může být užitečné ze
dvou důvodů:<br>
</p>
<ul>
  <li>Když chcete zabránit skriptu, aby nešly nahrát velké soubory
(někteří uživatelé tvrdí, že za jistých okolností nemusí stačit použít
hednotu <code><font color="#000000">MAX_FILE_SIZE </font></code>ve
formuláři, sám jsem se s tím nesetkal)</li>
  <li>Když chcete vědět, proč Vám nejde odeslat formulář obsahující
kvanta dat.</li>
</ul>
<p>Možná si říkáte, že kromě odesílání souborů to k ničemu není.
Existují však aplikace, které skutečně kvanta dat ve formulářích
odesílají. Tak například PHPmyAdmin umožňuje pomocí formuláře
uploadovat definici databáze, nebo rovněž databázová data. To skutečně
může narůst na několik MB a možná byste marně pátrali po příčině, proč
to nejde nahrát na server.<br>
</p>
<p> </p>
<a name="000404"></a><h2>Bezpečnost především</h2>
<p>Ve třech posledních dílech jsme se podívali na některé běžnější
volby jazyka PHP. Zejména na ty, které budou zajímat programátory,
protože přímo ovlivňují běh skriptů nebo mohou způsobit, že skript
někde běží a jinde ne. To však neznamená, že nyní budete schopni
nastavit php.ini tím nejlepším způsobem. Abyste uměli nastavit php.ini
"správně", museli byste se zabývat přinejmenším ještě následujícími
věcmi:<br>
</p>
<ul>
  <li>použitým webovým serverem</li>
  <li>tím, zda PHP poběží jako CGI či modul<br>
  </li>
  <li>operačním systémem, na němž PHP běží</li>
  <li>požadavky na výkon, škálovatelnost a zabezpečení</li>
  <li>a konečně, pokud by PHP využívalo více lidí, tak i (ne)možností
uspokojit více požadavků na konfiguraci od jednotlivých uživatelů<br>
  </li>
</ul>
<p> </p>
<p><span style="font-style: italic;">Pozn.:Murphyho zákon přitom
stanoví, že u jednoznačných voleb dojde k situaci, kdy každá polovina
uživatelů bude chtít přesně opačné nastavení.</span><br>
</p>
<p>Neboli, kvalitní instalace a nastavení php (včetně php.ini) jde nad
rámec tohoto seriálu a v praxi by měla být svěřena kvalifikovanému
správci. My příště opustíme téma nastavování php a zamyslíme se nad
tím, zda a jak se dá PHP použít k něčemu jinému než ke tvorbě
internetových stránek.</p>
<a name="000405"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (92) - funkce pro interakci s operačním systémem</h2>
			<p class="perex">Může PHP spouštět systémové příkazy? A jestliže ano, tak jak?
				<br>
			</p>
			<p>Ačkoli PHP se v naprosté většině případů používá k tvorbě
dynamických webových stránek, je dobré vědět, že může být použito i
jinak. V dnešním díle se zamyslíme nad&nbsp; způsoby, jakými může
programátor pomocí PHP zasahovat do operačního systému.<br>
</p>
<a name="000406"></a><h2>Utajený prováděcí operátor</h2>
<p>Prováděcí operátor je obrácený apostrof (`). Nepleťte si jej s
klasickým apostrofem ('). Na tomto operátoru není nic tajného, nazval
jsem ho tak prostě proto, že ho většina lidí vůbec nezná. Ve skriptu
tahle potvůrka způsobí, že příkaz, který je uzavřený v obrácených
apostrofech PHP ignoruje a je předán k provádění operačnímu systému.
Takže můžete
například napsat:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">echo
`</font><font color="#0000bb">ls</font><font color="#007700">`;</font><br>
</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Když se to spustí, provedou se následující věci:<br>
</p>
<ul>
  <li>Skript narazí na příkaz v obrácených apostrofech</li>
  <li>Skript jej provede jako příkaz operačního systému</li>
  <li>Ten příkaz může něco vrátit (ls samozřejmě vrací výpis souborů)</li>
  <li>To, co příkaz vrátil, může PHP zpracovat (může to být uloženo do
proměnné, vytištěno a tak dále)</li>
</ul>
<p>V praxi si to budete moci vyzkoušet málokde. Na naprosté většině
webhostingů je obrácený apostrof zakázán, protože administrátor bude
stěží chtít, abyste pomocí PHP jakkoli manipulovali s hostitelským
počítačem. Může se to ale hodit například při vývoji intranetových
aplikací, kde to za určitých podmínek může být relativně bezpečné.<br>
</p>
<p>Pokud budete z nějakého důvodu chtít nebo muset používat prováděcí
operátor, měli byste pamatovat na následující věci:<br>
</p>
<ol>
  <li>Omylem nebo úmyslně tak můžete vytvořit skripty, které jsou
nepřenositelné na jinou platformu. Protože například Windows nemají
příkaz ls, příklad výše by tam nefungoval.</li>
  <li>Pokud potřebujete nejen spouštět akce na serveru, ale rovněž
zpracovávat výstupy z těchto akcí pamatujte, že si můžete pěkně
naběhnout. Výstup může být totiž formátován jinak, než byste snad
očekávali, či může být v jiné znakové sadě. <br>
  </li>
  <li>Jestliže spustíte příkaz, který by normálně očekával uživatelský
vstup, PHP se může jevit jako zaseklé, protože spuštěný program nebyl
ukončen a PHP čeká na výsledky.</li>
  <li>Jestliže stránka obsahuje prováděcí operátor a v prohlížeči
zrušíte její načítání, neznamená to automaticky, že spuštěný příkaz
operačního systému bude zrušen (!)</li>
  <li>V jednom skriptu lze použít více systémových volání. V takovém
případě jsou spouštěny asynchronně (to znamená, že druhé nečeká na
dokončení prvního)</li>
  <li>Paměť, kterou spotřebuje příkaz operačního systému se v takovém
případě zahrnuje do maximálního množství paměti, kterou lze přidělit
PHP skriptu. Neboli, pokud by běh externího procesu, spuštěného pomocí
prováděcího operátoru potřeboval ke své činnosti více paměti, než kolik
může PHP použít, nebude spuštěn.</li>
  <li>Jestliže běží PHP v <a href="http://cz2.php.net/manual/cs/features.safe-mode.php">safe-mode</a>,
prováděcí operátor nefunguje.<br>
  </li>
</ol>
<p>S prováděcím operátorem se tedy dá především na hodně místech
narazit a tak je jeho použití spíš nedoporučované. Ale má-li webová
stránka nějakým způsobem ovlivňovat hostitelský počítač, je prostor k
jeho použití. Ekvivalentem prováděcího operátoru je PHP funkce <a href="http://cz2.php.net/manual/cs/function.shell-exec.php">shell_exec</a>,
což se jistě bude hodit zejména těm, kdo nechtějí lovit zpětné
apostrofy na klávesnici.<br>
</p>
<a name="000407"></a><h2>Funkce system</h2>
<p>Smyslem funkce <a href="http://cz.php.net/manual/cs/function.system.php">system()</a> je
rozšířit shell_exec o možnost
zpracovávat návratovou hodnotu volaného systémového příkazu. Jako
nepovinný druhý parametr totiž může přebírat název proměnné, do níž se
návratová hodnota shellového příkazu uloží. Takže můžete dělat takové
věci jako testování návratové hodnoty a rozhodnutí se, co dělat. Funkce
system však neumožňuje zpracovat celý výstup příkazu, protože v případě
úspěchu vrací <span style="font-style: italic;">pouze </span>poslední
řádek výstupu. (V případě neúspěchu pak vrací FALSE).<br>
</p>
<p>Pro ty, kdo se s návratovými hodnotami ještě nesetkali - jsou to
hodnoty vrácené provedeným programem, indikují převážně to, zda se
programu "povedlo co zamýšlel" a
bývají dokumentovány. Tak například GNU verze systémového příkazu grep
může vrátit jako návratovou hodnotu nulu v případě, kdy byly nalezeny
nějaké shody, jedničku pokud nebyly a dvojku pokud došlo k chybě. PHP
funkce system() tedy může návratovou hodnotu zachytit a zpracovat.<br>
</p>
<p> </p>
<a name="000408"></a><h2>Funkce exec</h2>
<p>Funkce <a href="http://cz.php.net/manual/cs/function.exec.php">exec()</a>
je mocnější než funkce system v tom, že umožňuje jak získat
návratovou hodnotu volaného systémového příkazu, tak i celý jeho výstup
(ne tedy jen poslední řádek výstupu). Jde na to tak, že ukládá každý
řádek výstupu do jednoho prvku pole. Konkrétní využití by mohlo
spočívat třeba ve zpracování souborů protokolů, protože ty velmi často
píší jednu zprávu na jeden řádek.<br>
</p>
<a name="000409"></a><h2>Funkce passthru</h2>
<p>Funkce <a href="http://cz.php.net/manual/cs/function.passthru.php">passthru()</a>
se prakticky ve všem podobá funkci system(), ale umí bezpečně zpracovat
binární data. Jinak název vám může připomenout funkci <a href="http://cz.php.net/manual/cs/function.fpassthru.php">fpassthru</a>,
která však vrací data ze souboru. Passthru samozřejmě vrací data
výstupu příkazu operačního systému.<br>
</p>
<a name="000410"></a><h2>Bezpečnost</h2>
<p>Spouštět ze skriptů příkazy pro operační systém hostitele je již z
principu nebezpečná věc. Takže, jak již bylo uvedeno, většina správců
to při konfiguraci PHP nadšeně zakáže. Nicméně, pokud byste chtěli a
mohli výše uvedené příkazy použít, měli byste si si ověřit, že to, co
předáváte jako příkaz operačnímu systému pokud možno nesouvisí s
uživatelským vstupem. Jinak by totiž uživatel mohl zadat příkaz, který
jste nezamýšleli.<br>
</p>
<p>Jestliže však přece jen musí být systémový příkaz závislý na zadání
uživatele (čemuž byste se opravdu měli vyhýbat), vzniká problém.
Podobný problém jsme již řešili při úvaze o uživatelských vstupech z
formulářů. Špatná data z formuláře však mohla nejspíš poškodit
zobrazenou stránku, nebo data z databáze. Tohle je mnohem horší,
neošetřeným vstupem byste mohli dostat do potíží celý operační systém.<br>
</p>
<p>Obecně lze doporučit funkci <a href="http://cz.php.net/manual/cs/function.escapeshellcmd.php">escapeshellcmd</a>.
Ta oescapuje metaznaky shellu tak, aby byl předaný příkaz
nezneužitelný. Trochu se svou filozofií podobá tomu, co v případě
řetězců předávaných databázi dělá funkce <a href="http://cz.php.net/manual/cs/function.addslashes.php">addslashes</a>,
totiž že upravuje informace, které PHP předává nějakému externímu
softwaru. Pakliže budete předávat nějaké parametry, často můžete trochu
ovlivnit to, co obsahují. Třeba zda se jedná o číslo či řetězec, jak to
bude velké či dlouhé nebo které znaky se tam smí a nesmí vyskytovat.<br>
</p>
<p>Rovněž byste neměli přiliš spoléhat na tvar, v jakém dorazí data z
příkazu operačního systému. To se týká zejména situací, kdy se
programátor spoléhá na výstupní data systémového příkazu. Pokud lze
přepsat příkaz tak, aby mu stačila "jen" návratová hodnota externího
procesu, udělejte to. Pokud ne, vrácená data analyzujte, než s nimi
něco uděláte. Rovněž si uvědomte, že příkazy, které voláte, mohou po
změně konfigurace systému vracet jiné výsledky či jinak formátovaná
data.<br>
</p>
<p>Konečně, tohle je přesně ta situace, kdy je třeba probrat všechny
katastrofické scénáře. Systémový příkaz může selhat, spotřebovat
dostupnou paměť, čekat na uživatelský vstup, dlouho trvat, kolidovat s
jiným vláknem či procesem, přestat odpovídat a já nevím, co ještě. Měli
byste se ujistit, že s takovými situacemi počítáte a umíte je řešit.<br>
</p>
<p>V dalším díle seriálu se podíváme na to, jak použít PHP z příkazové
řádky.</p>
<a name="000411"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (93) - příkazový řádek</h2>
			<p class="perex">Jak použít PHP, když někdo neumí programovat v shellu?
				<br>
			</p>
			<p>PHP vlastně vůbec nemusí běžet na webu. Ačkoli jeho použití jinde je
velmi vzácné, PHP může běžet z příkazové řádky na běžném počítači.
Nemusí se tedy jednat o server a úkolem PHP nemusí být vytváření
dynamického obsahu stránek. Ale popořadě.</p>
<p><span style="font-weight: bold;"></span></p>
<a name="000412"></a><h2>PHP a shell<br>
</h2>
<p>Především - toto můžete vyzkoušet, pokud máte k dispozici
spustitelnou (CGI) verzi PHP. Jestliže máte PHP zkompilován a
zkonfigurován jako modul serveru Apache, nebude Vám fungovat nic z
toho, co budeme popisovat dále. To, zda máte PHP spuštěn jako CGI či
jako modul Apache poznáte z výstupu funkce phpinfo(). Pokud je v
obecných informacích uveden v položce <span style="font-style: italic;">Server
API</span> údaj <span style="font-style: italic;">CGI/FastCGI</span>,
máte
vyhráno a můžete číst dál. Pakliže tam máte uvedeno <span style="font-style: italic;">Apache 2.0 Handler</span>
či něco podobného, běží vám PHP jako modul Apache a to jej pak nemůžete
spouštět z příkazové řádky.<br>
</p>
<p>Což neznamená, že musíte zoufat. PHP je navrženo tak, že Vám
umožňuje instalaci jak spustitelné verze, tak i modulu na jednom
stroji. Takže, pokud pracujete na Linuxu, můžete zkusit štěstí a
vyhledat spustitelnou verzi PHP příkazem:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">whereis php</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Pakliže jste na Windows, můžete podobnou věc zkusit pomocí:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">dir php.exe /s</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V obou případech se Vám může podařit najít binárku PHP a tu pak
můžete vesele spustit (máte-li k tomu dostatečná práva). Některé
distribuce totiž instalují obě verze PHP - modulovou i spustitelnou.<br>
</p>
<a name="000413"></a><h2>Primitivní příklad</h2>
<p>Jestliže existuje v systému binární soubor PHP, můžete napsat
"systémový" skript v PHP! Abyste viděli jak na to, použijeme jako
příklad
následující protřelý ;-)) shellový skript, který se pokusíme přepsat do
PHP:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">#!/bin/sh<br>
<br>
echo "Jsem to ale chytrej skript"</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Kód je to velmi triviální - jen dodejme, že v tomto skriptu značí
echo <span style="font-style: italic;">vestavěný příkaz shellu</span>.
Jeho spuštění samozřejmě vypíše text na standardní výstup. Do PHP se dá
přepsat velice jednoduše - prostě do první řádky napíšeme cestu k
binárnímu souboru PHP (a nastavíme soubor jako spustitelný) a zbytek
přepíšeme podle platné syntaxe PHP. Takže z toho bude něco ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">#!/usr/bin/php<br>
<br>
<font color="#0000bb">&lt;?<br>
</font><font color="#007700">echo </font><font color="#dd0000">"Jsem
to ale chytrej skript"</font><font color="#007700">;<br>
</font><font color="#0000bb">?&gt;</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Co je jinak? Především, sdělili jsme milému shellu, že má ke
spuštění skriptu použít php, to je ten první řádek. Potom, zbytek
skriptu musí mít platnou systaxi PHP - takže blok PHP kódu bude uzavřen
do odpovídajících závorek, řádky budou ukončeny středníky a tak dále. V
tomto případě je samozřejmě příkaz echo interpretován pomocí PHP,
nikoli pomocí shellu.<br>
</p>
<p style="font-style: italic;">Pozn.: Když máte php jinde než v
/usr/bin/php, budete si muset první řádek skriptu odpovídajícím
způsobem upravit.</p>
<p></p>
<p>Pakliže to zkusíte spustit, nedopadne výsledek podle očekávání.
Namísto toho, aby se příkaz prostě provedl, vypsal co má a ukončil
nejspíš uvidíte něco jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">Content-type: text/html<br>
X-Powered-By: PHP/4.3.9<br>
<br>
Sem to ale chytrej skript</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Kde je chyba? Chyba není nikde, pouze PHP se snaží generovat
odpovídající hlavičky pro prohlížeč. Ty však v příkazové řádce nemají
využití a dají se potlačit pomocí přepínače "-q". Pro úplnost dodejme,
že tento přepínač lze použít v prvním řádku skriptu, který pak bude
vypadat takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">#!/usr/bin/php -q</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a celý skript bude dělat přesně to, co předpokládáme.<br>
</p>
<a name="000414"></a><h2>Přepínače a tipy</h2>
<p>Přepínač "-q" není jediný, který můžeme při volání PHP z příkazové
řádky použít. Na <a href="http://cz.php.net/manual/cs/features.commandline.php">stránkách
PHP</a> je k dispozici tabulka s ostatními přepínači. Tak například
přepínač "-i" způsobí, že obdržíme výstup stejný, jako kdybychom
zavolali funkci phpinfo(). Volbou "-s" obdržíme výstup obarveného kódu,
jako kdybychom jej "prohnali" funkcí <a href="http://cz.php.net/manual/cs/function.show-source.php">show_source</a>.
Konečně další důležitá volba je "-f", která hledá v souboru chyby
syntaxe.<br>
</p>
<p>Dobrý tip pro použití řádkového PHP je třeba přesměrovat výstup do
souboru. Provede se to standardními prostředky operačního systému.
Takže, napíšete-li například něco ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">php -i &gt;&gt;~/test.htm</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>vznikne vám v domovském adresáři de facto stejná html stránka, jakou
byste získali pomocí funkce phpinfo() a následným uložením zdrojového
kódu stránky, pokud by se tato činnost prováděla na serveru. Použitím
filtrů můžete získat jen část výstupu, ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">php -i | grep "Server
API"</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a použitím dalších technik lze docílit výsledků, jakých byste
docílili s klasickými příkazy shellu. Můžete třebas takto napsané
skripty spouštět pomocí příkazů <span style="font-style: italic;">at</span>
a <span style="font-style: italic;">cron</span> a tak dále.<br>
</p>
<a name="000415"></a><h2>Závěr</h2>
<p>K čemu je spouštění PHP skriptů bez serveru dobré? Ačkoli by se
mohlo zdát, že k ničemu, v praxi se to přece jen někdy používá. Vybavil
bych si dva příklady:<br>
</p>
<ol>
  <li>Když někdo neumí programovat v shellu, ale umí v PHP a potřebuje
rychle napsat nějaký shellový skript. Kvůli jednomu skriptu se asi
nikdo nebude chtít učit jiný jazyk, takže tohle je dobrá záchrana.</li>
  <li>Když se má zajistit, aby se určitý PHP skript spouštěl v nějakou
dobu. Může se jednat třeba o skript, který provede denní údržbu
databáze a podobně. Ten skript může klidně fungovat jako součást
existujícího webu s tím, že pro účely automatického zálohování bude
spouštěn pomocí binárního (CGI) modulu PHP.<br>
  </li>
</ol>
<br>
<a name="000416"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (94) - GUI</h2>
			<p class="perex">PHP
se dá kromě tvorby webu a shellových skriptů použít i k vytváření
samstatných aplikací - včetně grafického rozhraní. Klíčem k tomu je
PHPGTK. <br>
			</p>
			<p>Ačkoli to mnoho lidí vůbec neví, dá se PHP kromě tvorby webových
stránek (a kromě použití jako shellový interpreter) použít rovněž jako
obecný jazyk pro tvorbu samostatných aplikací, a to dokonce aplikací s
grafickým rozhraním. V tomto a následujícím díle si trochu ukážeme, jak
na to.<br>
</p>
<p><span style="font-weight: bold;"></span></p>
<a name="000417"></a><h2>Princip<br>
</h2>
<p>Samotné PHP nemá žádné prostředky pro tvorbu GUI (graphic user
interface, grafické uživatelské rozhraní). Tím mám na mysli prostředky
pro tvorbu oken s tlačítky, rozevíracími seznamy, zaškrtávači,
přepínači a tak dále. Existují nicméně samostatně napsané programy,
jejichž úkolem je - zjednodušeně řečeno - vytvářet prvky grafického
uživatelského rozhraní. Takže, kdyby se PHP na některý takový program
(často se nazývá toolkit) vhodně napojilo, mohla by vzniknout zajímavá
kombinace, že? Zejména, kdyby takový toolkit byl dostupný pod nějakou
symatickou licencí a kdyby fungoval pod více operačními systémy.<br>
</p>
<p>Tvůrci dnes již velmi populárního programu pro manipulaci s obrázky
GIMP (na Linuxsoftu máme mimochodem o GIMPu <a href="http://www.linuxsoft.cz/gimp/">seriál</a>) přesně takový toolkit
kdysi potřebovali. Takže vznikl <a href="http://www.gtk.org/">GTK+</a>,
neboli "The Gimp Toolkit" - nezávislý balíček pro tvorbu grafického
uživatelského rozhraní. Šířen je pod licencí GNU LGPL, čili patří mezi
svobodný software. Software je to velmi používaný, GTK+ je například
základem prostředí GNOME.<br>
</p>
<p>A teď to nejlepší - GTK+ funguje pod Windows i pod Linuxem a
existuje projekt spojující PHP a GTK+! Takže pomocí PHP můžeme vytvářet
aplikace s grafickým rozhraním, aniž bychom se museli zabývat
"nízkoúrovňovým" programováním samotného rozhraní. Projekt, který PHP a
GTK integruje se nazývá PHPGTK a má pochopitlně svoje internetové <a href="http://gtk.php.net/">stránky</a>. Pojďme se krátce podívat na
to, jak takovou věc vůbec zprovoznit:<br>
</p>
<a name="000418"></a><h2>Instalace PHPGTK</h2>
<p><span style="font-weight: bold;">Windows</span></p>
<p><span style="font-weight: bold;"></span></p>
<p>PHPGTK je potřeba <a href="http://gtk.php.net/download.php">stáhnout</a>
a rozbalit. Soubor README.txt popisuje, kam se jednotlivé složky mají
překopírovat (to uděláte ručně). Část archivu se musí dostat do složky,
kde máte nainstalované PHP a část do systémové složky WINDOWS. Je to
poměrně dobře dokumentované. Instalací si můžete přepsat soubor php.ini
(což osobně nepovažuji za příliš dobrý nápad), nebo si můžete sekci,
týkající se PHP do vlastního php.ini překopírovat (mnohem lepší).
Distribuce obsahuje rovněž příklady, které si můžete spustit a
vyzkoušet. GTK+ aplikace se spouštějí pomocí souboru php_win.exe, takže
můžete naspat něco ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">c:\php\php_win
D:\pokus\gtk\gtk.php</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>a měl by se vám objevit požadovaný příklad.<br>
</p>
<p style="font-weight: bold;">LINUX</p>
<p>Ověřte si, zda máte k dispozici GTK. Způsob, jakým to provedete bude
záležet na možnostech konkrétní distribuce, pro Fedoru Core můžete
například použít něco ve smyslu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">yum search gtk | grep
installed<br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Dále si ověřte, zda máte nainstalováno PHP 4.3.4 nebo novější. Pokud
jste četli předchozí díl seriálu, asi pro Vás nebude překvapením, že to
z terminálu většinou můžete provést pomocí příkazu:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">php -v</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Stáhněte si nejnovější verzi ze stránek <a href="http://gtk.php.net/download.php">gtk.php.net</a>. Například v
době psaní tohoto článku to bylo takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">wget
http://gtk.php.net/do_download.php?download_file=php-gtk-1.0.1.tar.gz</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Směle to rozbalte a pusťte se do kompilace pomocí:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">./buildconf<br>
./configure<br>
make<br>
make install</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Hotovo! Celý proces je poměrně dobře zdokumentován na <a href="http://gtk.php.net/wiki/Resources/Installation">stránkách
projektu</a>, takže byste se v případě problémů neměli ztratit.<br>
</p>
<a name="000419"></a><h2>Něco málo příkladů</h2>
<p>Především, kompletní popis již samotné filozofie použití PHP-GTK je
silně nad rámec tohoto článku, takže se omezíme jen na to opravdu
nejdůležitější. Klasický začátečnický příklad "Hello world" byste
pomocí PHP-GTK napsali nějak takto:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?php<br>
<br>
</font><font color="#007700">if (!</font><font color="#0000bb">extension_loaded</font><font color="#007700">(</font><font color="#dd0000">'gtk'</font><font color="#007700">)) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">dl</font><font color="#007700">( </font><font color="#dd0000">'php_gtk.' </font><font color="#007700">. </font><font color="#0000bb">PHP_SHLIB_SUFFIX</font><font color="#007700">);<br>
}<br>
<br>
</font><font color="#ff8000">// při zavření okna<br>
</font><font color="#007700">function </font><font color="#0000bb">destroy</font><font color="#007700">()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">Gtk</font><font color="#007700">::</font><font color="#0000bb">main_quit</font><font color="#007700">();<br>
}<br>
<br>
</font><font color="#ff8000">// při kliknutí na tlačítko<br>
</font><font color="#007700">function </font><font color="#0000bb">hello</font><font color="#007700">()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;global&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$window</font><font color="#007700">;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$window</font><font color="#007700">-&gt;</font><font color="#0000bb">destroy</font><font color="#007700">();<br>
}<br>
<br>
</font><font color="#ff8000">// Nadefinujeme si okno<br>
</font><font color="#0000bb">$window </font><font color="#007700">=
&amp;new </font><font color="#0000bb">GtkWindow</font><font color="#007700">();<br>
</font><font color="#0000bb">$window</font><font color="#007700">-&gt;</font><font color="#0000bb">set_border_width</font><font color="#007700">(</font><font color="#0000bb">10</font><font color="#007700">);<br>
</font><font color="#0000bb">$window</font><font color="#007700">-&gt;</font><font color="#0000bb">connect</font><font color="#007700">(</font><font color="#dd0000">'destroy'</font><font color="#007700">, </font><font color="#dd0000">'destroy'</font><font color="#007700">);<br>
<br>
</font><font color="#ff8000">// a čudlíček...<br>
</font><font color="#0000bb">$button </font><font color="#007700">=
&amp;new </font><font color="#0000bb">GtkButton</font><font color="#007700">(</font><font color="#dd0000">'Hello World!'</font><font color="#007700">);<br>
</font><font color="#0000bb">$button</font><font color="#007700">-&gt;</font><font color="#0000bb">connect</font><font color="#007700">(</font><font color="#dd0000">'clicked'</font><font color="#007700">, </font><font color="#dd0000">'hello'</font><font color="#007700">);<br>
<br>
</font><font color="#ff8000">//který do okna přidáme<br>
</font><font color="#0000bb">$window</font><font color="#007700">-&gt;</font><font color="#0000bb">add</font><font color="#007700">(</font><font color="#0000bb">$button</font><font color="#007700">);<br>
<br>
</font><font color="#ff8000">// zobrazíme to ...<br>
</font><font color="#0000bb">$window</font><font color="#007700">-&gt;</font><font color="#0000bb">show_all</font><font color="#007700">();<br>
<br>
</font><font color="#ff8000">// a jedeme<br>
</font><font color="#0000bb">Gtk</font><font color="#007700">::</font><font color="#0000bb">main</font><font color="#007700">();<br>
<br>
</font><font color="#0000bb">?&gt;<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Dokážu si představit, že jste z toho dost vyjukaní, zejména pokud
jste nikdy nepracovali s jazyky ovládajícími grafické uživatelské
rozhraní (jako je C++, Java a podobně). Proto si příště tento příklad
trochu hlouběji rozebereme. Abych ale prozradil alespoň něco: tento
přístup využívá objekty; už jsme o nich mluvili v <a href="#000078">19.</a> a <a href="#000080">20.</a> díle
našeho seriálu. Objekty mohou vzájemně souviset (takže například
tlačítko souvisí s oknem, na němž je zobrazeno). Ale víc už
neprozradím, sledujte příští díl seriálu.<br>
</p>
<p>Mimochodem, docela by mě zajímalo, jestli někdo z čtenářů PHPGTK
používá a k čemu. Podělte se s námi v diskusi!</p>
<a name="000420"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (95) - GUI podruhé</h2>
			<p class="perex">Dnes si trochu hlouběji rozebereme, jak funguje spolupráce mezi PHP a knihovnou pro tvorbu grafického rozhraní.
				<br>
			</p>
			<p>Protože jsme minule jen lehce nastínili způsob, jakým lze PHP použít
pro tvorbu aplikací s grafickým rozhraním, budeme to dnes muset trochu
rozvést. Začneme okomentováním příkladu, který jsme použili v <a href="#000416">předchozím
díle</a>.<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#007700">if
(!</font><font color="#0000bb">extension_loaded</font><font color="#007700">(</font><font color="#dd0000">'gtk'</font><font color="#007700">)) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">dl</font><font color="#007700">( </font><font color="#dd0000">'php_gtk.' </font><font color="#007700">. </font><font color="#0000bb">PHP_SHLIB_SUFFIX</font><font color="#007700">);<br>
}</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Už tohle by mohlo někoho odradit. Dva řádky kódu, a čtyři neznámé
věci
v nich. Takže popořadě: především je zde použita funkce
<a href="http://cz.php.net/manual/cs/function.extension-loaded.php">extension_loaded()</a>.
Její název je dostatečně popisný - vrací TRUE, pokud
je nahrána externí knihovna (jako například PHPGTK). Tuto funkci byste
si měli při programování v PHPGTK zvyknout používat, protože jakmile se
dostanete ke vkládání souborů pomocí include (require), velmi brzo se
můžete dostat do situace, kdy nevíte, zda jste již extenzi nahráli či
nikoli. Filozofií se to trochu podobá testování, zda je k dispozici
daná funkce (pomocí function_exists), ale zde jde samozřejmě o celou
knihovnu. Jak víme, že název hledané knihovny je <span style="font-style: italic;">gtk</span> a ne třeba <span style="font-style: italic;">gtklib</span>? Pokud si to nepamatujete z
hlavy, může Vám pomoci dokumentace nebo můžete vyvěštit název extenze z
výstupu funkce phpinfo().<br>
</p>
<p>Pak je tu funkce <a href="http://cz.php.net/manual/cs/function.dl.php">dl()</a> - ta danou
knihovnu za běhu PHP načítá. Je
zajímavé, že manuál neuvádí zda a jakou návratovou hodnotu tato funkce
má. Experimentálně se mi podařilo zjistit, že funkce vrací TRUE v
případě, kdy se povede externí knihovnu nahrát, v opačném případě vrátí
FALSE (třeba, když máte špatně uveden název knihovny, funkce dl je
zakázána a podobně). Pokud by to byla pravda, mohli byste úspěšnost
nahrání knihovny testovat a zařídit se podle výsledku. Nicméně, protože
to není v manuálu k PHP dobře zdokumentováno, neměli byste na moje
experimenty příliš spoléhat.<br>
</p>
<p>Funkce dl() očekává název knihovny jako parametr. K tomu je rovněž
třeba říci několik věcí. Předně - knihovny jsou hledány v umístění,
specifikovaném pomocí konfigurační direktivy extension_dir v php.ini. A
dále, předaný název musí v tomto případě být názvem souboru operačního
systému. Konstanta PHP_SHLIB_SUFFIX, přidaná v PHP 4.3.0 značí příponu
knihovny a bude pravděpodobně záviset na operačním systému, na němž PHP
poběží (typicky to bude "so" na linuxu, "dll" na windows).<br>
</p>
<a name="000421"></a><h2>Widgety a kontejnery</h2>
<p>Teď, když už máme knihovnu nahranou si trochu rozebereme příkazy pro
zobrazení okna a tlačítka a pro jeho obsluhu. Knihovna PHPGTK je
organizována tak, aby se v ní člověk, který ji má
používat vyznal, přestože ji nestvořil.<br style="font-style: italic;">
</p>
<p><span style="font-style: italic;">Pozn.: To není tak samozřejmé, jak
by se na první pohled mohlo zdát. Schopnost napsat knihovnu tak, aby se
v ní vyznal cizí člověk je vysoce ceněná a kdo to dokáže, ten je
pravděpodobně velmi dobrý programátor. Patří k tomu takové "drobnosti"
jako správná organizace kódu, zapamatovatelné názvy či kvalitní
dokumentace. V praxi se lze často setkat s více knihovnami,
nabízejícími podobné funkce. Jestliže se pak v&nbsp; jedné vyznáte a ve
druhé nikoli - která bude asi komerčně úspěšnější?<br>
</span></p>
<p>Jak zjistíte, v knihovně PHPGTK se vyznáte celkem snadno, přestože
je dost veliká. Uvidíme z našeho příkladu. Především tu máme příkaz,
kterým <span style="font-weight: bold;">vytvoříme</span> nové okno.<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$window
</font><font color="#007700">= &amp;new </font><font color="#0000bb">GtkWindow</font><font color="#007700">();</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>V dokumentaci byste <a href="http://gtk.php.net/manual/cs/widgets.whatare.php">našli</a>, že
PHPGTK používá k materializaci prvků uživatelského rozhraní tzv.
widgety (česky "věcičky", "udělátka"). Příkladem widgetu může být třeba
okno, tlačítko nebo rozbalovací seznam. A právě příkazem výše jsme
vytvořili nový widget (okno) a vtipně si jej nazvali $window. Uvědomte
si ale, že okno zatím existuje jako pouhý objekt v paměti stroje - nic
neumí a není ještě vidět!<br>
</p>
<p>Jeden widget nám však v prográmku nestačí - kromě okna potřebujeme
ještě mít tlačítko. Pojďme tedy <span style="font-weight: bold;">vytvořit</span>
další widget - tlačítko:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$button
</font><font color="#007700">= &amp;new </font><font color="#0000bb">GtkButton</font><font color="#007700">(</font><font color="#dd0000">'Hello World!'</font><font color="#007700">);</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Vidíte, že příkaz je podobný jako příkaz pro inicializaci okna,
avšak přejímá jako parametr popisek nově vzniklého tlačítka. To je
příjemné, protože jinak by se popisek tlačítka musel nastavovat zvlášť
a kód by byl o to delší. Čili poznatek - některé widgety mohou při
inicializaci přejímat parametry, které upřesňují jejich vzhled či
chování. Pokud budete s PHPGTK pracovat delší dobu, jistě se u
některých widgetů naučíte význam předávaných parametrů z hlavy (bývá to
intuitivní).<br>
</p>
<p>Některé widgety mohou <span style="font-weight: bold;">obsahovat </span>jiné
widgety. Pokud to tak je, nazýváme tyto rodičovské widgety <span style="font-weight: bold;">kontejnery</span>.
Například widget GtkWindow smí obsahovat "dceřinné" widgety GtkButton a
je to tedy kontejner. Jinak řečeno tlačítko nebude v našem případě
existovat ve vzduchoprázdnu, ale bude na formuláři. Jenomže to počítač
zatím neví - hned to napravíme:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$window</font><font color="#007700">-&gt;</font><font color="#0000bb">add</font><font color="#007700">(</font><font color="#0000bb">$button</font><font color="#007700">);</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Od této chvíle je tedy náš nový čudlíček součástí našeho nového
okýnka. Je jasné, že jeden kontejner může obsahovat více dceřinných
prvků. Dokonce je to tak, že kontejner může obsahovat kontejner - ale
to už zabíháme do podrobností.<br>
</p>
<a name="000422"></a><h2>Signály</h2>
<p>Naší teorii ještě něco podstatného chybí. Tlačítko, jak je
definováno výše, totiž nic nedělá. Aby dělalo, je potřeba definovat, co
se má stát při vzniku <span style="font-style: italic;">signálů</span>.
Signálem je v PHPGTK míněna jakákoli myslitelná změna stavu objektu - u
tlačítka zmáčknutí, u okna třebas zavření, přetažení a podobně.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Naprostá většina widgetů
umí zachytávat více než jeden signál. Budete na to přicházet postupně
nebo to můžete nastudovat v manuálu.<br>
</span></p>
<p>Při výskytu signálů lze definovat, že se provede připravená PHP
funkce. Něco takového potřebujeme právě při klepnutí na naše tlačítko
$button:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$button</font><font color="#007700">-&gt;</font><font color="#0000bb">connect</font><font color="#007700">(</font><font color="#dd0000">'clicked'</font><font color="#007700">, </font><font color="#dd0000">'hello'</font><font color="#007700">);</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-style: italic;"></span></p>
<p>Od této chvíle tedy aplikace ví, že vždy, když zachytí signál
'clicked' od tlačítka $button, má zavolat PHP funkci hello. Tu musíme
napsat a můžeme v ní stisk tlačítka $button nějak ošetřit. Aby
nedocházelo k matení pojmů - platí, že:<br>
</p>
<ul>
  <li>název signálu (první parametr) musíme vybrat z těch, které daný
widget podporuje</li>
  <li>název funkce (druhý parametr) může být názvem libovolné dostupné
PHP funkce - vestavěné nebo (častěji) uživatelské<br>
  </li>
  <li>není povinné definovat zachycení všech signálů z daného widgetu.
Co nedefinujete, to bude aplikace ignorovat</li>
</ul>
<p style="font-style: italic;">Pozn.: Definovat tlačítko, které po
kliknutí nic neudělá je samozřejmě logický nesmysl, aplikaci by to však
nevadilo.<br>
</p>
<a name="000423"></a><h2>Zobrazení a uvolnění widgetu</h2>
<p>Teď už to můžeme celé zobrazit - což se děje pomocí metody show_all
widgetu $window:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$window</font><font color="#007700">-&gt;</font><font color="#0000bb">show_all</font><font color="#007700">();</font><font color="#0000bb"><br>
Gtk::main();<br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<p>A pokud má aplikace končit, zavírá okna a přerušuje spolupráci s
PHPGTK pomocí:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">$window</font><font color="#007700">-&gt;</font><font color="#0000bb">destroy</font><font color="#007700">();<br>
</font><font color="#0000bb">Gtk</font><font color="#007700">::</font><font color="#0000bb">main_quit</font><font color="#007700">();</font><font color="#0000bb"><br>
</font></font>
</code></div>
<!-- Zaza PHP kód END -->
<a name="000424"></a><h2>Závěr</h2>
<p>To byl jen hrubý nástin toho, jak pracuje PHPGTK (a vlastně celá
knihovna GTK). Cílem bylo pomoci čtenářům pochopit, co by se měli
naučit, jestliže chtějí s PHPGTK pracovat nějak soustavněji. Když se
naučíte používat standardní widgety a obsluhovat signály, máte napůl
vyhráno. Tady, stejně jako kdekoli jinde v programování platí, že cvik
dělá mistra - intenzivním používáním PHPGTK se můžete dostat do fáze,
kdy napíšete uživatelské rozhraní pro několik oken napoprvé bez mrknutí
oka. <br>
</p>
<p>Avšak pozor, žádné rozhraní není samospasitelné. Jestliže budou
události generované knihovnou PHPGTK mizeně obslouženy, ani to
nejkrásnější grafické uživatelské rozhraní nebude uživatelům přinšet
radost, ale jen utrpení. Pamatujte tedy na to, že pomocí PHPGTK lze
napsat dobré aplikace a špatné aplikace. Rozdíl je v kódu, kterým
budete obsluhovat signály.</p>
<a name="000425"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (96) - (ne)bezpečné PHP</h2>
			<p class="perex">Lze PHP považovat za bezpečnou záležitost? A pokud ano, co se pro to dá udělat?
				<br>
			</p>
			<p>Přestože jsme se určitým aspektům zabezpečení PHP věnovali průběžně,
budou celé následující dva díly seriálu věnovány bezpečnosti. Že je to
potřeba udělat, o tom mě přesvědčily komentáře čtenářů a spousta dotazů
jak od programátorů v PHP, tak od správců serverů. Dnes se podíváme na
víceméně na serverovou část problematiky. Tedy - co udělat, aby nám
provoz PHP na serveru nekompromitoval jeho bezpečnost. Budu se věnovat
jen věcem, které úzce souvisejí s PHP. Administrátoři webů mají
pochopitelně mnohem širší arzenál zbraní, protože mohou nastavovat
takové věci jako práva k souborům či webový server.<br>
</p>
<a name="000426"></a><h2>Žonglování se čtyřmi míčky<br>
</h2>
<p>Umíte žonglovat se čtyřmi míčky? (Já ne). Zabezpečit PHP se tomu
trochu podobá, protože do hry vstupují čtyři faktory, které se vzájemně
víceméně vylučují, a přitom všechny čtyři mají vliv na to, zda a jak
bude aplikace PHP zabezpečena. Uvědomme si, že se při úvaze o
bezpečnosti serveru se jedná o <span style="font-style: italic;">programátory
</span>v PHP, <span style="font-style: italic;">uživatele </span>našich
aplikací, <span style="font-style: italic;">administrátora </span>webu,
na kterém to
poběží a o případné <span style="font-style: italic;">útočníky</span>.<br>
</p>
<p><span style="font-weight: bold;">Programátor</span><br>
Programátor by si samozřejmě přál, aby PHP umělo co nejvíce věcí a aby
šly napsat rychle a snadno. Pro programátora je zajímavé, když mu někdo
s prací pomůže - použitím externí knihovny či funkce třetí strany může
nezřídka získat spoustu času na vývoj něčeho jiného (nebo na dohnání
časového plánu). Programátor chápe, že PHP se musí zabezpečit a má v
ruce některé velmi dobré nástroje, které mu v tom mohou pomoci. Někdy
však programátor vědomě či nevědomě zabezpečení aplikace podcení -
třeba když mu hoří časový plán, když nemá dost peněz na vývoj nebo když
si něčeho nevšimne.<br>
</p>
<p><span style="font-weight: bold;">Uživatel</span><br>
Uživatel by chtěl aplikaci co možná nejjednodušší. Běžný uživatel
problém bezpečnosti nevnímá příliš zblízka; bude jej obtěžovat, pokud
bude například přihlašování do aplikace příliš složité. Jestliže však
uživatel vinou nějaké bezpečnostní chyby přijde o data (nebo ještě lépe
- pokud přijde o peníze), začne si problém související s bezpečností
uvědomovat velmi palčivě. Takový zákazník je potencálně velmi zajímavý
- není pak pro něj problém pochopit, že psaní kvalitních a bezpečných
aplikací je drahé, ale nezbytné.<br>
</p>
<p><span style="font-weight: bold;">Administrátor</span><br>
Typický správce se samozřejmě nastará pouze o samotné PHP, stará se o
celý stroj nebo o více strojů a jeho prvotním zájmem je, aby systém
neměl pokud možno žádné bezpečnostní slabiny jako celek. Samozřejmě, že
ruku v ruce s tím jde druhý, protichůdný požadavek - aby zabezpečení
webu mohl nějak automatizovat a aby mu to nezabralo příliš mnoho času.
Administrátor si uvědomuje, že úšpěšný útok na jeho server by mohl
poškodit nejen data konkrétního uživatele, ale rovněž pověst firmy, pro
kterou pracuje, nebo jeho vlastní renomé.<br>
</p>
<p><span style="font-style: italic;">Pozn.: A taky je to jenom člověk. </span><br>
</p>
<p></p>
<p><span style="font-weight: bold;">Útočník</span><br>
Typický útok na webové sídlo nebude pravděpodobně veden touhou
zlikvidovat konkrétního uživatele. Útočník si může vybrat pro svou
nekalou činnost weby, u nichž najde nějakou bezpečnostní slabinu nebo
weby, jejichž prolomením si získá jméno. Líbilo by se mu, kdyby
existovala bezpečnostní díra, pomocí níž by se mohl do systému dostat -
a jako jediný z těch čtyř má na své straně čas.<br>
</p>
<p>Přestože asi nebudete chtít vycházet vstříc útočníkům, vidíte, že i
ostatní tři strany mají víceméně odlišné priority. Správné zabezpečení
PHP je tedy určitý kompromis - mazi možností něco napsat, něco používat
a rovněž to spravovat. Jak ale uvidíme, lze pro zabezpečení PHP přece
jen něco udělat.<br>
</p>
<p> </p>
<a name="000427"></a><h2>Verze PHP</h2>
<p>V době psaní tohoto článku byla stabilní verzí PHP 4.3.10.
Administrátor pravděpodobně bude mít pádný důvod instalovat na server
nejnovější stabilní verzi PHP, protože právě objevení bezpečnostích děr
bývá častým důvodem k vydání nové verze jazyka. Obecně toto tvrzení
platí i pro jiné součásti systému. Nebývá to však vždy tak jednoduché,
jak by se mohlo na první pohled zdát; tak například dvě nejnovější
verze nějakého software spolu nemusejí správně spolupracovat, přestože
předchozí dvě verze s tím neměly žádný problém.<br>
</p>
<p>Rovněž tak bývá problém najít administrátora, ochotného instalovat a
spravovat úplně nejnovější zveřejněnou verzi software (v případě PHP je
to v době psaní tohoto článku verze 5.0.3. Důvodem je to, že v
nejnovějších verzích se mohou vyskytovat chyby.<br>
</p>
<p></p>
<a name="000428"></a><h2>Zakázané funkce</h2>
<p>Administrátor může rovněž některé funkce v PHP zakázat. Pro zvídavé
- děje se tak pomocí konfigurační direktivy disable_functions v souboru
php.ini. Typickými kandidáty na takové funkce jsou například funkce pro
vykonání příkazů operačního systému a funkce na správu konfigurace (system,
exec, passthru, leak, Set_Time_Limit, copy, delete, popen, PutEnv,
shell_exec a podobně). Konfigurační direktivu disable_functions lze
použít pouze v php.ini, nelze ji tedy specifikovat ani uvnitř skriptu,
ani pro danou složku.<br>
</p>
<p>Význam zákazu některých funkcí je jasný - zabránit skriptům v
provedení akcí, které by neměly umět. <br>
</p>
<p></p>
<a name="000429"></a><h2>Safe_mode</h2>
<p>Safe mode, neboli bezpečný režim je pokus o zabezpečení PHP (zejména
na sdílených hostinzích) prostředky, které má PHP k dispozici.
Filozofie je to diskutabilní, protože se pokouší pomocí jednoho <span style="font-style: italic;">programu </span>(PHP) ovlivnit bezpečnost
<span style="font-style: italic;">systému</span>. Takže, například,
někdo může získat falešný pocit, že zapnutím zabezpečeného režimu PHP
má na serveru po starostech - tak to samozřejmě není. Konkrétní význam
bezpečného režimu je spíše otázka pro administrátory - my se teď pojďme
podívat, jaká omezní v případě tohoto režimu nastupují:<br>
</p>
<ol>
  <li>Existují <a href="http://cz.php.net/manual/cs/features.safe-mode.php#features.safe-mode.functions">omezené
funkce</a> nebo funkce, které se provedou jen v určitém případě</li>
  <li>Bez ohledu na nastavení konfigurační direktivy disable_fuctions
jsou zakázány funkce dl a shell_exec</li>
  <li>Funkce exec, system, passtrhu a popen jsou omezeny na ty
programy, které existují ve stanoveném adresáři. Stanovený adresář je
adresář, definovaný konfigurační direktivou safe_mode_exec_dir.</li>
  <li>Funkce pro práci se soubory (jako jsou copy, rename, unlink
apod.) kontrolují, zda soubory (adresáře), které se pokoušíte měnit,
mají stejného vlastníka jako spouštěný skript.</li>
</ol>
<p>Pakliže mám chvíli mluvit jako programátor - někdy je zabezpečený
režim zkutečně k vzteku. Tak například typický scénář je ten, že
skripty nahráváte na webový server pomocí protokolu FTP. Snadno se tedy
může stát, že vlastníkem skriptů je na serveru někdo jiný než vlastník
souborů, které skripty vytváří nebo které mají měnit. Všechny operace
se soubory je v takovém případě třeba otestoavat kvůli právům.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Jiné dobré řešení je
provádět co možná nejvíce operací samotnými skripty a co možná nejméně
pomocí FTP. I upload souboru může být proveden skriptem a odpadají tak
problémy s právy.<br>
</span></p>
<p>Příště se podíváme na bezpečnost&nbsp; souborů, databází, hesel a
uživatelských dat. </p>
<a name="000430"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (97) - bezpečnost ještě jednou</h2>
			<p class="perex">Jak lze bezpečně pracovat se soubory, databázemi a hesly. Také se dozvíte, jak spolu souvisí PHP a kočka domácí.
				<br>
			</p>
			<p>Dnes se podíváme na konkrétní záležitosti kolem PHP, které se týkají
zabezpečení a které se více či méně dají ovlivnit programátorsky.
Protože jsme se některých těchto témat již na různých místech seriálu
dotkli, budou zde rovněž
odkazy do předchozích článků.</p>
<a name="000431"></a><h2>Bezpečnost souborů</h2>
<p>Jelikož je PHP většinou provozováno na serveru s kvalitně
nastavenými právy k souborům, není toto téma tak palčivé, jak by mohlo
být. To však neznamená, že byste mu neměli věnovat pozornost! Čas od
času bývá potřeba pomocí PHP přečíst, odstranit nebo změnit soubor
operačního systému hostitelského počítače. V takovém případě musíte být
opatrní, aby skript pro modifikaci <span style="font-style: italic;">dělal
</span>skutečně to, co má, a aby
dělal <span style="font-style: italic;">jen </span>to, co má. Mějme
například následující skript pro vypsání
obsahu souboru do prohlížeče:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
$soubor</font><font color="#007700">=</font><font color="#0000bb">fopen</font><font color="#007700">(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"file"</font><font color="#007700">], </font><font color="#dd0000">"r"</font><font color="#007700">); <br>
&nbsp;&nbsp;</font><font color="#0000bb">$obsah</font><font color="#007700">=</font><font color="#0000bb">fread</font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">, </font><font color="#0000bb">50000</font><font color="#007700">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;pre&gt;"</font><font color="#007700">.</font><font color="#0000bb">$obsah</font><font color="#007700">.</font><font color="#dd0000">"&lt;/pre&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">fclose </font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">);</font><br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Tento skript je potenciálně velmi nebezpečný, protože vůbec
neověřuje, co se vlastně pokoušíme vypsat. Takže namísto nevinného
volání ve stylu </p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">http://www.linuxsoft.cz/source.php?file=[název
souboru]</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>by útočník mohl napsat něco jako:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000">http://www.linuxsoft.cz/source.php?file=/etc/passwd</font>
</code></div>
<!-- Zaza PHP kód END -->
<p>Způsobů, jak tomu zabránit je několik. Programátor by nikdy neměl
dát případnému útočníkovi do ruky takovouto zbraň, proto můžeme
dejme tomu omezit možnost vypsání souborů na soubory ve stejné složce,
jakou má obslužný skript:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#007700">if (</font><font color="#0000bb">eregi</font><font color="#007700">(</font><font color="#dd0000">"[\/~]"</font><font color="#007700">, </font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"file"</font><font color="#007700">])) die();<br>
&nbsp;&nbsp;</font><font color="#0000bb">$soubor</font><font color="#007700">=</font><font color="#0000bb">fopen</font><font color="#007700">(</font><font color="#0000bb">$_GET</font><font color="#007700">[</font><font color="#dd0000">"file"</font><font color="#007700">], </font><font color="#dd0000">"r"</font><font color="#007700">); <br>
&nbsp;&nbsp;</font><font color="#0000bb">$obsah</font><font color="#007700">=</font><font color="#0000bb">fread</font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">, </font><font color="#0000bb">50000</font><font color="#007700">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;echo </font><font color="#dd0000">"&lt;pre&gt;"</font><font color="#007700">.</font><font color="#0000bb">$obsah</font><font color="#007700">.</font><font color="#dd0000">"&lt;/pre&gt;"</font><font color="#007700">;<br>
&nbsp;&nbsp;</font><font color="#0000bb">fclose </font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">);</font><br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Můžeme rovněž kontrolovat příponu souboru, který se má zobrazovat,
jeho práva, velikost, typ a podobně. Rovněž je žádoucí veškeré případné
změny v souborech (jako je tvorba souborů, změna obsahu nebo mazání)
protokolovat.<br>
</p>
<a name="000432"></a><h2>Bezpečnost databází</h2>
<p>Jednotlivé databáze mají své bezpečnostní mechanizmy. K tomu patří
ověřování uživatelů, práva k tabulkám a procedurám a podobné věci. O
bezpečnosti databáze MySQL jsme v tomto seriálu již <a href="#000191">mluvili</a>.
Obecně je téma "PHP, databáze a bezpečnost" velmi široké, takže si
nejprve pojďme říci, co všechno tím můžeme mínit. Může se jednat o:<br>
</p>
<ul>
  <li>zabezpečení dat v databázi proti zneužití</li>
  <li>zabezpečování přihlašovacích informací</li>
  <li>zabezpečení komunikace mezi PHP a MySQL</li>
  <li>zabezpečení dotazů proti SQL-injection</li>
  <li>a další...</li>
</ul>
<p>V současné době, která by se dala označit jako věk databází
pochopitelně význam uvedených faktorů vzrůstá. Skutečnost je taková, že
100% zabezpečení internetové databáze není možné, a proto bude třeba
zvážit, jaké informace se v databázích na internetu mají uchovávat.
Znám skutečně společnosti, které ze svých internetových databází
pravidelně "odčerpávají" data do lokálních, lépe ochránitelných systémů.<br>
</p>
<p>Tak například pokud internetová stránka obsahuje nějaké připojovací
údaje k databázi, prakticky vždy jsou tyto údaje uloženy v PHP
skriptech. Pokud by útočník zjistil tyto údaje za skriptu, mohl by se
zcela jednoduše připojit k databázi. Proti tomu neexistuje spolehlivá
ochrana - snad jen uložit připojovací informace do konfiguračních
souborů webového serveru (Apache to umožňuje).<br>
</p>
<p>SQL injection je technika, která útočníkovi umožní "vpašovat" do
příkazu SQL pro databázi kód, který tam původně nebyl. Řešením je NIKDY
nepoužívat uživatelem zadaná data jako přímou součást databázových
operací. Namísto toho je velmi žádoucí všechna data ověřit, pospojovat
a odeslat do databáze až v momentě, kdy máme jistotu, že nemohou
obsahovat něco, co jsme nečekali. Můžeme tedy testovat, zda celé číslo
je opravdu celé, zda datum představuje platné datum a zda jsme všechny
potenciálně nebezpečné znaky řádně oescapovali.<br>
</p>
<a name="000433"></a><h2>Hesla ve skriptech</h2>
<p>Kromě připojovacích údajů do databáze může obsahovat skript celou
řadu dalších citlivých údajů. Můžeme mít například následující fragment
kódu:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#007700">if (</font><font color="#0000bb">$password</font><font color="#007700">==</font><font color="#dd0000">'administrátorské heslo'</font><font color="#007700">) </font><font color="#0000bb">$admin</font><font color="#007700">=</font><font color="#0000bb">TRUE</font><font color="#007700">; else </font><font color="#0000bb">$admin</font><font color="#007700">=</font><font color="#0000bb">FALSE</font><font color="#007700">;<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$admin</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//atd...<br>
&nbsp;&nbsp;</font><font color="#007700">}</font><br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Tento kód sám o sobě samozřejmě žádný problém nepředstavuje;
nepříjemné však je to, že kdokoli si skript přečte, bude naše heslo
znát (může se jednat třeba o správce webu). Přitom bychom nemuseli
porovnávat samotné heslo, ale jeho hash:<br>
</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&nbsp;
</font><font color="#007700">if (</font><font color="#0000bb">md5</font><font color="#007700">(</font><font color="#0000bb">$password</font><font color="#007700">)==</font><font color="#dd0000">'9075965146cba1da21ed431d8c9c15b5'</font><font color="#007700">) </font><font color="#0000bb">$admin</font><font color="#007700">=</font><font color="#0000bb">TRUE</font><font color="#007700">; else </font><font color="#0000bb">$admin</font><font color="#007700">=</font><font color="#0000bb">FALSE</font><font color="#007700">;<br>
&nbsp;&nbsp;if (</font><font color="#0000bb">$admin</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">//atd...<br>
&nbsp;&nbsp;</font><font color="#007700">}</font><br>
</font></code></div>
<!-- Zaza PHP kód END -->
<p>Protože je funkce md5() jednosměrná, neexistuje žádný způsob, jak z
ní vyluštit původní heslo a je tedy dobrou ochranou před nenechavými
zraky.<br>
</p>
<a name="000434"></a><h2>Data od uživatelů</h2>
<p>Jakákoli data od uživatelů je třeba kontrolovat, kontrolovat a
kontrolovat. Byla&nbsp; tom řeč průběžně, například v díle o <a href="#000105">formulářích</a>,
nebo v díle o <a href="#000351">zpracování
prvků TEXTAREA</a> na cvičném portálu. Uvědomme si, že chybná data
mohou přijít z nejrůznějších důvodů - může se jednat o omyl, útok na
webové stránky, nebo o kočku domácí líně se rozvalující na klávesnici
zapnutého PC.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Ten poslední příklad byl z </span><a style="font-style: italic;" href="http://cz.php.net/manual/cs/security.index.php#security.general">manuálu
o PHP</a><span style="font-style: italic;">! Ověřoval jsem to
experimentálně na svém řádně medializovaném domácím mazlíčku (<a href="./examples/48_show.jpeg">obrázek</a>
z dílu o <a href="#000206">ukládání
binárních dat</a> do databází) a bylo zjištěno toto: Naše Líza se při
rozvalování na klávesnici nepokouší rozbít bezpečnostní model PHP, ale
klávesnici samotnou. Jde přitom o tzv. brute-force attack (útok hrubou
silou), při němž se útočník pokouší přežvýkat přívodní kabel ke
klávesnici. Jak ta mrcha rozpozdá datový kabel od napěťového, to
skutečně nevím.</span><br>
</p>
<a name="000435"></a><h2>Register globals</h2>
<p>Jak a proč zakázat registraci globálních proměnných jsme již
probírali v díle o <a href="#000397">nastavení PHP</a>.
Ne snad, že by zapnutí či vypnutí této volby udělalo z PHP bezpečnou
aplikaci, ale je dobré vědět jak celý mechanismus funguje a jaké je s
tím spojeno nebezpečí.<br>
</p>
<a name="000436"></a><h2>Závěr</h2>
<p>Nedotkli jsme se všech aspektů zabezpečení PHP. Jak si můžete
přečíst v nabídkách <a href="http://www.linuxsoft.cz/kurzy/">kurzů</a>,
které Linuxsoft pořádá, je nastavení PHP na serveru rovněž jedním z
témat, která se přednášejí. Psaní bezpečných aplikací v PHP je vždy
balancování na ostří nože - mezi použitelností a zabezpečením. Je to
hledání kompromisu - stejně jako v mnoha jiných oblastech programování.
A to je na tom to hezké, ne?</p>
<a name="000437"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (98) - PHP 5.</h2>
			<p class="perex">Jaká je PHP 5? Vyplatí se přejít na ni co nejdříve?
				<br>
			</p>
			<p>Před nedávnem oficiálně vyšla verze PHP 5. Co nového nás v ní čeká?
A je potřeba udělat přechod z "čtyřkové" verze na "pětkovou" co
nejdříve?</p>
<a name="000438"></a><h2>Historie verzí PHP<br>
</h2>
<p>Jak prochází PHP vývojem, objevují se nové verze. Číslo hlavní verze
jazyka však zatím bylo změněno pouze čtyřikrát. Připomeňme si, že PHP 1
(i když se to vlastě jmenovalo PHP/FI, personal home page/form
interpreter) vyšlo již v roce 1995. Verze PHP 2 byla uvolněna v
listopadu 1997 a zaznamenala už výraznější úspěch. V červnu 1998 byla
potom uvolněna verze PHP 3.0, která způsobila onen boom okolo používání
PHP.&nbsp; V této souvislosti stojí za zmínku, že PHP 3.0 bylo
modulární a daly
se k němu "připisovat" například knihovny pro připojení databází. Možná
právě to způsobilo, že se "trojkové" verze PHP tak rozšířily.<br>
</p>
<p>Nicméně, stále se pohybujeme v roce 1998, takže v době, kdy byl psán
tento článek, již uběhlo od vydání "trojky" více než 6 let. Zjistilo se
například, že moduly jsou hezká věc, ale v kombinaci s více uživateli
jednoho stroje s PHP se celé zpracování požadavků dosti výrazně
zpomaluje. Proto byla v květnu roku 2000 uvolněna úplně nová verze PHP
(4.0), která obsahovala zcela přepracované a tudíž rychlejší jádro
Zend.
<br>
</p>
<p style="font-style: italic;">Pozn.: Pokud by to někoho zajímalo -
bylo toho dosaženo změnou filozofie zpracování souboru. PHP 3
zpracovávalo zdrojový kód sekvenčně, PHP 4 jej celý zkompiluje a pak
spustí. Čím je skript delší a složitější, tím je nárůst výkonu mezi
PHP4 a PHP3 výraznější.</p>
<p>Když už jsme se ponořili do historie, vybírám namátkou některé
podstatnější změny, které přineslo PHP 4:<br>
</p>
<ul>
  <li><a href="#000228">sessions</a></li>
  <li><a href="#000322">buffering
výstupu</a></li>
  <li><a href="#000024">datový
typ boolean</a></li>
  <li><a href="#000074">konstrukce
foreach</a></li>
  <li>podpora COM objektů (v seriálu jsme nezmiňovali, týká se jen
Windows)</li>
  <li>podpora spolupráce s jazykem Java (rovněž jsme nezmiňovali)<br>
  </li>
  <li>syntaxi "here-doc" (v seriálu jsme ji nezmiňovali)</li>
</ul>
<p>Většina těchto změn byla přijata kladně komunita vývojářů je začala
okamžitě používat. Například sessions se staly nedílnou součástí mnoha
dnešních aplikací. Podívejme se nyní na změny, které přineslo PHP 5,
vydané oficiálně v polovině roku 2004.<br>
</p>
<a name="000439"></a><h2>PHP 5</h2>
<p>PHP 5 přineslo celou řadu změn a vylepšení. Některá podstatnější
uvádím níže.<br>
</p>
<p><span style="font-weight: bold;">Vylepšené jádro zend-engine II</span><br>
Toto jádro obsahuje spoustu nových funkcí, zejména pokud se jedná o
práci s objekty. Zvídaví uživatelé se mohou podívat na stránky projektu
ZEND, kde se dozvědí <a href="http://www.zend.com/php5/articles/engine2-php5-changes.php">detaily</a>.
<br>
</p>
<p><span style="font-weight: bold;">Nové vlastnosti objektů</span><br>
Pokud chcete v PHP pracovat s objekty (nebo, pokud jste to chtěli již
dávno, ale zjistili jste, že to u náročnějších aplikací není skoro
vůbec možné), PHP5 vám přináší mnoho nových vlastností. Můžete používat
privátní, chráněné a veřejné proměnné, zlepšené je použití konstruktorů
a destruktorů. Je zavedena podpora interface a abstraktních tříd.<br>
</p>
<p><span style="font-weight: bold;">Vylepšená práce s chybami</span><br>
Moderní programovací jazyky mají tzv. strukturovanou správu chyb. PHP5
nabízí sice odlehčenou, přesto však strukturovanou správu chyb pomocí
třídy Exception. Existují bloky try {} a catch {} (nikoli však
finaly{}).<br>
</p>
<p></p>
<p><span style="font-weight: bold;">Kompletně přepsaná podpora XML</span><br>
To je jedna z nejlepších zpráv kolem nové verze. PHP 5 spolupracuje s
knihovnou <a href="http://www.xmlsoft.org/">libxml2</a> (vyvinutou
původně pro Gnome) a navíc přináší rozhraní SimpleXML. Simple XML je
rozhraní pro zpracování dokumentů XML, které načte informace z XML
dokumentu do hierarchicky uspořádaných objektů, což je jak rychlé na
napsání, tak rychlé na pochopení. (<a href="http://www.zend.com/php5/articles/php5-simplexml.php">Zde</a> je
příklad).<br>
</p>
<p><span style="font-weight: bold;">Sada pro připojení MySQL 4.1</span><br>
Pro připojení k MySQL 4.1 bylo vyvinuto v PHP 5 rozhraní mysqli. Je to
rozhraní objektové, takže napříště budete moci psát skripty pro
připojení k MySQL databázi objektově. (To samozřejmě můžete už teď
pomocí vlastních tříd nebo tříd z knihoven třetích stran).<br>
</p>
<p style="font-style: italic;">Pozn.: Tato vlastnost jazyka PHP je v
současné době době považována za hodně kontroverzní. Za všechny
nepokojené uvádím například následující <a href="http://hulan.info/blog/item/nemam-rad-php-mysql-4-0-versus-4-1/category/apache-php">úvahu</a>.<br>
</p>
<p><span style="font-weight: bold;">Zabudovaná podpora SQLite</span><br>
PHP 5 má zabudovanou podporu SQLite. SQLite je velmi skromný (co do
nároků na systém) databázový engine používající pro celou databázi
jeden soubor. Není to tedy databázový server ve stylu např. MySQL, ale
na jednodušší úlohy je velmi svižný a ve webových aplikacích si jistě
najde své místo. Více o SQLite se dozvíte na <a href="http://www.sqlite.org/">stránkách projektu</a>.<br>
</p>
<p><span style="font-weight: bold;">Iconv</span><br>
Hurá! Funkce pro konverzi znakových sad jsou součástí PHP5 interně,
takže se nebudou muset instalovat a konfigurovat zvlášť.<br>
</p>
<p></p>
<a name="000440"></a><h2>Upgradovat ?</h2>
<p>Vydání nové verze PHP vždy přináší otázku: upgradovat, či ne? A jak
brzy? Na produkčních serverech tuto otázku samozřejmě budou řešit
nejspíše administrátoři. Pro programátory je dobré vědět, že existují
freehostingové projekty (například <a href="http://www.php5.cz/">www.php5.cz</a>),
kde si mohou své aplikace běžící v PHP5 vyzkoušet. <br>
</p>
<p>Bohužel se nepodařilo zachovat zpětnou kompatibilitu mezi PHP4 a
PHP5 ze sta procent. Znamená to, že přinejmenším některé skripty bude
třeba před jejich nasazením na PHP5 přepsat. Budou to typicky skripty
pracující s databází či skripty využívající zpracování XML pomocí DOM.<br>
</p>
<p>To, jaký význam bude mít PHP5 na komunitu kolem vývoje webu je ještě
obtížné s určitostí předpovědět. My se v dalším díle seriálu zaměříme
na obecnější úvahu - jaká bude úloha PHP v budoucnu a nakolik se touto
technologií vyplatí zabývat.<br>
</p>
<a name="000441"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (99) - Budoucnost PHP</h2>
			<p class="perex">Lehké mudrování o tom, co se stane s PHP v blíže neurčené budoucnosti, aneb "mám se to tedy učit?"
				<br>
			</p>
			<p>Dnes se zamyslíme nad tím, jaké perspektivy nejspíše čekají jazyk
PHP a jaká budoucnost čeká ty, kdo tento jazyk ovládají. Nejsem
samozřejmě věštec, ale mnohé se dá vyčíst ze směru, jakým se tento
jazyk a komunita kolem něj v posledních několika letech vyvíjí.<br>
</p>
<p><span style="font-weight: bold;"></span></p>
<a name="000442"></a><h2>Směřování PHP</h2>
<p>Zejména v souvislosti s vydáním "pětkové" verze PHP je na webu k
dispozici mnoho článků, které se tak či onak zabývají směřováním PHP do
budoucna. Je to logické; vydání nové hlavní verze čehokoli,
programovací jazyk nevyjímaje, udává jasně směr, kterým se daná věc
bude ubírat. Pojďme si pro zpestření poukázat na některá zajímavější
místa na webu, která se tím zabývají nebo zabývala. Pokud si budete
články číst, doporučuji podívat se i na diskuse pod nimi. Mnohdy jsou
protichůdné a mnohdy jsou velmi zajímavé.<br>
</p>
<ul>
  <li>interval.cz - <a href="http://interval.cz/clanek.asp?article=3752">Vývoj PHP - cesta
správným směrem?</a></li>
  <li>zend.com - <a href="http://www.zend.com/php5/whats-new.php">Stránky
jádra a co je nového v PHP 5</a></li>
  <li>živě.cz - <a href="http://www.zive.cz/h/Programovani/AR.asp?ARI=121292">Budoucnost
PHP</a></li>
</ul>
<p style="font-style: italic;">Pozn.: Jste-li milovníky historie,
můžete na internetu najít i články z doby, kdy se filozofovalo o
přechodu z PHP 3 na PHP 4. Uvidíte z toho dvě věci: 1) Mnoho argumentů
se vyřeší "samo" tím, že se nová verze používá, a 2) Diskuse kolem
přechodu PHP4-&gt;PHP5 jsou mnohem vášnivější, než byly diskuse u
přechodu z PHP3 na PHP4.<br>
</p>
<p>Při tom humbuku kolem PHP 5 bychom ale neměli zapomínat na jednu
věc: PHP se bude vyvíjet dál. Podpora dalších technologií se bude
zlepšovat (třeba XML, SOAP), možnosti jazyka se budou rozšiřovat
(strukturovaná správa výjimek, objekty) a jádro ZEND se asi bude rovněž
zrychlovat.<br>
</p>
<p>V té záplavě informací o budoucnosti PHP bych si dovolil být
optimistou. PHP 5 samozřejmě nemá všechny vlastnosti, po nichž vývojáři
volali, ale některé má. Jiné se připravují. Další osud PHP bych
rozhodně neviděl černě. Komunita kolem něj je obrovská a existují
životaschopné projekty psané v PHP, které hned tak nezaniknou.<br>
</p>
<p>Jiná otázka je, zda se PHP "vypracuje" na jazyk, v němž bude možné
vyvíjet i ty největší internetové aplikace. To si netroufám odhadnout;
v očích mnoha odborníků je totiž PHP dodnes považováno za záležitost
pro "malé až střední" projekty. Už sama definice toho, co to je "malý
až střední" projekt je samozřejmě obtížná. Nicméně, úměrně tomu, jak se
budou v PHP zlepšovat podmínky pro práci s objekty, budou se i zvyšovat
jeho možnosti pro nasazení na "velkých" věcech.<br>
</p>
<p><span style="font-style: italic;">Pozn.: To je logické. Každý velký
projekt totiž skončí u objektů, protože procedurální programování
nemůže nabídnout takový stupeň znovupoužitelnosti kódu a flexibility,
jaký je pro vývoj mamutích aplikací potřeba.</span><br>
</p>
<p> </p>
<a name="000443"></a><h2>Alternativy k PHP</h2>
<p>Abychom pochopili, jaké má PHP vyhlídky, můžeme se rovněž krátce
zamyslet nad jeho alternativami. Pro vývoj webu to může být například
Perl nebo Python. Oba tyto jazyky jsou v mnoha ohledech dále než
samotné PHP (ve zmiňovaných objektech, například). Problémem je však
jejich nízká rozšířenost na komerčních hostinzích. Dostáváme se tak
vlastně do bludného kruhu.<br>
</p>
<p>Pro provoz aplikací na platformě Windows se kdysi používal jazyk ASP
(active server pages). Vypadá to, že byl s nástupem PHP zatlačen
poněkud do pozadí, navíc není přenositelný na jiný server a musí běžet
na Microsoft Internet Information serveru, tedy na Windows.<br>
</p>
<p>Nejvážnějšími konkurenty pro PHP se pak stávají "zbraně těžkého
kalibru", jako je platforma .NET (se svým ASP.NET) či Java. V jistém
smyslu o nějakém srovnávání nemůže být ani řeč, protože jak .NET, tak
Java jsou skutečně <span style="font-style: italic;">platformy</span>,
kdežto PHP je "jen" <span style="font-style: italic;">jazyk</span>.
Domnívám se, že PHP nikdy nebude tak silné, aby mohlo konkurovat
například Javě - a myslím, že by se o to PHP ani nemělo snažit.<br>
</p>
<a name="000444"></a><h2>Trendy ve tvorbě webu</h2>
<p>Jestliže uvažujeme o PHP, měli bychom rovněž přihlédnout k obecným
trendům ve tvorbě webu, protože tam se PHP uplatňuje nejčastěji.
(Konečně už) je pryč doba, kdy "letěly" weby přeplácané, nadupané
grafikou a animacemi a weby s pramalou informační hodnotou. Význam
získávají weby jednoduché na orientaci, přehledné, čtivé. PHP samo o
sobě samozřejmě můžete použít jak ke tvorbě webu hezkého a čtivého, tak
i ke spáchání webdesignérského paskvilu prvního stupně.<br>
</p>
<p>Ale o to nejde. Zdá se totiž, že na popularitě získávají
"předpřipravená" řešení typu různých CMS (content managemet systems,
systémů pro správu obsahu). Není divu, tyto systémy mají mnoho výhod -
od tolik potřebné možnosti oddělit obsah webu od jeho formy, přes
možnost práce více uživatelů na obsahu, centrální správu, až třeba po
rychlost, s jakou mohou tato řešení být nasazena do praxe.<br>
</p>
<p style="font-style: italic;">Pozn.: Můžete se přesvědčit sami, o CMS
máme totiž na Linuxsoftu <a href="http://www.linuxsoft.cz/article_list.php?id_kategory=218">seriál</a>.<br>
</p>
<p>A právě - naprostá většina alespoň těch nejznámějších redakčních
systémů je napsaná v PHP. Zdá se, že to je přesně segment, v němž PHP
plní svou úlohu velmi dobře - a že to je oblast, v níž se síly a
kvalita tohoto jazyka budou i nadále projevovat. PHP tedy budete moci
použít jak pro <span style="font-style: italic;">napsání </span>takového
software, tak i pro jeho uživatelské <span style="font-style: italic;">úpravy
</span>(pokud vám to umožní příslušná licence). <br>
</p>
<p> </p>
<a name="000445"></a><h2>Kolik jazyků umíš...</h2>
<p>... tolikrát jsi člověkem. Tohle v oblasti počítačů neplatí. Každý
jazyk je totiž primárně určen na něco jiného, má své silné a slabé
stránky a při jeho používání se stanete "mistrem" až za nějakou dobu.
Jestliže budete chtít kromě PHP umět i jiné programovací jazyky, nebo
jestliže se kromě jiných programovacích jazyků budete chtít naučit PHP,
možná vezmete zavděk nísledující postřehy:<br>
</p>
<ul>
  <li>Čím bližší je syntaxe jazyků, které ovládáte, ním spíše si je
budete plést.</li>
  <li>Schopnost algoritmizace úloh (tedy to, jak převést přání
zákazníka do řeči počítače) nezávisí primárně na zvládnutí žádného
jazyka (píšete-li špatně programy v PHP, budete je psát špatně i v
čemkoli jiném)</li>
  <li>Vlastnosti jazyka vás mohou svazovat nebo vám mohou dávat svobodu
(třeba v případě PHP je to jeho netypovost, která vám určitou svobodu
dává). Vždy za to ale zaplatíte - za svobodu například lepší "možností"
udělat chybu, poklesem výkonu či nepřehledností.</li>
  <li>Nemyslím si, že lze být "dobrý" ve více programovacích jazycích.
Stejně jako člověk má jen jednu mateřštinu, bude se vám pravděpodobně v
některém jazyce programovat lépe, v jiném hůře. Nemusí to být vina
jazyka a nemusí platit, že nejlépe se budete "cítit" v tom, co jste se
naučili jako první nebo v tom, co používáte nejčastěji.</li>
  <li>Neexistují "vysloveně dobré" a "vysloveně špatné" programovací
jazyky, alespoň ne v obecné rovině. Existují ale "vysloveně dobří" a
"vysloveně špatní" programátoři. Bez ohledu na jazyk, v němž píší.<br>
  </li>
</ul>
<p>Pakliže jste se naučili PHP, a chtěli byste pokračovat nějakým
"vyšším" programovacím jazykem, máte v podstatě dvě možnosti: "céčko"
nebo Javu. Rozebírat výhody a nevýhody těchto jazyků nebo je srovnávat
je již nad rámec naší úvahy; každopádně vás možná potěší, že oba jazyky
mají s PHP trochu společné syntaxe. Mám tím na mysli to, že některé
části kódu psané v Javě nebo C byste tedy mohli pochopit pomocí
znalostí, které máte z PHP.<br>
</p>
<a name="000446"></a><hr><h2><img src="./img/sipka1.png" alt="&gt;" height="15" width="15"> PHP (100) - Závěr</h2>
			<p class="perex">Jednou to přijít muselo, takže to zkrátím: tenhle díl seriálu o PHP je poslední.
				<br>
			</p>
			<p>Je to neuvěřitelné, co? Ale náš stodílný seriál je u konce. Pojďme
jej uzavřít krátkým ohlédnutím, podívat se ta to, co se povedlo a
nepovedlo a zodpovědět hromadně některé neustále se opakující dotazy s
tímto seriálem související.
<br>
</p>
<a name="000447"></a><h2>Co se povedlo</h2>
<p>Začněme optimisticky. Především, jsem rád, že se vůbec povedlo
takový seriál napsat, sestavit a publikovat. Protože záměrem redakce
bylo poskytnout všude tam, kde jen to je možné funkční a spustitelné
příklady, je u mnoha dílů možnost si předložené skripty buďto stáhnout,
nebo přímo spustit na našem serveru (u kolika jiných obdobných seriálů
máte tuto možnost)? U všech skriptů je rovněž k dispozici barevné
zvýraznění syntaxe.<br>
</p>
<p>Z některých článků mám velkou radost. Byl jsem například příjemně
překvapen, kolik kladných reakcí dorazilo na díl popisující <a href="#000240">přímou
tvorbu PDF pomocí PHP</a>. Vím o serverech, které díky těmto
informacím vyřešily letitý problém s tvorbou tiskových sestav z
firemního webu. Přivítám byl rovněž díl seriálu popisující <a href="#000351">zabezpečení
vstupu formulářů</a> a mnoho chvály si získal nápad publikovat "větší"
příklad s postupnými řešeními během více dílů; to byl ten náš
hypotetický server hudební skupiny.<br>
</p>
<p><span style="font-style: italic;">Pozn.: Někteří ocenili také fakt,
že jsme jako příklad NEPOUŽILI elektronický obchod, protože to dělá
každý. Skutečně je to velmi otřepané.<br>
</span></p>
<a name="000448"></a><h2>Co se nepovedlo</h2>
<p>Abych se jen nechválil - některé věci se rovněž nepovedly. Například
v šuplíku zůstal díl seriálu o spolupráci mezi PHP a LDAP serverem;
jelikož jsem nenašel jediný funkční veřejný LDAP server, k němuž by
se dalo pomocí PHP připojit, přišlo mi to celé poněkud málo
inspirující. Pod
Linuxem se mi rovněž nepovedlo rozchodit žádný smysluplný PHP debugger,
který
by byl k dispozici jako svobodný software.<br>
</p>
<p>Nepovedlo se mi dát dohromady vlastní texty týkající se spolupráce
PHP a knihovny GD. Musel bych opsat text z nějaké knížky (např. Jiří
Kosek - Tvorba interaktivních internetových aplikací). (Opisování je
samozřejmě nefér). Některé články se mi nepovedlo sestylizovat tak
záživně, jak by se to dalo udělat. Snažil jsem se, aby příklady v
článcích byly použitelné v praxi; nakolik se mi to povedlo nebo
nepovedlo, to nechám na zvážení laskavému čtenáři.<br>
</p>
<p> </p>
<a name="000449"></a><h2>FAQ</h2>
<p>Uživatelé se mě e-mailem nebo prostřednictvím diskusí pravidelně
ptají na některé otázky. Rád bych toho teď využil a zodpověděl některé
všem najednou.<br>
</p>
<p><span style="font-weight: bold;">Q: Vyjde seriál v kuse? Kdy? V jaké
formě?</span><br>
A: Seriál je majetkem portálu Linuxsoft, protože publikování článků pro
Linuxsoft je komerční záležitost (viz např. <a href="http://www.linuxsoft.cz/article.php?id_article=632">tato zpráva</a>).
Jakožto autor tedy nemám přímou možnost cokoli slibovat nebo snad
vydávat seriál najednou na vlastní pěst. Mohu vám však po poradě s
redakcí slíbit, že seriál vcelku <span style="font-weight: bold;">VYJDE</span>.
Způsob zveřejnění a formát bude včas oznámen. Sledujte náš portál.<br>
</p>
<p><span style="font-weight: bold;">Q: Mohu informace ze seriálu
použít/přetisknout/zveřejnit jinde?</span><br>
A: V těchto záležitostech se obracejte na redakci. Ivan (zavináček)
linuxsoft (tečička) cz.<br>
</p>
<p><span style="font-weight: bold;">Q: V seriálu mi chybí [chybějící
věc]. Rozboru [nějaké věci] jste věnoval málo prostoru. [Nějaký kód] se
dá napsat [rychleji | jednodušeji | bezpečněji].</span><br>
A: To je možné. Jsem jen člověk a dělám chyby. Každý seriál jednoho
autora "trpí" tím, že autor používá nějaké schéma (paradigma,
chcete-li) či úhel pohledu. I když byl seriál rozsáhlý, nemohl
rozebírat všechno, nemohl suplovat PHP manuál a není dané, že se z něj
čtenář dozví úplně všechno. Můžete však přispět do diskusí pod články a
obohatit tak ostatní. Příjemně mě potěšilo, že kladných reakcí bylo víc
než negativních.<br>
</p>
<p><span style="font-weight: bold;">Q: Nefunguje mi [příklad | postup |
nastavení]! Co s tím?</span><br>
A: Na dotazy kolem zveřejněných příkladů se podle možnosti snažím
odpovídat. Pokud se dotaz týká něčeho jiného (např. nastavení webového
serveru, operačního systému a podobně), zkuste štěstí v diskusi pod
článkem. Protože jednotlivé stroje,
systémy a konfigurace mohou být poměrně různorodé, je možné, že něco
někde nebude fungovat tak, jak je to v seriálu popisováno.<br>
</p>
<p><span style="font-weight: bold;">Q: Obarvování kódu je hezké. Jak
jste to dělali?</span><br>
A: Základ je v použití funkce <a href="http://cz.php.net/manual/cs/function.highlight-string.php">highlight_string</a>.
Ačkoli to z
bezpečnostních důvodů nechci vypisovat celé, hrubá kostra skriptu je
asi následující:</p>
<!-- Zaza PHP kód BEGIN -->
<div class="codes"><code><font color="#000000"><font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">function </font><font color="#0000bb">obsahsouboru </font><font color="#007700">(</font><font color="#0000bb">$file</font><font color="#007700">)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$soubor</font><font color="#007700">=</font><font color="#0000bb">fopen</font><font color="#007700">(</font><font color="#0000bb">$file</font><font color="#007700">, </font><font color="#dd0000">"r"</font><font color="#007700">); <br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$obsah</font><font color="#007700">=</font><font color="#0000bb">fread</font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">, </font><font color="#0000bb">50000</font><font color="#007700">); <br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#ff8000">// odstranění
citlivých údajů<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">fclose </font><font color="#007700">(</font><font color="#0000bb">$soubor</font><font color="#007700">);&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">ob_start</font><font color="#007700">();<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">highlight_string</font><font color="#007700">(</font><font color="#0000bb">$obsah</font><font color="#007700">);<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">$contents </font><font color="#007700">= </font><font color="#0000bb">ob_get_contents</font><font color="#007700">();<br>
&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000bb">ob_end_clean</font><font color="#007700">();<br>
&nbsp;&nbsp;&nbsp;&nbsp;return </font><font color="#0000bb">$contents</font><font color="#007700">;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;</font><font color="#ff8000">// bezpečnostní kontroly ...<br>
&nbsp;&nbsp;</font><font color="#0000bb">?&gt;<br>
</font>&nbsp;&nbsp;&lt;head&gt;<br>
&nbsp;&nbsp;&lt;meta http-equiv="Content-Type" content="text/html;
charset=utf-8"&gt;<br>
&nbsp;&nbsp;&lt;/head&gt;<br>
<font color="#0000bb">&lt;?<br>
&nbsp;&nbsp;</font><font color="#007700">echo </font><font color="#0000bb">obsahsouboru </font><font color="#007700">(</font><font color="#0000bb">$file</font><font color="#007700">.</font><font color="#dd0000">".php"</font><font color="#007700">);<br>
</font><font color="#0000bb">?&gt;<br>
</font>
</font></code></div>
<!-- Zaza PHP kód END -->
<p><span style="font-weight: bold;">Q: Co se chystá po dokončení
seriálu? Vyjde něco dalšího?</span><br>
A: Chystáme seriál o MySQL. Sledujte linuxsoft.cz, dozvíte se víc.
(Doplněno 16.4.2005 - ten seriál už je <a href="http://www.linuxsoft.cz/article_list.php?id_kategory=232">v běhu</a>)<br>
</p>
<p><span style="font-weight: bold;">Q: Mohu také psát pro Linuxsoft?</span><br>
A: <a href="http://www.linuxsoft.cz/article.php?id_article=632">Zde je
odpověď</a>.<br>
</p>
<p><span style="font-weight: bold;">Q: Co děláte kromě psaní článků pro
Linuxsoft? Mohl byste mi pomoci s [projektem | webem | programem |
funkcí | ...]</span><br>
A: Živím se jako programátor. Na Linuxsoftu nezveřejňuji informace o
svých projektech, protože je to portál a ne reklamní plocha. Pokud
budete chtít něco, co se netýká série článků o PHP, můžete se na mě
obrátit e-mailem. Kontaktní informace najdete v mém <a href="http://www.linuxsoft.cz/user_page.php?user_id=1428">profilu</a>.<br>
</p>
<p> </p>
<p> </p>
<a name="000450"></a><h2>Závěr</h2>
<p>Poděkování patří: <br>
</p>
<ul>
  <li>týmu Linuxsoftu (František, Ivan, Honza, ...) za vstřícný
přístup, </li>
  <li>všem, kdo mě podporovali (kritizovali, učili a postrkovali)
prostřednictvím diskusí a e-mailů, </li>
  <li>Ing. Emilu Kollertovi (to byl můj první učitel programování v
Basicu na IQ 151) za to, že ve mě vypěstoval lásku k počítačům </li>
  <li>vám všem, kdo to čtete, že jste se dostali až sem ;-)))</li>
  <li>Jakubovi Vránovi, který si můj seriál přečetl a konstruktivně jej
připomínkoval (jeho <a href="http://php.vrana.cz/">blog</a>)<br>
  </li>
</ul>
<p>Seriál nezahazujte. Protože se zde budou dělat korekce a úpravy,
věřím, že se nám povede udržet tento materiál aktuální a že vám pomůže
i
v budoucnosti. Loučím se s vámi a přeji vám mnoho příjemných chvil
strávených ve "společnosti" rychlých internetových lajn, spolehlivých
serverů a elegantních prográmků v PHP.<br>
</p>
<p>Petr Zajíc, autor</p>
</div></div></body></html>
